//
// File generated by /apps/root/5.34.36/root//bin/rootcint at Mon Nov 25 15:22:54 2019

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME srcdIbankvarsDict
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "bankvarsDict.h"

#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"

// Direct notice to TROOT of the dictionary's loading.
namespace {
   static struct DictInit {
      DictInit() {
         ROOT::RegisterModule();
      }
   } __TheDictionaryInitializer;
}

// START OF SHADOWS

namespace ROOTShadow {
   namespace Shadow {
   } // of namespace Shadow
} // of namespace ROOTShadow
// END OF SHADOWS

namespace ROOTDict {
   void BEAM_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void BEAM_t_Dictionary();
   static void *new_BEAM_t(void *p = 0);
   static void *newArray_BEAM_t(Long_t size, void *p);
   static void delete_BEAM_t(void *p);
   static void deleteArray_BEAM_t(void *p);
   static void destruct_BEAM_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::BEAM_t*)
   {
      ::BEAM_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BEAM_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("BEAM_t", "./include/bankheader.h", 13,
                  typeid(::BEAM_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &BEAM_t_Dictionary, isa_proxy, 0,
                  sizeof(::BEAM_t) );
      instance.SetNew(&new_BEAM_t);
      instance.SetNewArray(&newArray_BEAM_t);
      instance.SetDelete(&delete_BEAM_t);
      instance.SetDeleteArray(&deleteArray_BEAM_t);
      instance.SetDestructor(&destruct_BEAM_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::BEAM_t*)
   {
      return GenerateInitInstanceLocal((::BEAM_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BEAM_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void BEAM_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::BEAM_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void BMPR_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void BMPR_t_Dictionary();
   static void *new_BMPR_t(void *p = 0);
   static void *newArray_BMPR_t(Long_t size, void *p);
   static void delete_BMPR_t(void *p);
   static void deleteArray_BMPR_t(void *p);
   static void destruct_BMPR_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::BMPR_t*)
   {
      ::BMPR_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BMPR_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("BMPR_t", "./include/bankheader.h", 19,
                  typeid(::BMPR_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &BMPR_t_Dictionary, isa_proxy, 0,
                  sizeof(::BMPR_t) );
      instance.SetNew(&new_BMPR_t);
      instance.SetNewArray(&newArray_BMPR_t);
      instance.SetDelete(&delete_BMPR_t);
      instance.SetDeleteArray(&deleteArray_BMPR_t);
      instance.SetDestructor(&destruct_BMPR_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::BMPR_t*)
   {
      return GenerateInitInstanceLocal((::BMPR_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BMPR_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void BMPR_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::BMPR_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void BREP_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void BREP_t_Dictionary();
   static void *new_BREP_t(void *p = 0);
   static void *newArray_BREP_t(Long_t size, void *p);
   static void delete_BREP_t(void *p);
   static void deleteArray_BREP_t(void *p);
   static void destruct_BREP_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::BREP_t*)
   {
      ::BREP_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BREP_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("BREP_t", "./include/bankheader.h", 57,
                  typeid(::BREP_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &BREP_t_Dictionary, isa_proxy, 0,
                  sizeof(::BREP_t) );
      instance.SetNew(&new_BREP_t);
      instance.SetNewArray(&newArray_BREP_t);
      instance.SetDelete(&delete_BREP_t);
      instance.SetDeleteArray(&deleteArray_BREP_t);
      instance.SetDestructor(&destruct_BREP_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::BREP_t*)
   {
      return GenerateInitInstanceLocal((::BREP_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BREP_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void BREP_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::BREP_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CALB_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CALB_t_Dictionary();
   static void *new_CALB_t(void *p = 0);
   static void *newArray_CALB_t(Long_t size, void *p);
   static void delete_CALB_t(void *p);
   static void deleteArray_CALB_t(void *p);
   static void destruct_CALB_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CALB_t*)
   {
      ::CALB_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CALB_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CALB_t", "./include/bankheader.h", 71,
                  typeid(::CALB_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CALB_t_Dictionary, isa_proxy, 0,
                  sizeof(::CALB_t) );
      instance.SetNew(&new_CALB_t);
      instance.SetNewArray(&newArray_CALB_t);
      instance.SetDelete(&delete_CALB_t);
      instance.SetDeleteArray(&deleteArray_CALB_t);
      instance.SetDestructor(&destruct_CALB_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CALB_t*)
   {
      return GenerateInitInstanceLocal((::CALB_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CALB_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CALB_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CALB_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CALL_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CALL_t_Dictionary();
   static void *new_CALL_t(void *p = 0);
   static void *newArray_CALL_t(Long_t size, void *p);
   static void delete_CALL_t(void *p);
   static void deleteArray_CALL_t(void *p);
   static void destruct_CALL_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CALL_t*)
   {
      ::CALL_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CALL_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CALL_t", "./include/bankheader.h", 76,
                  typeid(::CALL_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CALL_t_Dictionary, isa_proxy, 0,
                  sizeof(::CALL_t) );
      instance.SetNew(&new_CALL_t);
      instance.SetNewArray(&newArray_CALL_t);
      instance.SetDelete(&delete_CALL_t);
      instance.SetDeleteArray(&deleteArray_CALL_t);
      instance.SetDestructor(&destruct_CALL_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CALL_t*)
   {
      return GenerateInitInstanceLocal((::CALL_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CALL_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CALL_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CALL_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CC01_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CC01_t_Dictionary();
   static void *new_CC01_t(void *p = 0);
   static void *newArray_CC01_t(Long_t size, void *p);
   static void delete_CC01_t(void *p);
   static void deleteArray_CC01_t(void *p);
   static void destruct_CC01_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CC01_t*)
   {
      ::CC01_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CC01_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CC01_t", "./include/bankheader.h", 81,
                  typeid(::CC01_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CC01_t_Dictionary, isa_proxy, 0,
                  sizeof(::CC01_t) );
      instance.SetNew(&new_CC01_t);
      instance.SetNewArray(&newArray_CC01_t);
      instance.SetDelete(&delete_CC01_t);
      instance.SetDeleteArray(&deleteArray_CC01_t);
      instance.SetDestructor(&destruct_CC01_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CC01_t*)
   {
      return GenerateInitInstanceLocal((::CC01_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CC01_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CC01_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CC01_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CC1_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CC1_t_Dictionary();
   static void *new_CC1_t(void *p = 0);
   static void *newArray_CC1_t(Long_t size, void *p);
   static void delete_CC1_t(void *p);
   static void deleteArray_CC1_t(void *p);
   static void destruct_CC1_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CC1_t*)
   {
      ::CC1_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CC1_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CC1_t", "./include/bankheader.h", 86,
                  typeid(::CC1_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CC1_t_Dictionary, isa_proxy, 0,
                  sizeof(::CC1_t) );
      instance.SetNew(&new_CC1_t);
      instance.SetNewArray(&newArray_CC1_t);
      instance.SetDelete(&delete_CC1_t);
      instance.SetDeleteArray(&deleteArray_CC1_t);
      instance.SetDestructor(&destruct_CC1_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CC1_t*)
   {
      return GenerateInitInstanceLocal((::CC1_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CC1_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CC1_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CC1_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CC_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CC_t_Dictionary();
   static void *new_CC_t(void *p = 0);
   static void *newArray_CC_t(Long_t size, void *p);
   static void delete_CC_t(void *p);
   static void deleteArray_CC_t(void *p);
   static void destruct_CC_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CC_t*)
   {
      ::CC_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CC_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CC_t", "./include/bankheader.h", 91,
                  typeid(::CC_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CC_t_Dictionary, isa_proxy, 0,
                  sizeof(::CC_t) );
      instance.SetNew(&new_CC_t);
      instance.SetNewArray(&newArray_CC_t);
      instance.SetDelete(&delete_CC_t);
      instance.SetDeleteArray(&deleteArray_CC_t);
      instance.SetDestructor(&destruct_CC_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CC_t*)
   {
      return GenerateInitInstanceLocal((::CC_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CC_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CC_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CC_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CCDI_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CCDI_t_Dictionary();
   static void *new_CCDI_t(void *p = 0);
   static void *newArray_CCDI_t(Long_t size, void *p);
   static void delete_CCDI_t(void *p);
   static void deleteArray_CCDI_t(void *p);
   static void destruct_CCDI_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CCDI_t*)
   {
      ::CCDI_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CCDI_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CCDI_t", "./include/bankheader.h", 98,
                  typeid(::CCDI_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CCDI_t_Dictionary, isa_proxy, 0,
                  sizeof(::CCDI_t) );
      instance.SetNew(&new_CCDI_t);
      instance.SetNewArray(&newArray_CCDI_t);
      instance.SetDelete(&delete_CCDI_t);
      instance.SetDeleteArray(&deleteArray_CCDI_t);
      instance.SetDestructor(&destruct_CCDI_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CCDI_t*)
   {
      return GenerateInitInstanceLocal((::CCDI_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CCDI_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CCDI_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CCDI_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CCH_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CCH_t_Dictionary();
   static void *new_CCH_t(void *p = 0);
   static void *newArray_CCH_t(Long_t size, void *p);
   static void delete_CCH_t(void *p);
   static void deleteArray_CCH_t(void *p);
   static void destruct_CCH_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CCH_t*)
   {
      ::CCH_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CCH_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CCH_t", "./include/bankheader.h", 112,
                  typeid(::CCH_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CCH_t_Dictionary, isa_proxy, 0,
                  sizeof(::CCH_t) );
      instance.SetNew(&new_CCH_t);
      instance.SetNewArray(&newArray_CCH_t);
      instance.SetDelete(&delete_CCH_t);
      instance.SetDeleteArray(&deleteArray_CCH_t);
      instance.SetDestructor(&destruct_CCH_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CCH_t*)
   {
      return GenerateInitInstanceLocal((::CCH_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CCH_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CCH_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CCH_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CCMT_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CCMT_t_Dictionary();
   static void *new_CCMT_t(void *p = 0);
   static void *newArray_CCMT_t(Long_t size, void *p);
   static void delete_CCMT_t(void *p);
   static void deleteArray_CCMT_t(void *p);
   static void destruct_CCMT_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CCMT_t*)
   {
      ::CCMT_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CCMT_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CCMT_t", "./include/bankheader.h", 116,
                  typeid(::CCMT_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CCMT_t_Dictionary, isa_proxy, 0,
                  sizeof(::CCMT_t) );
      instance.SetNew(&new_CCMT_t);
      instance.SetNewArray(&newArray_CCMT_t);
      instance.SetDelete(&delete_CCMT_t);
      instance.SetDeleteArray(&deleteArray_CCMT_t);
      instance.SetDestructor(&destruct_CCMT_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CCMT_t*)
   {
      return GenerateInitInstanceLocal((::CCMT_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CCMT_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CCMT_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CCMT_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CCPB_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CCPB_t_Dictionary();
   static void *new_CCPB_t(void *p = 0);
   static void *newArray_CCPB_t(Long_t size, void *p);
   static void delete_CCPB_t(void *p);
   static void deleteArray_CCPB_t(void *p);
   static void destruct_CCPB_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CCPB_t*)
   {
      ::CCPB_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CCPB_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CCPB_t", "./include/bankheader.h", 124,
                  typeid(::CCPB_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CCPB_t_Dictionary, isa_proxy, 0,
                  sizeof(::CCPB_t) );
      instance.SetNew(&new_CCPB_t);
      instance.SetNewArray(&newArray_CCPB_t);
      instance.SetDelete(&delete_CCPB_t);
      instance.SetDeleteArray(&deleteArray_CCPB_t);
      instance.SetDestructor(&destruct_CCPB_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CCPB_t*)
   {
      return GenerateInitInstanceLocal((::CCPB_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CCPB_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CCPB_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CCPB_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CCPE_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CCPE_t_Dictionary();
   static void *new_CCPE_t(void *p = 0);
   static void *newArray_CCPE_t(Long_t size, void *p);
   static void delete_CCPE_t(void *p);
   static void deleteArray_CCPE_t(void *p);
   static void destruct_CCPE_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CCPE_t*)
   {
      ::CCPE_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CCPE_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CCPE_t", "./include/bankheader.h", 129,
                  typeid(::CCPE_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CCPE_t_Dictionary, isa_proxy, 0,
                  sizeof(::CCPE_t) );
      instance.SetNew(&new_CCPE_t);
      instance.SetNewArray(&newArray_CCPE_t);
      instance.SetDelete(&delete_CCPE_t);
      instance.SetDeleteArray(&deleteArray_CCPE_t);
      instance.SetDestructor(&destruct_CCPE_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CCPE_t*)
   {
      return GenerateInitInstanceLocal((::CCPE_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CCPE_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CCPE_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CCPE_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CCRC_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CCRC_t_Dictionary();
   static void *new_CCRC_t(void *p = 0);
   static void *newArray_CCRC_t(Long_t size, void *p);
   static void delete_CCRC_t(void *p);
   static void deleteArray_CCRC_t(void *p);
   static void destruct_CCRC_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CCRC_t*)
   {
      ::CCRC_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CCRC_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CCRC_t", "./include/bankheader.h", 143,
                  typeid(::CCRC_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CCRC_t_Dictionary, isa_proxy, 0,
                  sizeof(::CCRC_t) );
      instance.SetNew(&new_CCRC_t);
      instance.SetNewArray(&newArray_CCRC_t);
      instance.SetDelete(&delete_CCRC_t);
      instance.SetDeleteArray(&deleteArray_CCRC_t);
      instance.SetDestructor(&destruct_CCRC_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CCRC_t*)
   {
      return GenerateInitInstanceLocal((::CCRC_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CCRC_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CCRC_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CCRC_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CCS_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CCS_t_Dictionary();
   static void *new_CCS_t(void *p = 0);
   static void *newArray_CCS_t(Long_t size, void *p);
   static void delete_CCS_t(void *p);
   static void deleteArray_CCS_t(void *p);
   static void destruct_CCS_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CCS_t*)
   {
      ::CCS_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CCS_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CCS_t", "./include/bankheader.h", 241,
                  typeid(::CCS_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CCS_t_Dictionary, isa_proxy, 0,
                  sizeof(::CCS_t) );
      instance.SetNew(&new_CCS_t);
      instance.SetNewArray(&newArray_CCS_t);
      instance.SetDelete(&delete_CCS_t);
      instance.SetDeleteArray(&deleteArray_CCS_t);
      instance.SetDestructor(&destruct_CCS_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CCS_t*)
   {
      return GenerateInitInstanceLocal((::CCS_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CCS_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CCS_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CCS_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CCT_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CCT_t_Dictionary();
   static void *new_CCT_t(void *p = 0);
   static void *newArray_CCT_t(Long_t size, void *p);
   static void delete_CCT_t(void *p);
   static void deleteArray_CCT_t(void *p);
   static void destruct_CCT_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CCT_t*)
   {
      ::CCT_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CCT_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CCT_t", "./include/bankheader.h", 245,
                  typeid(::CCT_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CCT_t_Dictionary, isa_proxy, 0,
                  sizeof(::CCT_t) );
      instance.SetNew(&new_CCT_t);
      instance.SetNewArray(&newArray_CCT_t);
      instance.SetDelete(&delete_CCT_t);
      instance.SetDeleteArray(&deleteArray_CCT_t);
      instance.SetDestructor(&destruct_CCT_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CCT_t*)
   {
      return GenerateInitInstanceLocal((::CCT_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CCT_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CCT_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CCT_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CHI2_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CHI2_t_Dictionary();
   static void *new_CHI2_t(void *p = 0);
   static void *newArray_CHI2_t(Long_t size, void *p);
   static void delete_CHI2_t(void *p);
   static void deleteArray_CHI2_t(void *p);
   static void destruct_CHI2_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CHI2_t*)
   {
      ::CHI2_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CHI2_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CHI2_t", "./include/bankheader.h", 251,
                  typeid(::CHI2_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CHI2_t_Dictionary, isa_proxy, 0,
                  sizeof(::CHI2_t) );
      instance.SetNew(&new_CHI2_t);
      instance.SetNewArray(&newArray_CHI2_t);
      instance.SetDelete(&delete_CHI2_t);
      instance.SetDeleteArray(&deleteArray_CHI2_t);
      instance.SetDestructor(&destruct_CHI2_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CHI2_t*)
   {
      return GenerateInitInstanceLocal((::CHI2_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CHI2_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CHI2_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CHI2_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CL01_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CL01_t_Dictionary();
   static void *new_CL01_t(void *p = 0);
   static void *newArray_CL01_t(Long_t size, void *p);
   static void delete_CL01_t(void *p);
   static void deleteArray_CL01_t(void *p);
   static void destruct_CL01_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CL01_t*)
   {
      ::CL01_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CL01_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CL01_t", "./include/bankheader.h", 265,
                  typeid(::CL01_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CL01_t_Dictionary, isa_proxy, 0,
                  sizeof(::CL01_t) );
      instance.SetNew(&new_CL01_t);
      instance.SetNewArray(&newArray_CL01_t);
      instance.SetDelete(&delete_CL01_t);
      instance.SetDeleteArray(&deleteArray_CL01_t);
      instance.SetDestructor(&destruct_CL01_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CL01_t*)
   {
      return GenerateInitInstanceLocal((::CL01_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CL01_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CL01_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CL01_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CLST_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CLST_t_Dictionary();
   static void *new_CLST_t(void *p = 0);
   static void *newArray_CLST_t(Long_t size, void *p);
   static void delete_CLST_t(void *p);
   static void deleteArray_CLST_t(void *p);
   static void destruct_CLST_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CLST_t*)
   {
      ::CLST_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CLST_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CLST_t", "./include/bankheader.h", 268,
                  typeid(::CLST_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CLST_t_Dictionary, isa_proxy, 0,
                  sizeof(::CLST_t) );
      instance.SetNew(&new_CLST_t);
      instance.SetNewArray(&newArray_CLST_t);
      instance.SetDelete(&delete_CLST_t);
      instance.SetDeleteArray(&deleteArray_CLST_t);
      instance.SetDestructor(&destruct_CLST_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CLST_t*)
   {
      return GenerateInitInstanceLocal((::CLST_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CLST_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CLST_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CLST_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CPED_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CPED_t_Dictionary();
   static void *new_CPED_t(void *p = 0);
   static void *newArray_CPED_t(Long_t size, void *p);
   static void delete_CPED_t(void *p);
   static void deleteArray_CPED_t(void *p);
   static void destruct_CPED_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CPED_t*)
   {
      ::CPED_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CPED_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CPED_t", "./include/bankheader.h", 275,
                  typeid(::CPED_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CPED_t_Dictionary, isa_proxy, 0,
                  sizeof(::CPED_t) );
      instance.SetNew(&new_CPED_t);
      instance.SetNewArray(&newArray_CPED_t);
      instance.SetDelete(&delete_CPED_t);
      instance.SetDeleteArray(&deleteArray_CPED_t);
      instance.SetDestructor(&destruct_CPED_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CPED_t*)
   {
      return GenerateInitInstanceLocal((::CPED_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CPED_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CPED_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CPED_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void CSQL_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void CSQL_t_Dictionary();
   static void *new_CSQL_t(void *p = 0);
   static void *newArray_CSQL_t(Long_t size, void *p);
   static void delete_CSQL_t(void *p);
   static void deleteArray_CSQL_t(void *p);
   static void destruct_CSQL_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::CSQL_t*)
   {
      ::CSQL_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::CSQL_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("CSQL_t", "./include/bankheader.h", 298,
                  typeid(::CSQL_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &CSQL_t_Dictionary, isa_proxy, 0,
                  sizeof(::CSQL_t) );
      instance.SetNew(&new_CSQL_t);
      instance.SetNewArray(&newArray_CSQL_t);
      instance.SetDelete(&delete_CSQL_t);
      instance.SetDeleteArray(&deleteArray_CSQL_t);
      instance.SetDestructor(&destruct_CSQL_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::CSQL_t*)
   {
      return GenerateInitInstanceLocal((::CSQL_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::CSQL_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void CSQL_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::CSQL_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DC0_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DC0_t_Dictionary();
   static void *new_DC0_t(void *p = 0);
   static void *newArray_DC0_t(Long_t size, void *p);
   static void delete_DC0_t(void *p);
   static void deleteArray_DC0_t(void *p);
   static void destruct_DC0_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DC0_t*)
   {
      ::DC0_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DC0_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DC0_t", "./include/bankheader.h", 302,
                  typeid(::DC0_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DC0_t_Dictionary, isa_proxy, 0,
                  sizeof(::DC0_t) );
      instance.SetNew(&new_DC0_t);
      instance.SetNewArray(&newArray_DC0_t);
      instance.SetDelete(&delete_DC0_t);
      instance.SetDeleteArray(&deleteArray_DC0_t);
      instance.SetDestructor(&destruct_DC0_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DC0_t*)
   {
      return GenerateInitInstanceLocal((::DC0_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DC0_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DC0_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DC0_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DC1_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DC1_t_Dictionary();
   static void *new_DC1_t(void *p = 0);
   static void *newArray_DC1_t(Long_t size, void *p);
   static void delete_DC1_t(void *p);
   static void deleteArray_DC1_t(void *p);
   static void destruct_DC1_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DC1_t*)
   {
      ::DC1_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DC1_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DC1_t", "./include/bankheader.h", 306,
                  typeid(::DC1_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DC1_t_Dictionary, isa_proxy, 0,
                  sizeof(::DC1_t) );
      instance.SetNew(&new_DC1_t);
      instance.SetNewArray(&newArray_DC1_t);
      instance.SetDelete(&delete_DC1_t);
      instance.SetDeleteArray(&deleteArray_DC1_t);
      instance.SetDestructor(&destruct_DC1_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DC1_t*)
   {
      return GenerateInitInstanceLocal((::DC1_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DC1_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DC1_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DC1_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DCDW_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DCDW_t_Dictionary();
   static void *new_DCDW_t(void *p = 0);
   static void *newArray_DCDW_t(Long_t size, void *p);
   static void delete_DCDW_t(void *p);
   static void deleteArray_DCDW_t(void *p);
   static void destruct_DCDW_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DCDW_t*)
   {
      ::DCDW_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DCDW_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DCDW_t", "./include/bankheader.h", 311,
                  typeid(::DCDW_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DCDW_t_Dictionary, isa_proxy, 0,
                  sizeof(::DCDW_t) );
      instance.SetNew(&new_DCDW_t);
      instance.SetNewArray(&newArray_DCDW_t);
      instance.SetDelete(&delete_DCDW_t);
      instance.SetDeleteArray(&deleteArray_DCDW_t);
      instance.SetDestructor(&destruct_DCDW_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DCDW_t*)
   {
      return GenerateInitInstanceLocal((::DCDW_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DCDW_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DCDW_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DCDW_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DCGM_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DCGM_t_Dictionary();
   static void *new_DCGM_t(void *p = 0);
   static void *newArray_DCGM_t(Long_t size, void *p);
   static void delete_DCGM_t(void *p);
   static void deleteArray_DCGM_t(void *p);
   static void destruct_DCGM_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DCGM_t*)
   {
      ::DCGM_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DCGM_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DCGM_t", "./include/bankheader.h", 334,
                  typeid(::DCGM_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DCGM_t_Dictionary, isa_proxy, 0,
                  sizeof(::DCGM_t) );
      instance.SetNew(&new_DCGM_t);
      instance.SetNewArray(&newArray_DCGM_t);
      instance.SetDelete(&delete_DCGM_t);
      instance.SetDeleteArray(&deleteArray_DCGM_t);
      instance.SetDestructor(&destruct_DCGM_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DCGM_t*)
   {
      return GenerateInitInstanceLocal((::DCGM_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DCGM_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DCGM_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DCGM_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DCGW_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DCGW_t_Dictionary();
   static void *new_DCGW_t(void *p = 0);
   static void *newArray_DCGW_t(Long_t size, void *p);
   static void delete_DCGW_t(void *p);
   static void deleteArray_DCGW_t(void *p);
   static void destruct_DCGW_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DCGW_t*)
   {
      ::DCGW_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DCGW_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DCGW_t", "./include/bankheader.h", 344,
                  typeid(::DCGW_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DCGW_t_Dictionary, isa_proxy, 0,
                  sizeof(::DCGW_t) );
      instance.SetNew(&new_DCGW_t);
      instance.SetNewArray(&newArray_DCGW_t);
      instance.SetDelete(&delete_DCGW_t);
      instance.SetDeleteArray(&deleteArray_DCGW_t);
      instance.SetDestructor(&destruct_DCGW_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DCGW_t*)
   {
      return GenerateInitInstanceLocal((::DCGW_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DCGW_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DCGW_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DCGW_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DCH_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DCH_t_Dictionary();
   static void *new_DCH_t(void *p = 0);
   static void *newArray_DCH_t(Long_t size, void *p);
   static void delete_DCH_t(void *p);
   static void deleteArray_DCH_t(void *p);
   static void destruct_DCH_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DCH_t*)
   {
      ::DCH_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DCH_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DCH_t", "./include/bankheader.h", 359,
                  typeid(::DCH_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DCH_t_Dictionary, isa_proxy, 0,
                  sizeof(::DCH_t) );
      instance.SetNew(&new_DCH_t);
      instance.SetNewArray(&newArray_DCH_t);
      instance.SetDelete(&delete_DCH_t);
      instance.SetDeleteArray(&deleteArray_DCH_t);
      instance.SetDestructor(&destruct_DCH_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DCH_t*)
   {
      return GenerateInitInstanceLocal((::DCH_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DCH_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DCH_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DCH_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DCMN_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DCMN_t_Dictionary();
   static void *new_DCMN_t(void *p = 0);
   static void *newArray_DCMN_t(Long_t size, void *p);
   static void delete_DCMN_t(void *p);
   static void deleteArray_DCMN_t(void *p);
   static void destruct_DCMN_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DCMN_t*)
   {
      ::DCMN_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DCMN_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DCMN_t", "./include/bankheader.h", 411,
                  typeid(::DCMN_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DCMN_t_Dictionary, isa_proxy, 0,
                  sizeof(::DCMN_t) );
      instance.SetNew(&new_DCMN_t);
      instance.SetNewArray(&newArray_DCMN_t);
      instance.SetDelete(&delete_DCMN_t);
      instance.SetDeleteArray(&deleteArray_DCMN_t);
      instance.SetDestructor(&destruct_DCMN_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DCMN_t*)
   {
      return GenerateInitInstanceLocal((::DCMN_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DCMN_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DCMN_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DCMN_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DCPB_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DCPB_t_Dictionary();
   static void *new_DCPB_t(void *p = 0);
   static void *newArray_DCPB_t(Long_t size, void *p);
   static void delete_DCPB_t(void *p);
   static void deleteArray_DCPB_t(void *p);
   static void destruct_DCPB_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DCPB_t*)
   {
      ::DCPB_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DCPB_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DCPB_t", "./include/bankheader.h", 426,
                  typeid(::DCPB_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DCPB_t_Dictionary, isa_proxy, 0,
                  sizeof(::DCPB_t) );
      instance.SetNew(&new_DCPB_t);
      instance.SetNewArray(&newArray_DCPB_t);
      instance.SetDelete(&delete_DCPB_t);
      instance.SetDeleteArray(&deleteArray_DCPB_t);
      instance.SetDestructor(&destruct_DCPB_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DCPB_t*)
   {
      return GenerateInitInstanceLocal((::DCPB_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DCPB_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DCPB_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DCPB_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DCV1_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DCV1_t_Dictionary();
   static void *new_DCV1_t(void *p = 0);
   static void *newArray_DCV1_t(Long_t size, void *p);
   static void delete_DCV1_t(void *p);
   static void deleteArray_DCV1_t(void *p);
   static void destruct_DCV1_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DCV1_t*)
   {
      ::DCV1_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DCV1_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DCV1_t", "./include/bankheader.h", 433,
                  typeid(::DCV1_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DCV1_t_Dictionary, isa_proxy, 0,
                  sizeof(::DCV1_t) );
      instance.SetNew(&new_DCV1_t);
      instance.SetNewArray(&newArray_DCV1_t);
      instance.SetDelete(&delete_DCV1_t);
      instance.SetDeleteArray(&deleteArray_DCV1_t);
      instance.SetDestructor(&destruct_DCV1_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DCV1_t*)
   {
      return GenerateInitInstanceLocal((::DCV1_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DCV1_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DCV1_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DCV1_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DCV2_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DCV2_t_Dictionary();
   static void *new_DCV2_t(void *p = 0);
   static void *newArray_DCV2_t(Long_t size, void *p);
   static void delete_DCV2_t(void *p);
   static void deleteArray_DCV2_t(void *p);
   static void destruct_DCV2_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DCV2_t*)
   {
      ::DCV2_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DCV2_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DCV2_t", "./include/bankheader.h", 449,
                  typeid(::DCV2_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DCV2_t_Dictionary, isa_proxy, 0,
                  sizeof(::DCV2_t) );
      instance.SetNew(&new_DCV2_t);
      instance.SetNewArray(&newArray_DCV2_t);
      instance.SetDelete(&delete_DCV2_t);
      instance.SetDeleteArray(&deleteArray_DCV2_t);
      instance.SetDestructor(&destruct_DCV2_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DCV2_t*)
   {
      return GenerateInitInstanceLocal((::DCV2_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DCV2_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DCV2_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DCV2_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DCV3_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DCV3_t_Dictionary();
   static void *new_DCV3_t(void *p = 0);
   static void *newArray_DCV3_t(Long_t size, void *p);
   static void delete_DCV3_t(void *p);
   static void deleteArray_DCV3_t(void *p);
   static void destruct_DCV3_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DCV3_t*)
   {
      ::DCV3_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DCV3_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DCV3_t", "./include/bankheader.h", 456,
                  typeid(::DCV3_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DCV3_t_Dictionary, isa_proxy, 0,
                  sizeof(::DCV3_t) );
      instance.SetNew(&new_DCV3_t);
      instance.SetNewArray(&newArray_DCV3_t);
      instance.SetDelete(&delete_DCV3_t);
      instance.SetDeleteArray(&deleteArray_DCV3_t);
      instance.SetDestructor(&destruct_DCV3_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DCV3_t*)
   {
      return GenerateInitInstanceLocal((::DCV3_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DCV3_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DCV3_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DCV3_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DDLY_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DDLY_t_Dictionary();
   static void *new_DDLY_t(void *p = 0);
   static void *newArray_DDLY_t(Long_t size, void *p);
   static void delete_DDLY_t(void *p);
   static void deleteArray_DDLY_t(void *p);
   static void destruct_DDLY_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DDLY_t*)
   {
      ::DDLY_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DDLY_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DDLY_t", "./include/bankheader.h", 461,
                  typeid(::DDLY_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DDLY_t_Dictionary, isa_proxy, 0,
                  sizeof(::DDLY_t) );
      instance.SetNew(&new_DDLY_t);
      instance.SetNewArray(&newArray_DDLY_t);
      instance.SetDelete(&delete_DDLY_t);
      instance.SetDeleteArray(&deleteArray_DDLY_t);
      instance.SetDestructor(&destruct_DDLY_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DDLY_t*)
   {
      return GenerateInitInstanceLocal((::DDLY_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DDLY_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DDLY_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DDLY_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DGEO_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DGEO_t_Dictionary();
   static void *new_DGEO_t(void *p = 0);
   static void *newArray_DGEO_t(Long_t size, void *p);
   static void delete_DGEO_t(void *p);
   static void deleteArray_DGEO_t(void *p);
   static void destruct_DGEO_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DGEO_t*)
   {
      ::DGEO_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DGEO_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DGEO_t", "./include/bankheader.h", 471,
                  typeid(::DGEO_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DGEO_t_Dictionary, isa_proxy, 0,
                  sizeof(::DGEO_t) );
      instance.SetNew(&new_DGEO_t);
      instance.SetNewArray(&newArray_DGEO_t);
      instance.SetDelete(&delete_DGEO_t);
      instance.SetDeleteArray(&deleteArray_DGEO_t);
      instance.SetDestructor(&destruct_DGEO_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DGEO_t*)
   {
      return GenerateInitInstanceLocal((::DGEO_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DGEO_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DGEO_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DGEO_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DHCL_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DHCL_t_Dictionary();
   static void *new_DHCL_t(void *p = 0);
   static void *newArray_DHCL_t(Long_t size, void *p);
   static void delete_DHCL_t(void *p);
   static void deleteArray_DHCL_t(void *p);
   static void destruct_DHCL_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DHCL_t*)
   {
      ::DHCL_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DHCL_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DHCL_t", "./include/bankheader.h", 489,
                  typeid(::DHCL_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DHCL_t_Dictionary, isa_proxy, 0,
                  sizeof(::DHCL_t) );
      instance.SetNew(&new_DHCL_t);
      instance.SetNewArray(&newArray_DHCL_t);
      instance.SetDelete(&delete_DHCL_t);
      instance.SetDeleteArray(&deleteArray_DHCL_t);
      instance.SetDestructor(&destruct_DHCL_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DHCL_t*)
   {
      return GenerateInitInstanceLocal((::DHCL_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DHCL_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DHCL_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DHCL_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DITM_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DITM_t_Dictionary();
   static void *new_DITM_t(void *p = 0);
   static void *newArray_DITM_t(Long_t size, void *p);
   static void delete_DITM_t(void *p);
   static void deleteArray_DITM_t(void *p);
   static void destruct_DITM_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DITM_t*)
   {
      ::DITM_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DITM_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DITM_t", "./include/bankheader.h", 492,
                  typeid(::DITM_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DITM_t_Dictionary, isa_proxy, 0,
                  sizeof(::DITM_t) );
      instance.SetNew(&new_DITM_t);
      instance.SetNewArray(&newArray_DITM_t);
      instance.SetDelete(&delete_DITM_t);
      instance.SetDeleteArray(&deleteArray_DITM_t);
      instance.SetDestructor(&destruct_DITM_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DITM_t*)
   {
      return GenerateInitInstanceLocal((::DITM_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DITM_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DITM_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DITM_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DOCA_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DOCA_t_Dictionary();
   static void *new_DOCA_t(void *p = 0);
   static void *newArray_DOCA_t(Long_t size, void *p);
   static void delete_DOCA_t(void *p);
   static void deleteArray_DOCA_t(void *p);
   static void destruct_DOCA_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DOCA_t*)
   {
      ::DOCA_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DOCA_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DOCA_t", "./include/bankheader.h", 496,
                  typeid(::DOCA_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DOCA_t_Dictionary, isa_proxy, 0,
                  sizeof(::DOCA_t) );
      instance.SetNew(&new_DOCA_t);
      instance.SetNewArray(&newArray_DOCA_t);
      instance.SetDelete(&delete_DOCA_t);
      instance.SetDeleteArray(&deleteArray_DOCA_t);
      instance.SetDestructor(&destruct_DOCA_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DOCA_t*)
   {
      return GenerateInitInstanceLocal((::DOCA_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DOCA_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DOCA_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DOCA_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DPCP_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DPCP_t_Dictionary();
   static void *new_DPCP_t(void *p = 0);
   static void *newArray_DPCP_t(Long_t size, void *p);
   static void delete_DPCP_t(void *p);
   static void deleteArray_DPCP_t(void *p);
   static void destruct_DPCP_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DPCP_t*)
   {
      ::DPCP_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DPCP_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DPCP_t", "./include/bankheader.h", 511,
                  typeid(::DPCP_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DPCP_t_Dictionary, isa_proxy, 0,
                  sizeof(::DPCP_t) );
      instance.SetNew(&new_DPCP_t);
      instance.SetNewArray(&newArray_DPCP_t);
      instance.SetDelete(&delete_DPCP_t);
      instance.SetDeleteArray(&deleteArray_DPCP_t);
      instance.SetDestructor(&destruct_DPCP_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DPCP_t*)
   {
      return GenerateInitInstanceLocal((::DPCP_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DPCP_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DPCP_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DPCP_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DPSP_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DPSP_t_Dictionary();
   static void *new_DPSP_t(void *p = 0);
   static void *newArray_DPSP_t(Long_t size, void *p);
   static void delete_DPSP_t(void *p);
   static void deleteArray_DPSP_t(void *p);
   static void destruct_DPSP_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DPSP_t*)
   {
      ::DPSP_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DPSP_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DPSP_t", "./include/bankheader.h", 516,
                  typeid(::DPSP_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DPSP_t_Dictionary, isa_proxy, 0,
                  sizeof(::DPSP_t) );
      instance.SetNew(&new_DPSP_t);
      instance.SetNewArray(&newArray_DPSP_t);
      instance.SetDelete(&delete_DPSP_t);
      instance.SetDeleteArray(&deleteArray_DPSP_t);
      instance.SetDestructor(&destruct_DPSP_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DPSP_t*)
   {
      return GenerateInitInstanceLocal((::DPSP_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DPSP_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DPSP_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DPSP_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DSPC_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DSPC_t_Dictionary();
   static void *new_DSPC_t(void *p = 0);
   static void *newArray_DSPC_t(Long_t size, void *p);
   static void delete_DSPC_t(void *p);
   static void deleteArray_DSPC_t(void *p);
   static void destruct_DSPC_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DSPC_t*)
   {
      ::DSPC_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DSPC_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DSPC_t", "./include/bankheader.h", 526,
                  typeid(::DSPC_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DSPC_t_Dictionary, isa_proxy, 0,
                  sizeof(::DSPC_t) );
      instance.SetNew(&new_DSPC_t);
      instance.SetNewArray(&newArray_DSPC_t);
      instance.SetDelete(&delete_DSPC_t);
      instance.SetDeleteArray(&deleteArray_DSPC_t);
      instance.SetDestructor(&destruct_DSPC_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DSPC_t*)
   {
      return GenerateInitInstanceLocal((::DSPC_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DSPC_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DSPC_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DSPC_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DSPS_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DSPS_t_Dictionary();
   static void *new_DSPS_t(void *p = 0);
   static void *newArray_DSPS_t(Long_t size, void *p);
   static void delete_DSPS_t(void *p);
   static void deleteArray_DSPS_t(void *p);
   static void destruct_DSPS_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DSPS_t*)
   {
      ::DSPS_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DSPS_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DSPS_t", "./include/bankheader.h", 531,
                  typeid(::DSPS_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DSPS_t_Dictionary, isa_proxy, 0,
                  sizeof(::DSPS_t) );
      instance.SetNew(&new_DSPS_t);
      instance.SetNewArray(&newArray_DSPS_t);
      instance.SetDelete(&delete_DSPS_t);
      instance.SetDeleteArray(&deleteArray_DSPS_t);
      instance.SetDestructor(&destruct_DSPS_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DSPS_t*)
   {
      return GenerateInitInstanceLocal((::DSPS_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DSPS_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DSPS_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DSPS_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DSTC_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DSTC_t_Dictionary();
   static void *new_DSTC_t(void *p = 0);
   static void *newArray_DSTC_t(Long_t size, void *p);
   static void delete_DSTC_t(void *p);
   static void deleteArray_DSTC_t(void *p);
   static void destruct_DSTC_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DSTC_t*)
   {
      ::DSTC_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DSTC_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DSTC_t", "./include/bankheader.h", 542,
                  typeid(::DSTC_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DSTC_t_Dictionary, isa_proxy, 0,
                  sizeof(::DSTC_t) );
      instance.SetNew(&new_DSTC_t);
      instance.SetNewArray(&newArray_DSTC_t);
      instance.SetDelete(&delete_DSTC_t);
      instance.SetDeleteArray(&deleteArray_DSTC_t);
      instance.SetDestructor(&destruct_DSTC_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DSTC_t*)
   {
      return GenerateInitInstanceLocal((::DSTC_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DSTC_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DSTC_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DSTC_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DTCP_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DTCP_t_Dictionary();
   static void *new_DTCP_t(void *p = 0);
   static void *newArray_DTCP_t(Long_t size, void *p);
   static void delete_DTCP_t(void *p);
   static void deleteArray_DTCP_t(void *p);
   static void destruct_DTCP_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DTCP_t*)
   {
      ::DTCP_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DTCP_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DTCP_t", "./include/bankheader.h", 559,
                  typeid(::DTCP_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DTCP_t_Dictionary, isa_proxy, 0,
                  sizeof(::DTCP_t) );
      instance.SetNew(&new_DTCP_t);
      instance.SetNewArray(&newArray_DTCP_t);
      instance.SetDelete(&delete_DTCP_t);
      instance.SetDeleteArray(&deleteArray_DTCP_t);
      instance.SetDestructor(&destruct_DTCP_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DTCP_t*)
   {
      return GenerateInitInstanceLocal((::DTCP_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DTCP_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DTCP_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DTCP_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DTRK_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DTRK_t_Dictionary();
   static void *new_DTRK_t(void *p = 0);
   static void *newArray_DTRK_t(Long_t size, void *p);
   static void delete_DTRK_t(void *p);
   static void deleteArray_DTRK_t(void *p);
   static void destruct_DTRK_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DTRK_t*)
   {
      ::DTRK_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DTRK_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("DTRK_t", "./include/bankheader.h", 564,
                  typeid(::DTRK_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &DTRK_t_Dictionary, isa_proxy, 0,
                  sizeof(::DTRK_t) );
      instance.SetNew(&new_DTRK_t);
      instance.SetNewArray(&newArray_DTRK_t);
      instance.SetDelete(&delete_DTRK_t);
      instance.SetDeleteArray(&deleteArray_DTRK_t);
      instance.SetDestructor(&destruct_DTRK_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DTRK_t*)
   {
      return GenerateInitInstanceLocal((::DTRK_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DTRK_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DTRK_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DTRK_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void EC01_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void EC01_t_Dictionary();
   static void *new_EC01_t(void *p = 0);
   static void *newArray_EC01_t(Long_t size, void *p);
   static void delete_EC01_t(void *p);
   static void deleteArray_EC01_t(void *p);
   static void destruct_EC01_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::EC01_t*)
   {
      ::EC01_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::EC01_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("EC01_t", "./include/bankheader.h", 569,
                  typeid(::EC01_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &EC01_t_Dictionary, isa_proxy, 0,
                  sizeof(::EC01_t) );
      instance.SetNew(&new_EC01_t);
      instance.SetNewArray(&newArray_EC01_t);
      instance.SetDelete(&delete_EC01_t);
      instance.SetDeleteArray(&deleteArray_EC01_t);
      instance.SetDestructor(&destruct_EC01_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::EC01_t*)
   {
      return GenerateInitInstanceLocal((::EC01_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::EC01_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void EC01_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::EC01_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void EC1_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void EC1_t_Dictionary();
   static void *new_EC1_t(void *p = 0);
   static void *newArray_EC1_t(Long_t size, void *p);
   static void delete_EC1_t(void *p);
   static void deleteArray_EC1_t(void *p);
   static void destruct_EC1_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::EC1_t*)
   {
      ::EC1_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::EC1_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("EC1_t", "./include/bankheader.h", 576,
                  typeid(::EC1_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &EC1_t_Dictionary, isa_proxy, 0,
                  sizeof(::EC1_t) );
      instance.SetNew(&new_EC1_t);
      instance.SetNewArray(&newArray_EC1_t);
      instance.SetDelete(&delete_EC1_t);
      instance.SetDeleteArray(&deleteArray_EC1_t);
      instance.SetDestructor(&destruct_EC1_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::EC1_t*)
   {
      return GenerateInitInstanceLocal((::EC1_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::EC1_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void EC1_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::EC1_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void EC1P_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void EC1P_t_Dictionary();
   static void *new_EC1P_t(void *p = 0);
   static void *newArray_EC1P_t(Long_t size, void *p);
   static void delete_EC1P_t(void *p);
   static void deleteArray_EC1P_t(void *p);
   static void destruct_EC1P_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::EC1P_t*)
   {
      ::EC1P_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::EC1P_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("EC1P_t", "./include/bankheader.h", 582,
                  typeid(::EC1P_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &EC1P_t_Dictionary, isa_proxy, 0,
                  sizeof(::EC1P_t) );
      instance.SetNew(&new_EC1P_t);
      instance.SetNewArray(&newArray_EC1P_t);
      instance.SetDelete(&delete_EC1P_t);
      instance.SetDeleteArray(&deleteArray_EC1P_t);
      instance.SetDestructor(&destruct_EC1P_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::EC1P_t*)
   {
      return GenerateInitInstanceLocal((::EC1P_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::EC1P_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void EC1P_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::EC1P_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void EC1R_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void EC1R_t_Dictionary();
   static void *new_EC1R_t(void *p = 0);
   static void *newArray_EC1R_t(Long_t size, void *p);
   static void delete_EC1R_t(void *p);
   static void deleteArray_EC1R_t(void *p);
   static void destruct_EC1R_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::EC1R_t*)
   {
      ::EC1R_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::EC1R_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("EC1R_t", "./include/bankheader.h", 634,
                  typeid(::EC1R_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &EC1R_t_Dictionary, isa_proxy, 0,
                  sizeof(::EC1R_t) );
      instance.SetNew(&new_EC1R_t);
      instance.SetNewArray(&newArray_EC1R_t);
      instance.SetDelete(&delete_EC1R_t);
      instance.SetDeleteArray(&deleteArray_EC1R_t);
      instance.SetDestructor(&destruct_EC1R_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::EC1R_t*)
   {
      return GenerateInitInstanceLocal((::EC1R_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::EC1R_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void EC1R_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::EC1R_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECCA_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECCA_t_Dictionary();
   static void *new_ECCA_t(void *p = 0);
   static void *newArray_ECCA_t(Long_t size, void *p);
   static void delete_ECCA_t(void *p);
   static void deleteArray_ECCA_t(void *p);
   static void destruct_ECCA_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECCA_t*)
   {
      ::ECCA_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECCA_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECCA_t", "./include/bankheader.h", 644,
                  typeid(::ECCA_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECCA_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECCA_t) );
      instance.SetNew(&new_ECCA_t);
      instance.SetNewArray(&newArray_ECCA_t);
      instance.SetDelete(&delete_ECCA_t);
      instance.SetDeleteArray(&deleteArray_ECCA_t);
      instance.SetDestructor(&destruct_ECCA_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECCA_t*)
   {
      return GenerateInitInstanceLocal((::ECCA_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECCA_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECCA_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECCA_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECCL_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECCL_t_Dictionary();
   static void *new_ECCL_t(void *p = 0);
   static void *newArray_ECCL_t(Long_t size, void *p);
   static void delete_ECCL_t(void *p);
   static void deleteArray_ECCL_t(void *p);
   static void destruct_ECCL_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECCL_t*)
   {
      ::ECCL_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECCL_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECCL_t", "./include/bankheader.h", 654,
                  typeid(::ECCL_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECCL_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECCL_t) );
      instance.SetNew(&new_ECCL_t);
      instance.SetNewArray(&newArray_ECCL_t);
      instance.SetDelete(&delete_ECCL_t);
      instance.SetDeleteArray(&deleteArray_ECCL_t);
      instance.SetDestructor(&destruct_ECCL_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECCL_t*)
   {
      return GenerateInitInstanceLocal((::ECCL_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECCL_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECCL_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECCL_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECCT_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECCT_t_Dictionary();
   static void *new_ECCT_t(void *p = 0);
   static void *newArray_ECCT_t(Long_t size, void *p);
   static void delete_ECCT_t(void *p);
   static void deleteArray_ECCT_t(void *p);
   static void destruct_ECCT_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECCT_t*)
   {
      ::ECCT_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECCT_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECCT_t", "./include/bankheader.h", 668,
                  typeid(::ECCT_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECCT_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECCT_t) );
      instance.SetNew(&new_ECCT_t);
      instance.SetNewArray(&newArray_ECCT_t);
      instance.SetDelete(&delete_ECCT_t);
      instance.SetDeleteArray(&deleteArray_ECCT_t);
      instance.SetDestructor(&destruct_ECCT_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECCT_t*)
   {
      return GenerateInitInstanceLocal((::ECCT_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECCT_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECCT_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECCT_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void EC_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void EC_t_Dictionary();
   static void *new_EC_t(void *p = 0);
   static void *newArray_EC_t(Long_t size, void *p);
   static void delete_EC_t(void *p);
   static void deleteArray_EC_t(void *p);
   static void destruct_EC_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::EC_t*)
   {
      ::EC_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::EC_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("EC_t", "./include/bankheader.h", 673,
                  typeid(::EC_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &EC_t_Dictionary, isa_proxy, 0,
                  sizeof(::EC_t) );
      instance.SetNew(&new_EC_t);
      instance.SetNewArray(&newArray_EC_t);
      instance.SetDelete(&delete_EC_t);
      instance.SetDeleteArray(&deleteArray_EC_t);
      instance.SetDestructor(&destruct_EC_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::EC_t*)
   {
      return GenerateInitInstanceLocal((::EC_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::EC_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void EC_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::EC_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECDI_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECDI_t_Dictionary();
   static void *new_ECDI_t(void *p = 0);
   static void *newArray_ECDI_t(Long_t size, void *p);
   static void delete_ECDI_t(void *p);
   static void deleteArray_ECDI_t(void *p);
   static void destruct_ECDI_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECDI_t*)
   {
      ::ECDI_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECDI_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECDI_t", "./include/bankheader.h", 680,
                  typeid(::ECDI_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECDI_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECDI_t) );
      instance.SetNew(&new_ECDI_t);
      instance.SetNewArray(&newArray_ECDI_t);
      instance.SetDelete(&delete_ECDI_t);
      instance.SetDeleteArray(&deleteArray_ECDI_t);
      instance.SetDestructor(&destruct_ECDI_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECDI_t*)
   {
      return GenerateInitInstanceLocal((::ECDI_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECDI_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECDI_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECDI_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECG_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECG_t_Dictionary();
   static void *new_ECG_t(void *p = 0);
   static void *newArray_ECG_t(Long_t size, void *p);
   static void delete_ECG_t(void *p);
   static void deleteArray_ECG_t(void *p);
   static void destruct_ECG_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECG_t*)
   {
      ::ECG_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECG_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECG_t", "./include/bankheader.h", 704,
                  typeid(::ECG_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECG_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECG_t) );
      instance.SetNew(&new_ECG_t);
      instance.SetNewArray(&newArray_ECG_t);
      instance.SetDelete(&delete_ECG_t);
      instance.SetDeleteArray(&deleteArray_ECG_t);
      instance.SetDestructor(&destruct_ECG_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECG_t*)
   {
      return GenerateInitInstanceLocal((::ECG_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECG_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECG_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECG_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECHB_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECHB_t_Dictionary();
   static void *new_ECHB_t(void *p = 0);
   static void *newArray_ECHB_t(Long_t size, void *p);
   static void delete_ECHB_t(void *p);
   static void deleteArray_ECHB_t(void *p);
   static void destruct_ECHB_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECHB_t*)
   {
      ::ECHB_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECHB_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECHB_t", "./include/bankheader.h", 744,
                  typeid(::ECHB_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECHB_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECHB_t) );
      instance.SetNew(&new_ECHB_t);
      instance.SetNewArray(&newArray_ECHB_t);
      instance.SetDelete(&delete_ECHB_t);
      instance.SetDeleteArray(&deleteArray_ECHB_t);
      instance.SetDestructor(&destruct_ECHB_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECHB_t*)
   {
      return GenerateInitInstanceLocal((::ECHB_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECHB_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECHB_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECHB_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECH_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECH_t_Dictionary();
   static void *new_ECH_t(void *p = 0);
   static void *newArray_ECH_t(Long_t size, void *p);
   static void delete_ECH_t(void *p);
   static void deleteArray_ECH_t(void *p);
   static void destruct_ECH_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECH_t*)
   {
      ::ECH_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECH_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECH_t", "./include/bankheader.h", 757,
                  typeid(::ECH_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECH_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECH_t) );
      instance.SetNew(&new_ECH_t);
      instance.SetNewArray(&newArray_ECH_t);
      instance.SetDelete(&delete_ECH_t);
      instance.SetDeleteArray(&deleteArray_ECH_t);
      instance.SetDestructor(&destruct_ECH_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECH_t*)
   {
      return GenerateInitInstanceLocal((::ECH_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECH_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECH_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECH_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECMT_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECMT_t_Dictionary();
   static void *new_ECMT_t(void *p = 0);
   static void *newArray_ECMT_t(Long_t size, void *p);
   static void delete_ECMT_t(void *p);
   static void deleteArray_ECMT_t(void *p);
   static void destruct_ECMT_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECMT_t*)
   {
      ::ECMT_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECMT_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECMT_t", "./include/bankheader.h", 765,
                  typeid(::ECMT_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECMT_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECMT_t) );
      instance.SetNew(&new_ECMT_t);
      instance.SetNewArray(&newArray_ECMT_t);
      instance.SetDelete(&delete_ECMT_t);
      instance.SetDeleteArray(&deleteArray_ECMT_t);
      instance.SetDestructor(&destruct_ECMT_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECMT_t*)
   {
      return GenerateInitInstanceLocal((::ECMT_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECMT_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECMT_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECMT_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECP1_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECP1_t_Dictionary();
   static void *new_ECP1_t(void *p = 0);
   static void *newArray_ECP1_t(Long_t size, void *p);
   static void delete_ECP1_t(void *p);
   static void deleteArray_ECP1_t(void *p);
   static void destruct_ECP1_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECP1_t*)
   {
      ::ECP1_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECP1_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECP1_t", "./include/bankheader.h", 772,
                  typeid(::ECP1_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECP1_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECP1_t) );
      instance.SetNew(&new_ECP1_t);
      instance.SetNewArray(&newArray_ECP1_t);
      instance.SetDelete(&delete_ECP1_t);
      instance.SetDeleteArray(&deleteArray_ECP1_t);
      instance.SetDestructor(&destruct_ECP1_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECP1_t*)
   {
      return GenerateInitInstanceLocal((::ECP1_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECP1_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECP1_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECP1_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECPB_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECPB_t_Dictionary();
   static void *new_ECPB_t(void *p = 0);
   static void *newArray_ECPB_t(Long_t size, void *p);
   static void delete_ECPB_t(void *p);
   static void deleteArray_ECPB_t(void *p);
   static void destruct_ECPB_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECPB_t*)
   {
      ::ECPB_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECPB_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECPB_t", "./include/bankheader.h", 790,
                  typeid(::ECPB_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECPB_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECPB_t) );
      instance.SetNew(&new_ECPB_t);
      instance.SetNewArray(&newArray_ECPB_t);
      instance.SetDelete(&delete_ECPB_t);
      instance.SetDeleteArray(&deleteArray_ECPB_t);
      instance.SetDestructor(&destruct_ECPB_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECPB_t*)
   {
      return GenerateInitInstanceLocal((::ECPB_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECPB_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECPB_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECPB_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECPC_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECPC_t_Dictionary();
   static void *new_ECPC_t(void *p = 0);
   static void *newArray_ECPC_t(Long_t size, void *p);
   static void delete_ECPC_t(void *p);
   static void deleteArray_ECPC_t(void *p);
   static void destruct_ECPC_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECPC_t*)
   {
      ::ECPC_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECPC_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECPC_t", "./include/bankheader.h", 795,
                  typeid(::ECPC_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECPC_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECPC_t) );
      instance.SetNew(&new_ECPC_t);
      instance.SetNewArray(&newArray_ECPC_t);
      instance.SetDelete(&delete_ECPC_t);
      instance.SetDeleteArray(&deleteArray_ECPC_t);
      instance.SetDestructor(&destruct_ECPC_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECPC_t*)
   {
      return GenerateInitInstanceLocal((::ECPC_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECPC_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECPC_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECPC_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECP_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECP_t_Dictionary();
   static void *new_ECP_t(void *p = 0);
   static void *newArray_ECP_t(Long_t size, void *p);
   static void delete_ECP_t(void *p);
   static void deleteArray_ECP_t(void *p);
   static void destruct_ECP_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECP_t*)
   {
      ::ECP_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECP_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECP_t", "./include/bankheader.h", 804,
                  typeid(::ECP_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECP_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECP_t) );
      instance.SetNew(&new_ECP_t);
      instance.SetNewArray(&newArray_ECP_t);
      instance.SetDelete(&delete_ECP_t);
      instance.SetDeleteArray(&deleteArray_ECP_t);
      instance.SetDestructor(&destruct_ECP_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECP_t*)
   {
      return GenerateInitInstanceLocal((::ECP_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECP_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECP_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECP_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECPE_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECPE_t_Dictionary();
   static void *new_ECPE_t(void *p = 0);
   static void *newArray_ECPE_t(Long_t size, void *p);
   static void delete_ECPE_t(void *p);
   static void deleteArray_ECPE_t(void *p);
   static void destruct_ECPE_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECPE_t*)
   {
      ::ECPE_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECPE_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECPE_t", "./include/bankheader.h", 809,
                  typeid(::ECPE_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECPE_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECPE_t) );
      instance.SetNew(&new_ECPE_t);
      instance.SetNewArray(&newArray_ECPE_t);
      instance.SetDelete(&delete_ECPE_t);
      instance.SetDeleteArray(&deleteArray_ECPE_t);
      instance.SetDestructor(&destruct_ECPE_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECPE_t*)
   {
      return GenerateInitInstanceLocal((::ECPE_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECPE_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECPE_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECPE_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECPI_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECPI_t_Dictionary();
   static void *new_ECPI_t(void *p = 0);
   static void *newArray_ECPI_t(Long_t size, void *p);
   static void delete_ECPI_t(void *p);
   static void deleteArray_ECPI_t(void *p);
   static void destruct_ECPI_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECPI_t*)
   {
      ::ECPI_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECPI_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECPI_t", "./include/bankheader.h", 820,
                  typeid(::ECPI_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECPI_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECPI_t) );
      instance.SetNew(&new_ECPI_t);
      instance.SetNewArray(&newArray_ECPI_t);
      instance.SetDelete(&delete_ECPI_t);
      instance.SetDeleteArray(&deleteArray_ECPI_t);
      instance.SetDestructor(&destruct_ECPI_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECPI_t*)
   {
      return GenerateInitInstanceLocal((::ECPI_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECPI_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECPI_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECPI_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECPO_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECPO_t_Dictionary();
   static void *new_ECPO_t(void *p = 0);
   static void *newArray_ECPO_t(Long_t size, void *p);
   static void delete_ECPO_t(void *p);
   static void deleteArray_ECPO_t(void *p);
   static void destruct_ECPO_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECPO_t*)
   {
      ::ECPO_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECPO_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECPO_t", "./include/bankheader.h", 829,
                  typeid(::ECPO_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECPO_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECPO_t) );
      instance.SetNew(&new_ECPO_t);
      instance.SetNewArray(&newArray_ECPO_t);
      instance.SetDelete(&delete_ECPO_t);
      instance.SetDeleteArray(&deleteArray_ECPO_t);
      instance.SetDestructor(&destruct_ECPO_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECPO_t*)
   {
      return GenerateInitInstanceLocal((::ECPO_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECPO_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECPO_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECPO_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECRB_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECRB_t_Dictionary();
   static void *new_ECRB_t(void *p = 0);
   static void *newArray_ECRB_t(Long_t size, void *p);
   static void delete_ECRB_t(void *p);
   static void deleteArray_ECRB_t(void *p);
   static void destruct_ECRB_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECRB_t*)
   {
      ::ECRB_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECRB_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECRB_t", "./include/bankheader.h", 880,
                  typeid(::ECRB_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECRB_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECRB_t) );
      instance.SetNew(&new_ECRB_t);
      instance.SetNewArray(&newArray_ECRB_t);
      instance.SetDelete(&delete_ECRB_t);
      instance.SetDeleteArray(&deleteArray_ECRB_t);
      instance.SetDestructor(&destruct_ECRB_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECRB_t*)
   {
      return GenerateInitInstanceLocal((::ECRB_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECRB_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECRB_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECRB_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECS_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECS_t_Dictionary();
   static void *new_ECS_t(void *p = 0);
   static void *newArray_ECS_t(Long_t size, void *p);
   static void delete_ECS_t(void *p);
   static void deleteArray_ECS_t(void *p);
   static void destruct_ECS_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECS_t*)
   {
      ::ECS_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECS_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECS_t", "./include/bankheader.h", 978,
                  typeid(::ECS_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECS_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECS_t) );
      instance.SetNew(&new_ECS_t);
      instance.SetNewArray(&newArray_ECS_t);
      instance.SetDelete(&delete_ECS_t);
      instance.SetDeleteArray(&deleteArray_ECS_t);
      instance.SetDestructor(&destruct_ECS_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECS_t*)
   {
      return GenerateInitInstanceLocal((::ECS_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECS_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECS_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECS_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ECT_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ECT_t_Dictionary();
   static void *new_ECT_t(void *p = 0);
   static void *newArray_ECT_t(Long_t size, void *p);
   static void delete_ECT_t(void *p);
   static void deleteArray_ECT_t(void *p);
   static void destruct_ECT_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ECT_t*)
   {
      ::ECT_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ECT_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ECT_t", "./include/bankheader.h", 982,
                  typeid(::ECT_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ECT_t_Dictionary, isa_proxy, 0,
                  sizeof(::ECT_t) );
      instance.SetNew(&new_ECT_t);
      instance.SetNewArray(&newArray_ECT_t);
      instance.SetDelete(&delete_ECT_t);
      instance.SetDeleteArray(&deleteArray_ECT_t);
      instance.SetDestructor(&destruct_ECT_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ECT_t*)
   {
      return GenerateInitInstanceLocal((::ECT_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ECT_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ECT_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ECT_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void EID0_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void EID0_t_Dictionary();
   static void *new_EID0_t(void *p = 0);
   static void *newArray_EID0_t(Long_t size, void *p);
   static void delete_EID0_t(void *p);
   static void deleteArray_EID0_t(void *p);
   static void destruct_EID0_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::EID0_t*)
   {
      ::EID0_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::EID0_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("EID0_t", "./include/bankheader.h", 988,
                  typeid(::EID0_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &EID0_t_Dictionary, isa_proxy, 0,
                  sizeof(::EID0_t) );
      instance.SetNew(&new_EID0_t);
      instance.SetNewArray(&newArray_EID0_t);
      instance.SetDelete(&delete_EID0_t);
      instance.SetDeleteArray(&deleteArray_EID0_t);
      instance.SetDestructor(&destruct_EID0_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::EID0_t*)
   {
      return GenerateInitInstanceLocal((::EID0_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::EID0_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void EID0_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::EID0_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void EPIC_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void EPIC_t_Dictionary();
   static void *new_EPIC_t(void *p = 0);
   static void *newArray_EPIC_t(Long_t size, void *p);
   static void delete_EPIC_t(void *p);
   static void deleteArray_EPIC_t(void *p);
   static void destruct_EPIC_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::EPIC_t*)
   {
      ::EPIC_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::EPIC_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("EPIC_t", "./include/bankheader.h", 992,
                  typeid(::EPIC_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &EPIC_t_Dictionary, isa_proxy, 0,
                  sizeof(::EPIC_t) );
      instance.SetNew(&new_EPIC_t);
      instance.SetNewArray(&newArray_EPIC_t);
      instance.SetDelete(&delete_EPIC_t);
      instance.SetDeleteArray(&deleteArray_EPIC_t);
      instance.SetDestructor(&destruct_EPIC_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::EPIC_t*)
   {
      return GenerateInitInstanceLocal((::EPIC_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::EPIC_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void EPIC_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::EPIC_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void EVNT_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void EVNT_t_Dictionary();
   static void *new_EVNT_t(void *p = 0);
   static void *newArray_EVNT_t(Long_t size, void *p);
   static void delete_EVNT_t(void *p);
   static void deleteArray_EVNT_t(void *p);
   static void destruct_EVNT_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::EVNT_t*)
   {
      ::EVNT_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::EVNT_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("EVNT_t", "./include/bankheader.h", 1012,
                  typeid(::EVNT_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &EVNT_t_Dictionary, isa_proxy, 0,
                  sizeof(::EVNT_t) );
      instance.SetNew(&new_EVNT_t);
      instance.SetNewArray(&newArray_EVNT_t);
      instance.SetDelete(&delete_EVNT_t);
      instance.SetDeleteArray(&deleteArray_EVNT_t);
      instance.SetDestructor(&destruct_EVNT_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::EVNT_t*)
   {
      return GenerateInitInstanceLocal((::EVNT_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::EVNT_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void EVNT_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::EVNT_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void FBPM_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void FBPM_t_Dictionary();
   static void *new_FBPM_t(void *p = 0);
   static void *newArray_FBPM_t(Long_t size, void *p);
   static void delete_FBPM_t(void *p);
   static void deleteArray_FBPM_t(void *p);
   static void destruct_FBPM_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::FBPM_t*)
   {
      ::FBPM_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::FBPM_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("FBPM_t", "./include/bankheader.h", 1017,
                  typeid(::FBPM_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &FBPM_t_Dictionary, isa_proxy, 0,
                  sizeof(::FBPM_t) );
      instance.SetNew(&new_FBPM_t);
      instance.SetNewArray(&newArray_FBPM_t);
      instance.SetDelete(&delete_FBPM_t);
      instance.SetDeleteArray(&deleteArray_FBPM_t);
      instance.SetDestructor(&destruct_FBPM_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::FBPM_t*)
   {
      return GenerateInitInstanceLocal((::FBPM_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::FBPM_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void FBPM_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::FBPM_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void G1SL_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void G1SL_t_Dictionary();
   static void *new_G1SL_t(void *p = 0);
   static void *newArray_G1SL_t(Long_t size, void *p);
   static void delete_G1SL_t(void *p);
   static void deleteArray_G1SL_t(void *p);
   static void destruct_G1SL_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::G1SL_t*)
   {
      ::G1SL_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::G1SL_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("G1SL_t", "./include/bankheader.h", 1083,
                  typeid(::G1SL_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &G1SL_t_Dictionary, isa_proxy, 0,
                  sizeof(::G1SL_t) );
      instance.SetNew(&new_G1SL_t);
      instance.SetNewArray(&newArray_G1SL_t);
      instance.SetDelete(&delete_G1SL_t);
      instance.SetDeleteArray(&deleteArray_G1SL_t);
      instance.SetDestructor(&destruct_G1SL_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::G1SL_t*)
   {
      return GenerateInitInstanceLocal((::G1SL_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::G1SL_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void G1SL_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::G1SL_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void G2SL_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void G2SL_t_Dictionary();
   static void *new_G2SL_t(void *p = 0);
   static void *newArray_G2SL_t(Long_t size, void *p);
   static void delete_G2SL_t(void *p);
   static void deleteArray_G2SL_t(void *p);
   static void destruct_G2SL_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::G2SL_t*)
   {
      ::G2SL_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::G2SL_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("G2SL_t", "./include/bankheader.h", 1149,
                  typeid(::G2SL_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &G2SL_t_Dictionary, isa_proxy, 0,
                  sizeof(::G2SL_t) );
      instance.SetNew(&new_G2SL_t);
      instance.SetNewArray(&newArray_G2SL_t);
      instance.SetDelete(&delete_G2SL_t);
      instance.SetDeleteArray(&deleteArray_G2SL_t);
      instance.SetDestructor(&destruct_G2SL_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::G2SL_t*)
   {
      return GenerateInitInstanceLocal((::G2SL_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::G2SL_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void G2SL_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::G2SL_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void G3SL_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void G3SL_t_Dictionary();
   static void *new_G3SL_t(void *p = 0);
   static void *newArray_G3SL_t(Long_t size, void *p);
   static void delete_G3SL_t(void *p);
   static void deleteArray_G3SL_t(void *p);
   static void destruct_G3SL_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::G3SL_t*)
   {
      ::G3SL_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::G3SL_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("G3SL_t", "./include/bankheader.h", 1215,
                  typeid(::G3SL_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &G3SL_t_Dictionary, isa_proxy, 0,
                  sizeof(::G3SL_t) );
      instance.SetNew(&new_G3SL_t);
      instance.SetNewArray(&newArray_G3SL_t);
      instance.SetDelete(&delete_G3SL_t);
      instance.SetDeleteArray(&deleteArray_G3SL_t);
      instance.SetDestructor(&destruct_G3SL_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::G3SL_t*)
   {
      return GenerateInitInstanceLocal((::G3SL_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::G3SL_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void G3SL_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::G3SL_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void G4SL_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void G4SL_t_Dictionary();
   static void *new_G4SL_t(void *p = 0);
   static void *newArray_G4SL_t(Long_t size, void *p);
   static void delete_G4SL_t(void *p);
   static void deleteArray_G4SL_t(void *p);
   static void destruct_G4SL_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::G4SL_t*)
   {
      ::G4SL_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::G4SL_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("G4SL_t", "./include/bankheader.h", 1281,
                  typeid(::G4SL_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &G4SL_t_Dictionary, isa_proxy, 0,
                  sizeof(::G4SL_t) );
      instance.SetNew(&new_G4SL_t);
      instance.SetNewArray(&newArray_G4SL_t);
      instance.SetDelete(&delete_G4SL_t);
      instance.SetDeleteArray(&deleteArray_G4SL_t);
      instance.SetDestructor(&destruct_G4SL_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::G4SL_t*)
   {
      return GenerateInitInstanceLocal((::G4SL_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::G4SL_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void G4SL_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::G4SL_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void GPAR_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void GPAR_t_Dictionary();
   static void *new_GPAR_t(void *p = 0);
   static void *newArray_GPAR_t(Long_t size, void *p);
   static void delete_GPAR_t(void *p);
   static void deleteArray_GPAR_t(void *p);
   static void destruct_GPAR_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::GPAR_t*)
   {
      ::GPAR_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GPAR_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("GPAR_t", "./include/bankheader.h", 1286,
                  typeid(::GPAR_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &GPAR_t_Dictionary, isa_proxy, 0,
                  sizeof(::GPAR_t) );
      instance.SetNew(&new_GPAR_t);
      instance.SetNewArray(&newArray_GPAR_t);
      instance.SetDelete(&delete_GPAR_t);
      instance.SetDeleteArray(&deleteArray_GPAR_t);
      instance.SetDestructor(&destruct_GPAR_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::GPAR_t*)
   {
      return GenerateInitInstanceLocal((::GPAR_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GPAR_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void GPAR_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::GPAR_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void GPID_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void GPID_t_Dictionary();
   static void *new_GPID_t(void *p = 0);
   static void *newArray_GPID_t(Long_t size, void *p);
   static void delete_GPID_t(void *p);
   static void deleteArray_GPID_t(void *p);
   static void destruct_GPID_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::GPID_t*)
   {
      ::GPID_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GPID_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("GPID_t", "./include/bankheader.h", 1316,
                  typeid(::GPID_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &GPID_t_Dictionary, isa_proxy, 0,
                  sizeof(::GPID_t) );
      instance.SetNew(&new_GPID_t);
      instance.SetNewArray(&newArray_GPID_t);
      instance.SetDelete(&delete_GPID_t);
      instance.SetDeleteArray(&deleteArray_GPID_t);
      instance.SetDestructor(&destruct_GPID_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::GPID_t*)
   {
      return GenerateInitInstanceLocal((::GPID_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GPID_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void GPID_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::GPID_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void GP_X_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void GP_X_t_Dictionary();
   static void *new_GP_X_t(void *p = 0);
   static void *newArray_GP_X_t(Long_t size, void *p);
   static void delete_GP_X_t(void *p);
   static void deleteArray_GP_X_t(void *p);
   static void destruct_GP_X_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::GP_X_t*)
   {
      ::GP_X_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GP_X_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("GP_X_t", "./include/bankheader.h", 1319,
                  typeid(::GP_X_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &GP_X_t_Dictionary, isa_proxy, 0,
                  sizeof(::GP_X_t) );
      instance.SetNew(&new_GP_X_t);
      instance.SetNewArray(&newArray_GP_X_t);
      instance.SetDelete(&delete_GP_X_t);
      instance.SetDeleteArray(&deleteArray_GP_X_t);
      instance.SetDestructor(&destruct_GP_X_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::GP_X_t*)
   {
      return GenerateInitInstanceLocal((::GP_X_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GP_X_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void GP_X_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::GP_X_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void GP_Y_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void GP_Y_t_Dictionary();
   static void *new_GP_Y_t(void *p = 0);
   static void *newArray_GP_Y_t(Long_t size, void *p);
   static void delete_GP_Y_t(void *p);
   static void deleteArray_GP_Y_t(void *p);
   static void destruct_GP_Y_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::GP_Y_t*)
   {
      ::GP_Y_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GP_Y_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("GP_Y_t", "./include/bankheader.h", 1322,
                  typeid(::GP_Y_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &GP_Y_t_Dictionary, isa_proxy, 0,
                  sizeof(::GP_Y_t) );
      instance.SetNew(&new_GP_Y_t);
      instance.SetNewArray(&newArray_GP_Y_t);
      instance.SetDelete(&delete_GP_Y_t);
      instance.SetDeleteArray(&deleteArray_GP_Y_t);
      instance.SetDestructor(&destruct_GP_Y_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::GP_Y_t*)
   {
      return GenerateInitInstanceLocal((::GP_Y_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GP_Y_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void GP_Y_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::GP_Y_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void HBER_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void HBER_t_Dictionary();
   static void *new_HBER_t(void *p = 0);
   static void *newArray_HBER_t(Long_t size, void *p);
   static void delete_HBER_t(void *p);
   static void deleteArray_HBER_t(void *p);
   static void destruct_HBER_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::HBER_t*)
   {
      ::HBER_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::HBER_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("HBER_t", "./include/bankheader.h", 1347,
                  typeid(::HBER_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &HBER_t_Dictionary, isa_proxy, 0,
                  sizeof(::HBER_t) );
      instance.SetNew(&new_HBER_t);
      instance.SetNewArray(&newArray_HBER_t);
      instance.SetDelete(&delete_HBER_t);
      instance.SetDeleteArray(&deleteArray_HBER_t);
      instance.SetDestructor(&destruct_HBER_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::HBER_t*)
   {
      return GenerateInitInstanceLocal((::HBER_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::HBER_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void HBER_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::HBER_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void HBID_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void HBID_t_Dictionary();
   static void *new_HBID_t(void *p = 0);
   static void *newArray_HBID_t(Long_t size, void *p);
   static void delete_HBID_t(void *p);
   static void deleteArray_HBID_t(void *p);
   static void destruct_HBID_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::HBID_t*)
   {
      ::HBID_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::HBID_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("HBID_t", "./include/bankheader.h", 1383,
                  typeid(::HBID_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &HBID_t_Dictionary, isa_proxy, 0,
                  sizeof(::HBID_t) );
      instance.SetNew(&new_HBID_t);
      instance.SetNewArray(&newArray_HBID_t);
      instance.SetDelete(&delete_HBID_t);
      instance.SetDeleteArray(&deleteArray_HBID_t);
      instance.SetDestructor(&destruct_HBID_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::HBID_t*)
   {
      return GenerateInitInstanceLocal((::HBID_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::HBID_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void HBID_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::HBID_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void HBLA_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void HBLA_t_Dictionary();
   static void *new_HBLA_t(void *p = 0);
   static void *newArray_HBLA_t(Long_t size, void *p);
   static void delete_HBLA_t(void *p);
   static void deleteArray_HBLA_t(void *p);
   static void destruct_HBLA_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::HBLA_t*)
   {
      ::HBLA_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::HBLA_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("HBLA_t", "./include/bankheader.h", 1401,
                  typeid(::HBLA_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &HBLA_t_Dictionary, isa_proxy, 0,
                  sizeof(::HBLA_t) );
      instance.SetNew(&new_HBLA_t);
      instance.SetNewArray(&newArray_HBLA_t);
      instance.SetDelete(&delete_HBLA_t);
      instance.SetDeleteArray(&deleteArray_HBLA_t);
      instance.SetDestructor(&destruct_HBLA_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::HBLA_t*)
   {
      return GenerateInitInstanceLocal((::HBLA_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::HBLA_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void HBLA_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::HBLA_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void HBTB_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void HBTB_t_Dictionary();
   static void *new_HBTB_t(void *p = 0);
   static void *newArray_HBTB_t(Long_t size, void *p);
   static void delete_HBTB_t(void *p);
   static void deleteArray_HBTB_t(void *p);
   static void destruct_HBTB_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::HBTB_t*)
   {
      ::HBTB_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::HBTB_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("HBTB_t", "./include/bankheader.h", 1413,
                  typeid(::HBTB_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &HBTB_t_Dictionary, isa_proxy, 0,
                  sizeof(::HBTB_t) );
      instance.SetNew(&new_HBTB_t);
      instance.SetNewArray(&newArray_HBTB_t);
      instance.SetDelete(&delete_HBTB_t);
      instance.SetDeleteArray(&deleteArray_HBTB_t);
      instance.SetDestructor(&destruct_HBTB_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::HBTB_t*)
   {
      return GenerateInitInstanceLocal((::HBTB_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::HBTB_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void HBTB_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::HBTB_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void HBTR_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void HBTR_t_Dictionary();
   static void *new_HBTR_t(void *p = 0);
   static void *newArray_HBTR_t(Long_t size, void *p);
   static void delete_HBTR_t(void *p);
   static void deleteArray_HBTR_t(void *p);
   static void destruct_HBTR_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::HBTR_t*)
   {
      ::HBTR_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::HBTR_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("HBTR_t", "./include/bankheader.h", 1424,
                  typeid(::HBTR_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &HBTR_t_Dictionary, isa_proxy, 0,
                  sizeof(::HBTR_t) );
      instance.SetNew(&new_HBTR_t);
      instance.SetNewArray(&newArray_HBTR_t);
      instance.SetDelete(&delete_HBTR_t);
      instance.SetDeleteArray(&deleteArray_HBTR_t);
      instance.SetDestructor(&destruct_HBTR_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::HBTR_t*)
   {
      return GenerateInitInstanceLocal((::HBTR_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::HBTR_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void HBTR_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::HBTR_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void HCAL_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void HCAL_t_Dictionary();
   static void *new_HCAL_t(void *p = 0);
   static void *newArray_HCAL_t(Long_t size, void *p);
   static void delete_HCAL_t(void *p);
   static void deleteArray_HCAL_t(void *p);
   static void destruct_HCAL_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::HCAL_t*)
   {
      ::HCAL_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::HCAL_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("HCAL_t", "./include/bankheader.h", 1431,
                  typeid(::HCAL_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &HCAL_t_Dictionary, isa_proxy, 0,
                  sizeof(::HCAL_t) );
      instance.SetNew(&new_HCAL_t);
      instance.SetNewArray(&newArray_HCAL_t);
      instance.SetDelete(&delete_HCAL_t);
      instance.SetDeleteArray(&deleteArray_HCAL_t);
      instance.SetDestructor(&destruct_HCAL_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::HCAL_t*)
   {
      return GenerateInitInstanceLocal((::HCAL_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::HCAL_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void HCAL_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::HCAL_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void HDPL_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void HDPL_t_Dictionary();
   static void *new_HDPL_t(void *p = 0);
   static void *newArray_HDPL_t(Long_t size, void *p);
   static void delete_HDPL_t(void *p);
   static void deleteArray_HDPL_t(void *p);
   static void destruct_HDPL_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::HDPL_t*)
   {
      ::HDPL_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::HDPL_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("HDPL_t", "./include/bankheader.h", 1441,
                  typeid(::HDPL_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &HDPL_t_Dictionary, isa_proxy, 0,
                  sizeof(::HDPL_t) );
      instance.SetNew(&new_HDPL_t);
      instance.SetNewArray(&newArray_HDPL_t);
      instance.SetDelete(&delete_HDPL_t);
      instance.SetDeleteArray(&deleteArray_HDPL_t);
      instance.SetDestructor(&destruct_HDPL_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::HDPL_t*)
   {
      return GenerateInitInstanceLocal((::HDPL_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::HDPL_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void HDPL_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::HDPL_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void HEAD_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void HEAD_t_Dictionary();
   static void *new_HEAD_t(void *p = 0);
   static void *newArray_HEAD_t(Long_t size, void *p);
   static void delete_HEAD_t(void *p);
   static void deleteArray_HEAD_t(void *p);
   static void destruct_HEAD_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::HEAD_t*)
   {
      ::HEAD_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::HEAD_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("HEAD_t", "./include/bankheader.h", 1451,
                  typeid(::HEAD_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &HEAD_t_Dictionary, isa_proxy, 0,
                  sizeof(::HEAD_t) );
      instance.SetNew(&new_HEAD_t);
      instance.SetNewArray(&newArray_HEAD_t);
      instance.SetDelete(&delete_HEAD_t);
      instance.SetDeleteArray(&deleteArray_HEAD_t);
      instance.SetDestructor(&destruct_HEAD_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::HEAD_t*)
   {
      return GenerateInitInstanceLocal((::HEAD_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::HEAD_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void HEAD_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::HEAD_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void HEVT_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void HEVT_t_Dictionary();
   static void *new_HEVT_t(void *p = 0);
   static void *newArray_HEVT_t(Long_t size, void *p);
   static void delete_HEVT_t(void *p);
   static void deleteArray_HEVT_t(void *p);
   static void destruct_HEVT_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::HEVT_t*)
   {
      ::HEVT_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::HEVT_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("HEVT_t", "./include/bankheader.h", 1469,
                  typeid(::HEVT_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &HEVT_t_Dictionary, isa_proxy, 0,
                  sizeof(::HEVT_t) );
      instance.SetNew(&new_HEVT_t);
      instance.SetNewArray(&newArray_HEVT_t);
      instance.SetDelete(&delete_HEVT_t);
      instance.SetDeleteArray(&deleteArray_HEVT_t);
      instance.SetDestructor(&destruct_HEVT_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::HEVT_t*)
   {
      return GenerateInitInstanceLocal((::HEVT_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::HEVT_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void HEVT_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::HEVT_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void HLS_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void HLS_t_Dictionary();
   static void *new_HLS_t(void *p = 0);
   static void *newArray_HLS_t(Long_t size, void *p);
   static void delete_HLS_t(void *p);
   static void deleteArray_HLS_t(void *p);
   static void destruct_HLS_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::HLS_t*)
   {
      ::HLS_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::HLS_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("HLS_t", "./include/bankheader.h", 1487,
                  typeid(::HLS_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &HLS_t_Dictionary, isa_proxy, 0,
                  sizeof(::HLS_t) );
      instance.SetNew(&new_HLS_t);
      instance.SetNewArray(&newArray_HLS_t);
      instance.SetDelete(&delete_HLS_t);
      instance.SetDeleteArray(&deleteArray_HLS_t);
      instance.SetDestructor(&destruct_HLS_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::HLS_t*)
   {
      return GenerateInitInstanceLocal((::HLS_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::HLS_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void HLS_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::HLS_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void IC_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void IC_t_Dictionary();
   static void *new_IC_t(void *p = 0);
   static void *newArray_IC_t(Long_t size, void *p);
   static void delete_IC_t(void *p);
   static void deleteArray_IC_t(void *p);
   static void destruct_IC_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::IC_t*)
   {
      ::IC_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::IC_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("IC_t", "./include/bankheader.h", 1492,
                  typeid(::IC_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &IC_t_Dictionary, isa_proxy, 0,
                  sizeof(::IC_t) );
      instance.SetNew(&new_IC_t);
      instance.SetNewArray(&newArray_IC_t);
      instance.SetDelete(&delete_IC_t);
      instance.SetDeleteArray(&deleteArray_IC_t);
      instance.SetDestructor(&destruct_IC_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::IC_t*)
   {
      return GenerateInitInstanceLocal((::IC_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::IC_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void IC_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::IC_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ICHB_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ICHB_t_Dictionary();
   static void *new_ICHB_t(void *p = 0);
   static void *newArray_ICHB_t(Long_t size, void *p);
   static void delete_ICHB_t(void *p);
   static void deleteArray_ICHB_t(void *p);
   static void destruct_ICHB_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ICHB_t*)
   {
      ::ICHB_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ICHB_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ICHB_t", "./include/bankheader.h", 1508,
                  typeid(::ICHB_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ICHB_t_Dictionary, isa_proxy, 0,
                  sizeof(::ICHB_t) );
      instance.SetNew(&new_ICHB_t);
      instance.SetNewArray(&newArray_ICHB_t);
      instance.SetDelete(&delete_ICHB_t);
      instance.SetDeleteArray(&deleteArray_ICHB_t);
      instance.SetDestructor(&destruct_ICHB_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ICHB_t*)
   {
      return GenerateInitInstanceLocal((::ICHB_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ICHB_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ICHB_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ICHB_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void KFIT_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void KFIT_t_Dictionary();
   static void *new_KFIT_t(void *p = 0);
   static void *newArray_KFIT_t(Long_t size, void *p);
   static void delete_KFIT_t(void *p);
   static void deleteArray_KFIT_t(void *p);
   static void destruct_KFIT_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::KFIT_t*)
   {
      ::KFIT_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::KFIT_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("KFIT_t", "./include/bankheader.h", 1556,
                  typeid(::KFIT_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &KFIT_t_Dictionary, isa_proxy, 0,
                  sizeof(::KFIT_t) );
      instance.SetNew(&new_KFIT_t);
      instance.SetNewArray(&newArray_KFIT_t);
      instance.SetDelete(&delete_KFIT_t);
      instance.SetDeleteArray(&deleteArray_KFIT_t);
      instance.SetDestructor(&destruct_KFIT_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::KFIT_t*)
   {
      return GenerateInitInstanceLocal((::KFIT_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::KFIT_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void KFIT_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::KFIT_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void L1PG_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void L1PG_t_Dictionary();
   static void *new_L1PG_t(void *p = 0);
   static void *newArray_L1PG_t(Long_t size, void *p);
   static void delete_L1PG_t(void *p);
   static void deleteArray_L1PG_t(void *p);
   static void destruct_L1PG_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::L1PG_t*)
   {
      ::L1PG_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::L1PG_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("L1PG_t", "./include/bankheader.h", 1559,
                  typeid(::L1PG_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &L1PG_t_Dictionary, isa_proxy, 0,
                  sizeof(::L1PG_t) );
      instance.SetNew(&new_L1PG_t);
      instance.SetNewArray(&newArray_L1PG_t);
      instance.SetDelete(&delete_L1PG_t);
      instance.SetDeleteArray(&deleteArray_L1PG_t);
      instance.SetDestructor(&destruct_L1PG_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::L1PG_t*)
   {
      return GenerateInitInstanceLocal((::L1PG_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::L1PG_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void L1PG_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::L1PG_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void L2H_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void L2H_t_Dictionary();
   static void *new_L2H_t(void *p = 0);
   static void *newArray_L2H_t(Long_t size, void *p);
   static void delete_L2H_t(void *p);
   static void deleteArray_L2H_t(void *p);
   static void destruct_L2H_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::L2H_t*)
   {
      ::L2H_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::L2H_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("L2H_t", "./include/bankheader.h", 1563,
                  typeid(::L2H_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &L2H_t_Dictionary, isa_proxy, 0,
                  sizeof(::L2H_t) );
      instance.SetNew(&new_L2H_t);
      instance.SetNewArray(&newArray_L2H_t);
      instance.SetDelete(&delete_L2H_t);
      instance.SetDeleteArray(&deleteArray_L2H_t);
      instance.SetDestructor(&destruct_L2H_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::L2H_t*)
   {
      return GenerateInitInstanceLocal((::L2H_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::L2H_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void L2H_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::L2H_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void L2S_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void L2S_t_Dictionary();
   static void *new_L2S_t(void *p = 0);
   static void *newArray_L2S_t(Long_t size, void *p);
   static void delete_L2S_t(void *p);
   static void deleteArray_L2S_t(void *p);
   static void destruct_L2S_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::L2S_t*)
   {
      ::L2S_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::L2S_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("L2S_t", "./include/bankheader.h", 1567,
                  typeid(::L2S_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &L2S_t_Dictionary, isa_proxy, 0,
                  sizeof(::L2S_t) );
      instance.SetNew(&new_L2S_t);
      instance.SetNewArray(&newArray_L2S_t);
      instance.SetDelete(&delete_L2S_t);
      instance.SetDeleteArray(&deleteArray_L2S_t);
      instance.SetDestructor(&destruct_L2S_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::L2S_t*)
   {
      return GenerateInitInstanceLocal((::L2S_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::L2S_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void L2S_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::L2S_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void LASR_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void LASR_t_Dictionary();
   static void *new_LASR_t(void *p = 0);
   static void *newArray_LASR_t(Long_t size, void *p);
   static void delete_LASR_t(void *p);
   static void deleteArray_LASR_t(void *p);
   static void destruct_LASR_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::LASR_t*)
   {
      ::LASR_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::LASR_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("LASR_t", "./include/bankheader.h", 1573,
                  typeid(::LASR_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &LASR_t_Dictionary, isa_proxy, 0,
                  sizeof(::LASR_t) );
      instance.SetNew(&new_LASR_t);
      instance.SetNewArray(&newArray_LASR_t);
      instance.SetDelete(&delete_LASR_t);
      instance.SetDeleteArray(&deleteArray_LASR_t);
      instance.SetDestructor(&destruct_LASR_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::LASR_t*)
   {
      return GenerateInitInstanceLocal((::LASR_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::LASR_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void LASR_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::LASR_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void LCDI_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void LCDI_t_Dictionary();
   static void *new_LCDI_t(void *p = 0);
   static void *newArray_LCDI_t(Long_t size, void *p);
   static void delete_LCDI_t(void *p);
   static void deleteArray_LCDI_t(void *p);
   static void destruct_LCDI_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::LCDI_t*)
   {
      ::LCDI_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::LCDI_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("LCDI_t", "./include/bankheader.h", 1579,
                  typeid(::LCDI_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &LCDI_t_Dictionary, isa_proxy, 0,
                  sizeof(::LCDI_t) );
      instance.SetNew(&new_LCDI_t);
      instance.SetNewArray(&newArray_LCDI_t);
      instance.SetDelete(&delete_LCDI_t);
      instance.SetDeleteArray(&deleteArray_LCDI_t);
      instance.SetDestructor(&destruct_LCDI_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::LCDI_t*)
   {
      return GenerateInitInstanceLocal((::LCDI_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::LCDI_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void LCDI_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::LCDI_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void LCPB_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void LCPB_t_Dictionary();
   static void *new_LCPB_t(void *p = 0);
   static void *newArray_LCPB_t(Long_t size, void *p);
   static void delete_LCPB_t(void *p);
   static void deleteArray_LCPB_t(void *p);
   static void destruct_LCPB_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::LCPB_t*)
   {
      ::LCPB_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::LCPB_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("LCPB_t", "./include/bankheader.h", 1591,
                  typeid(::LCPB_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &LCPB_t_Dictionary, isa_proxy, 0,
                  sizeof(::LCPB_t) );
      instance.SetNew(&new_LCPB_t);
      instance.SetNewArray(&newArray_LCPB_t);
      instance.SetDelete(&delete_LCPB_t);
      instance.SetDeleteArray(&deleteArray_LCPB_t);
      instance.SetDestructor(&destruct_LCPB_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::LCPB_t*)
   {
      return GenerateInitInstanceLocal((::LCPB_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::LCPB_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void LCPB_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::LCPB_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void LOWQ_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void LOWQ_t_Dictionary();
   static void *new_LOWQ_t(void *p = 0);
   static void *newArray_LOWQ_t(Long_t size, void *p);
   static void delete_LOWQ_t(void *p);
   static void deleteArray_LOWQ_t(void *p);
   static void destruct_LOWQ_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::LOWQ_t*)
   {
      ::LOWQ_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::LOWQ_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("LOWQ_t", "./include/bankheader.h", 1605,
                  typeid(::LOWQ_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &LOWQ_t_Dictionary, isa_proxy, 0,
                  sizeof(::LOWQ_t) );
      instance.SetNew(&new_LOWQ_t);
      instance.SetNewArray(&newArray_LOWQ_t);
      instance.SetDelete(&delete_LOWQ_t);
      instance.SetDeleteArray(&deleteArray_LOWQ_t);
      instance.SetDestructor(&destruct_LOWQ_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::LOWQ_t*)
   {
      return GenerateInitInstanceLocal((::LOWQ_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::LOWQ_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void LOWQ_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::LOWQ_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void MCEV_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void MCEV_t_Dictionary();
   static void *new_MCEV_t(void *p = 0);
   static void *newArray_MCEV_t(Long_t size, void *p);
   static void delete_MCEV_t(void *p);
   static void deleteArray_MCEV_t(void *p);
   static void destruct_MCEV_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::MCEV_t*)
   {
      ::MCEV_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::MCEV_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("MCEV_t", "./include/bankheader.h", 1609,
                  typeid(::MCEV_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &MCEV_t_Dictionary, isa_proxy, 0,
                  sizeof(::MCEV_t) );
      instance.SetNew(&new_MCEV_t);
      instance.SetNewArray(&newArray_MCEV_t);
      instance.SetDelete(&delete_MCEV_t);
      instance.SetDeleteArray(&deleteArray_MCEV_t);
      instance.SetDestructor(&destruct_MCEV_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::MCEV_t*)
   {
      return GenerateInitInstanceLocal((::MCEV_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::MCEV_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void MCEV_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::MCEV_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void MCHD_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void MCHD_t_Dictionary();
   static void *new_MCHD_t(void *p = 0);
   static void *newArray_MCHD_t(Long_t size, void *p);
   static void delete_MCHD_t(void *p);
   static void deleteArray_MCHD_t(void *p);
   static void destruct_MCHD_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::MCHD_t*)
   {
      ::MCHD_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::MCHD_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("MCHD_t", "./include/bankheader.h", 1627,
                  typeid(::MCHD_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &MCHD_t_Dictionary, isa_proxy, 0,
                  sizeof(::MCHD_t) );
      instance.SetNew(&new_MCHD_t);
      instance.SetNewArray(&newArray_MCHD_t);
      instance.SetDelete(&delete_MCHD_t);
      instance.SetDeleteArray(&deleteArray_MCHD_t);
      instance.SetDestructor(&destruct_MCHD_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::MCHD_t*)
   {
      return GenerateInitInstanceLocal((::MCHD_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::MCHD_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void MCHD_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::MCHD_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void MCTK_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void MCTK_t_Dictionary();
   static void *new_MCTK_t(void *p = 0);
   static void *newArray_MCTK_t(Long_t size, void *p);
   static void delete_MCTK_t(void *p);
   static void deleteArray_MCTK_t(void *p);
   static void destruct_MCTK_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::MCTK_t*)
   {
      ::MCTK_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::MCTK_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("MCTK_t", "./include/bankheader.h", 1640,
                  typeid(::MCTK_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &MCTK_t_Dictionary, isa_proxy, 0,
                  sizeof(::MCTK_t) );
      instance.SetNew(&new_MCTK_t);
      instance.SetNewArray(&newArray_MCTK_t);
      instance.SetDelete(&delete_MCTK_t);
      instance.SetDeleteArray(&deleteArray_MCTK_t);
      instance.SetDestructor(&destruct_MCTK_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::MCTK_t*)
   {
      return GenerateInitInstanceLocal((::MCTK_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::MCTK_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void MCTK_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::MCTK_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void MCVX_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void MCVX_t_Dictionary();
   static void *new_MCVX_t(void *p = 0);
   static void *newArray_MCVX_t(Long_t size, void *p);
   static void delete_MCVX_t(void *p);
   static void deleteArray_MCVX_t(void *p);
   static void destruct_MCVX_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::MCVX_t*)
   {
      ::MCVX_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::MCVX_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("MCVX_t", "./include/bankheader.h", 1647,
                  typeid(::MCVX_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &MCVX_t_Dictionary, isa_proxy, 0,
                  sizeof(::MCVX_t) );
      instance.SetNew(&new_MCVX_t);
      instance.SetNewArray(&newArray_MCVX_t);
      instance.SetDelete(&delete_MCVX_t);
      instance.SetDeleteArray(&deleteArray_MCVX_t);
      instance.SetDestructor(&destruct_MCVX_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::MCVX_t*)
   {
      return GenerateInitInstanceLocal((::MCVX_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::MCVX_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void MCVX_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::MCVX_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void MS1_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void MS1_t_Dictionary();
   static void *new_MS1_t(void *p = 0);
   static void *newArray_MS1_t(Long_t size, void *p);
   static void delete_MS1_t(void *p);
   static void deleteArray_MS1_t(void *p);
   static void destruct_MS1_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::MS1_t*)
   {
      ::MS1_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::MS1_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("MS1_t", "./include/bankheader.h", 1651,
                  typeid(::MS1_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &MS1_t_Dictionary, isa_proxy, 0,
                  sizeof(::MS1_t) );
      instance.SetNew(&new_MS1_t);
      instance.SetNewArray(&newArray_MS1_t);
      instance.SetDelete(&delete_MS1_t);
      instance.SetDeleteArray(&deleteArray_MS1_t);
      instance.SetDestructor(&destruct_MS1_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::MS1_t*)
   {
      return GenerateInitInstanceLocal((::MS1_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::MS1_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void MS1_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::MS1_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void MTRK_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void MTRK_t_Dictionary();
   static void *new_MTRK_t(void *p = 0);
   static void *newArray_MTRK_t(Long_t size, void *p);
   static void delete_MTRK_t(void *p);
   static void deleteArray_MTRK_t(void *p);
   static void destruct_MTRK_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::MTRK_t*)
   {
      ::MTRK_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::MTRK_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("MTRK_t", "./include/bankheader.h", 1660,
                  typeid(::MTRK_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &MTRK_t_Dictionary, isa_proxy, 0,
                  sizeof(::MTRK_t) );
      instance.SetNew(&new_MTRK_t);
      instance.SetNewArray(&newArray_MTRK_t);
      instance.SetDelete(&delete_MTRK_t);
      instance.SetDeleteArray(&deleteArray_MTRK_t);
      instance.SetDestructor(&destruct_MTRK_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::MTRK_t*)
   {
      return GenerateInitInstanceLocal((::MTRK_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::MTRK_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void MTRK_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::MTRK_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void MVRT_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void MVRT_t_Dictionary();
   static void *new_MVRT_t(void *p = 0);
   static void *newArray_MVRT_t(Long_t size, void *p);
   static void delete_MVRT_t(void *p);
   static void deleteArray_MVRT_t(void *p);
   static void destruct_MVRT_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::MVRT_t*)
   {
      ::MVRT_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::MVRT_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("MVRT_t", "./include/bankheader.h", 1675,
                  typeid(::MVRT_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &MVRT_t_Dictionary, isa_proxy, 0,
                  sizeof(::MVRT_t) );
      instance.SetNew(&new_MVRT_t);
      instance.SetNewArray(&newArray_MVRT_t);
      instance.SetDelete(&delete_MVRT_t);
      instance.SetDeleteArray(&deleteArray_MVRT_t);
      instance.SetDestructor(&destruct_MVRT_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::MVRT_t*)
   {
      return GenerateInitInstanceLocal((::MVRT_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::MVRT_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void MVRT_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::MVRT_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void PART_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PART_t_Dictionary();
   static void *new_PART_t(void *p = 0);
   static void *newArray_PART_t(Long_t size, void *p);
   static void delete_PART_t(void *p);
   static void deleteArray_PART_t(void *p);
   static void destruct_PART_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::PART_t*)
   {
      ::PART_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PART_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("PART_t", "./include/bankheader.h", 1690,
                  typeid(::PART_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &PART_t_Dictionary, isa_proxy, 0,
                  sizeof(::PART_t) );
      instance.SetNew(&new_PART_t);
      instance.SetNewArray(&newArray_PART_t);
      instance.SetDelete(&delete_PART_t);
      instance.SetDeleteArray(&deleteArray_PART_t);
      instance.SetDestructor(&destruct_PART_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::PART_t*)
   {
      return GenerateInitInstanceLocal((::PART_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PART_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PART_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::PART_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void PCO_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PCO_t_Dictionary();
   static void *new_PCO_t(void *p = 0);
   static void *newArray_PCO_t(Long_t size, void *p);
   static void delete_PCO_t(void *p);
   static void deleteArray_PCO_t(void *p);
   static void destruct_PCO_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::PCO_t*)
   {
      ::PCO_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PCO_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("PCO_t", "./include/bankheader.h", 1700,
                  typeid(::PCO_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &PCO_t_Dictionary, isa_proxy, 0,
                  sizeof(::PCO_t) );
      instance.SetNew(&new_PCO_t);
      instance.SetNewArray(&newArray_PCO_t);
      instance.SetDelete(&delete_PCO_t);
      instance.SetDeleteArray(&deleteArray_PCO_t);
      instance.SetDestructor(&destruct_PCO_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::PCO_t*)
   {
      return GenerateInitInstanceLocal((::PCO_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PCO_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PCO_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::PCO_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void PHTM_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PHTM_t_Dictionary();
   static void *new_PHTM_t(void *p = 0);
   static void *newArray_PHTM_t(Long_t size, void *p);
   static void delete_PHTM_t(void *p);
   static void deleteArray_PHTM_t(void *p);
   static void destruct_PHTM_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::PHTM_t*)
   {
      ::PHTM_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PHTM_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("PHTM_t", "./include/bankheader.h", 1713,
                  typeid(::PHTM_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &PHTM_t_Dictionary, isa_proxy, 0,
                  sizeof(::PHTM_t) );
      instance.SetNew(&new_PHTM_t);
      instance.SetNewArray(&newArray_PHTM_t);
      instance.SetDelete(&delete_PHTM_t);
      instance.SetDeleteArray(&deleteArray_PHTM_t);
      instance.SetDestructor(&destruct_PHTM_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::PHTM_t*)
   {
      return GenerateInitInstanceLocal((::PHTM_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PHTM_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PHTM_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::PHTM_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void PID1_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PID1_t_Dictionary();
   static void *new_PID1_t(void *p = 0);
   static void *newArray_PID1_t(Long_t size, void *p);
   static void delete_PID1_t(void *p);
   static void deleteArray_PID1_t(void *p);
   static void destruct_PID1_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::PID1_t*)
   {
      ::PID1_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PID1_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("PID1_t", "./include/bankheader.h", 1731,
                  typeid(::PID1_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &PID1_t_Dictionary, isa_proxy, 0,
                  sizeof(::PID1_t) );
      instance.SetNew(&new_PID1_t);
      instance.SetNewArray(&newArray_PID1_t);
      instance.SetDelete(&delete_PID1_t);
      instance.SetDeleteArray(&deleteArray_PID1_t);
      instance.SetDestructor(&destruct_PID1_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::PID1_t*)
   {
      return GenerateInitInstanceLocal((::PID1_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PID1_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PID1_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::PID1_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void PID2_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PID2_t_Dictionary();
   static void *new_PID2_t(void *p = 0);
   static void *newArray_PID2_t(Long_t size, void *p);
   static void delete_PID2_t(void *p);
   static void deleteArray_PID2_t(void *p);
   static void destruct_PID2_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::PID2_t*)
   {
      ::PID2_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PID2_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("PID2_t", "./include/bankheader.h", 1749,
                  typeid(::PID2_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &PID2_t_Dictionary, isa_proxy, 0,
                  sizeof(::PID2_t) );
      instance.SetNew(&new_PID2_t);
      instance.SetNewArray(&newArray_PID2_t);
      instance.SetDelete(&delete_PID2_t);
      instance.SetDeleteArray(&deleteArray_PID2_t);
      instance.SetDestructor(&destruct_PID2_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::PID2_t*)
   {
      return GenerateInitInstanceLocal((::PID2_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PID2_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PID2_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::PID2_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void PID3_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PID3_t_Dictionary();
   static void *new_PID3_t(void *p = 0);
   static void *newArray_PID3_t(Long_t size, void *p);
   static void delete_PID3_t(void *p);
   static void deleteArray_PID3_t(void *p);
   static void destruct_PID3_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::PID3_t*)
   {
      ::PID3_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PID3_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("PID3_t", "./include/bankheader.h", 1767,
                  typeid(::PID3_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &PID3_t_Dictionary, isa_proxy, 0,
                  sizeof(::PID3_t) );
      instance.SetNew(&new_PID3_t);
      instance.SetNewArray(&newArray_PID3_t);
      instance.SetDelete(&delete_PID3_t);
      instance.SetDeleteArray(&deleteArray_PID3_t);
      instance.SetDestructor(&destruct_PID3_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::PID3_t*)
   {
      return GenerateInitInstanceLocal((::PID3_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PID3_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PID3_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::PID3_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void PID4_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PID4_t_Dictionary();
   static void *new_PID4_t(void *p = 0);
   static void *newArray_PID4_t(Long_t size, void *p);
   static void delete_PID4_t(void *p);
   static void deleteArray_PID4_t(void *p);
   static void destruct_PID4_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::PID4_t*)
   {
      ::PID4_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PID4_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("PID4_t", "./include/bankheader.h", 1785,
                  typeid(::PID4_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &PID4_t_Dictionary, isa_proxy, 0,
                  sizeof(::PID4_t) );
      instance.SetNew(&new_PID4_t);
      instance.SetNewArray(&newArray_PID4_t);
      instance.SetDelete(&delete_PID4_t);
      instance.SetDeleteArray(&deleteArray_PID4_t);
      instance.SetDestructor(&destruct_PID4_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::PID4_t*)
   {
      return GenerateInitInstanceLocal((::PID4_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PID4_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PID4_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::PID4_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void PID5_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PID5_t_Dictionary();
   static void *new_PID5_t(void *p = 0);
   static void *newArray_PID5_t(Long_t size, void *p);
   static void delete_PID5_t(void *p);
   static void deleteArray_PID5_t(void *p);
   static void destruct_PID5_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::PID5_t*)
   {
      ::PID5_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PID5_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("PID5_t", "./include/bankheader.h", 1803,
                  typeid(::PID5_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &PID5_t_Dictionary, isa_proxy, 0,
                  sizeof(::PID5_t) );
      instance.SetNew(&new_PID5_t);
      instance.SetNewArray(&newArray_PID5_t);
      instance.SetDelete(&delete_PID5_t);
      instance.SetDeleteArray(&deleteArray_PID5_t);
      instance.SetDestructor(&destruct_PID5_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::PID5_t*)
   {
      return GenerateInitInstanceLocal((::PID5_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PID5_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PID5_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::PID5_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void PID6_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PID6_t_Dictionary();
   static void *new_PID6_t(void *p = 0);
   static void *newArray_PID6_t(Long_t size, void *p);
   static void delete_PID6_t(void *p);
   static void deleteArray_PID6_t(void *p);
   static void destruct_PID6_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::PID6_t*)
   {
      ::PID6_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PID6_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("PID6_t", "./include/bankheader.h", 1821,
                  typeid(::PID6_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &PID6_t_Dictionary, isa_proxy, 0,
                  sizeof(::PID6_t) );
      instance.SetNew(&new_PID6_t);
      instance.SetNewArray(&newArray_PID6_t);
      instance.SetDelete(&delete_PID6_t);
      instance.SetDeleteArray(&deleteArray_PID6_t);
      instance.SetDestructor(&destruct_PID6_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::PID6_t*)
   {
      return GenerateInitInstanceLocal((::PID6_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PID6_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PID6_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::PID6_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void PIDT_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PIDT_t_Dictionary();
   static void *new_PIDT_t(void *p = 0);
   static void *newArray_PIDT_t(Long_t size, void *p);
   static void delete_PIDT_t(void *p);
   static void deleteArray_PIDT_t(void *p);
   static void destruct_PIDT_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::PIDT_t*)
   {
      ::PIDT_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PIDT_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("PIDT_t", "./include/bankheader.h", 1833,
                  typeid(::PIDT_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &PIDT_t_Dictionary, isa_proxy, 0,
                  sizeof(::PIDT_t) );
      instance.SetNew(&new_PIDT_t);
      instance.SetNewArray(&newArray_PIDT_t);
      instance.SetDelete(&delete_PIDT_t);
      instance.SetDeleteArray(&deleteArray_PIDT_t);
      instance.SetDestructor(&destruct_PIDT_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::PIDT_t*)
   {
      return GenerateInitInstanceLocal((::PIDT_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PIDT_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PIDT_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::PIDT_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void PRTM_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PRTM_t_Dictionary();
   static void *new_PRTM_t(void *p = 0);
   static void *newArray_PRTM_t(Long_t size, void *p);
   static void delete_PRTM_t(void *p);
   static void deleteArray_PRTM_t(void *p);
   static void destruct_PRTM_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::PRTM_t*)
   {
      ::PRTM_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PRTM_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("PRTM_t", "./include/bankheader.h", 1836,
                  typeid(::PRTM_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &PRTM_t_Dictionary, isa_proxy, 0,
                  sizeof(::PRTM_t) );
      instance.SetNew(&new_PRTM_t);
      instance.SetNewArray(&newArray_PRTM_t);
      instance.SetDelete(&delete_PRTM_t);
      instance.SetDeleteArray(&deleteArray_PRTM_t);
      instance.SetDestructor(&destruct_PRTM_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::PRTM_t*)
   {
      return GenerateInitInstanceLocal((::PRTM_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PRTM_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PRTM_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::PRTM_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void PSO_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PSO_t_Dictionary();
   static void *new_PSO_t(void *p = 0);
   static void *newArray_PSO_t(Long_t size, void *p);
   static void delete_PSO_t(void *p);
   static void deleteArray_PSO_t(void *p);
   static void destruct_PSO_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::PSO_t*)
   {
      ::PSO_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PSO_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("PSO_t", "./include/bankheader.h", 1842,
                  typeid(::PSO_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &PSO_t_Dictionary, isa_proxy, 0,
                  sizeof(::PSO_t) );
      instance.SetNew(&new_PSO_t);
      instance.SetNewArray(&newArray_PSO_t);
      instance.SetDelete(&delete_PSO_t);
      instance.SetDeleteArray(&deleteArray_PSO_t);
      instance.SetDestructor(&destruct_PSO_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::PSO_t*)
   {
      return GenerateInitInstanceLocal((::PSO_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PSO_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PSO_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::PSO_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void PTDB_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PTDB_t_Dictionary();
   static void *new_PTDB_t(void *p = 0);
   static void *newArray_PTDB_t(Long_t size, void *p);
   static void delete_PTDB_t(void *p);
   static void deleteArray_PTDB_t(void *p);
   static void destruct_PTDB_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::PTDB_t*)
   {
      ::PTDB_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PTDB_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("PTDB_t", "./include/bankheader.h", 1855,
                  typeid(::PTDB_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &PTDB_t_Dictionary, isa_proxy, 0,
                  sizeof(::PTDB_t) );
      instance.SetNew(&new_PTDB_t);
      instance.SetNewArray(&newArray_PTDB_t);
      instance.SetDelete(&delete_PTDB_t);
      instance.SetDeleteArray(&deleteArray_PTDB_t);
      instance.SetDestructor(&destruct_PTDB_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::PTDB_t*)
   {
      return GenerateInitInstanceLocal((::PTDB_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PTDB_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PTDB_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::PTDB_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void RCST_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void RCST_t_Dictionary();
   static void *new_RCST_t(void *p = 0);
   static void *newArray_RCST_t(Long_t size, void *p);
   static void delete_RCST_t(void *p);
   static void deleteArray_RCST_t(void *p);
   static void destruct_RCST_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::RCST_t*)
   {
      ::RCST_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RCST_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("RCST_t", "./include/bankheader.h", 1872,
                  typeid(::RCST_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &RCST_t_Dictionary, isa_proxy, 0,
                  sizeof(::RCST_t) );
      instance.SetNew(&new_RCST_t);
      instance.SetNewArray(&newArray_RCST_t);
      instance.SetDelete(&delete_RCST_t);
      instance.SetDeleteArray(&deleteArray_RCST_t);
      instance.SetDestructor(&destruct_RCST_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::RCST_t*)
   {
      return GenerateInitInstanceLocal((::RCST_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::RCST_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void RCST_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::RCST_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void REF_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void REF_t_Dictionary();
   static void *new_REF_t(void *p = 0);
   static void *newArray_REF_t(Long_t size, void *p);
   static void delete_REF_t(void *p);
   static void deleteArray_REF_t(void *p);
   static void destruct_REF_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::REF_t*)
   {
      ::REF_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::REF_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("REF_t", "./include/bankheader.h", 1876,
                  typeid(::REF_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &REF_t_Dictionary, isa_proxy, 0,
                  sizeof(::REF_t) );
      instance.SetNew(&new_REF_t);
      instance.SetNewArray(&newArray_REF_t);
      instance.SetDelete(&delete_REF_t);
      instance.SetDeleteArray(&deleteArray_REF_t);
      instance.SetDestructor(&destruct_REF_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::REF_t*)
   {
      return GenerateInitInstanceLocal((::REF_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::REF_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void REF_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::REF_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void RF_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void RF_t_Dictionary();
   static void *new_RF_t(void *p = 0);
   static void *newArray_RF_t(Long_t size, void *p);
   static void delete_RF_t(void *p);
   static void deleteArray_RF_t(void *p);
   static void destruct_RF_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::RF_t*)
   {
      ::RF_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RF_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("RF_t", "./include/bankheader.h", 1881,
                  typeid(::RF_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &RF_t_Dictionary, isa_proxy, 0,
                  sizeof(::RF_t) );
      instance.SetNew(&new_RF_t);
      instance.SetNewArray(&newArray_RF_t);
      instance.SetDelete(&delete_RF_t);
      instance.SetDeleteArray(&deleteArray_RF_t);
      instance.SetDestructor(&destruct_RF_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::RF_t*)
   {
      return GenerateInitInstanceLocal((::RF_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::RF_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void RF_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::RF_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void RFT_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void RFT_t_Dictionary();
   static void *new_RFT_t(void *p = 0);
   static void *newArray_RFT_t(Long_t size, void *p);
   static void delete_RFT_t(void *p);
   static void deleteArray_RFT_t(void *p);
   static void destruct_RFT_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::RFT_t*)
   {
      ::RFT_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RFT_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("RFT_t", "./include/bankheader.h", 1885,
                  typeid(::RFT_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &RFT_t_Dictionary, isa_proxy, 0,
                  sizeof(::RFT_t) );
      instance.SetNew(&new_RFT_t);
      instance.SetNewArray(&newArray_RFT_t);
      instance.SetDelete(&delete_RFT_t);
      instance.SetDeleteArray(&deleteArray_RFT_t);
      instance.SetDestructor(&destruct_RFT_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::RFT_t*)
   {
      return GenerateInitInstanceLocal((::RFT_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::RFT_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void RFT_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::RFT_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void RGLK_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void RGLK_t_Dictionary();
   static void *new_RGLK_t(void *p = 0);
   static void *newArray_RGLK_t(Long_t size, void *p);
   static void delete_RGLK_t(void *p);
   static void deleteArray_RGLK_t(void *p);
   static void destruct_RGLK_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::RGLK_t*)
   {
      ::RGLK_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RGLK_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("RGLK_t", "./include/bankheader.h", 1897,
                  typeid(::RGLK_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &RGLK_t_Dictionary, isa_proxy, 0,
                  sizeof(::RGLK_t) );
      instance.SetNew(&new_RGLK_t);
      instance.SetNewArray(&newArray_RGLK_t);
      instance.SetDelete(&delete_RGLK_t);
      instance.SetDeleteArray(&deleteArray_RGLK_t);
      instance.SetDestructor(&destruct_RGLK_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::RGLK_t*)
   {
      return GenerateInitInstanceLocal((::RGLK_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::RGLK_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void RGLK_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::RGLK_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void RNLG_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void RNLG_t_Dictionary();
   static void *new_RNLG_t(void *p = 0);
   static void *newArray_RNLG_t(Long_t size, void *p);
   static void delete_RNLG_t(void *p);
   static void deleteArray_RNLG_t(void *p);
   static void destruct_RNLG_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::RNLG_t*)
   {
      ::RNLG_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RNLG_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("RNLG_t", "./include/bankheader.h", 1900,
                  typeid(::RNLG_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &RNLG_t_Dictionary, isa_proxy, 0,
                  sizeof(::RNLG_t) );
      instance.SetNew(&new_RNLG_t);
      instance.SetNewArray(&newArray_RNLG_t);
      instance.SetDelete(&delete_RNLG_t);
      instance.SetDeleteArray(&deleteArray_RNLG_t);
      instance.SetDestructor(&destruct_RNLG_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::RNLG_t*)
   {
      return GenerateInitInstanceLocal((::RNLG_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::RNLG_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void RNLG_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::RNLG_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void RNPE_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void RNPE_t_Dictionary();
   static void *new_RNPE_t(void *p = 0);
   static void *newArray_RNPE_t(Long_t size, void *p);
   static void delete_RNPE_t(void *p);
   static void deleteArray_RNPE_t(void *p);
   static void destruct_RNPE_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::RNPE_t*)
   {
      ::RNPE_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RNPE_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("RNPE_t", "./include/bankheader.h", 1904,
                  typeid(::RNPE_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &RNPE_t_Dictionary, isa_proxy, 0,
                  sizeof(::RNPE_t) );
      instance.SetNew(&new_RNPE_t);
      instance.SetNewArray(&newArray_RNPE_t);
      instance.SetDelete(&delete_RNPE_t);
      instance.SetDeleteArray(&deleteArray_RNPE_t);
      instance.SetDestructor(&destruct_RNPE_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::RNPE_t*)
   {
      return GenerateInitInstanceLocal((::RNPE_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::RNPE_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void RNPE_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::RNPE_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void RTSL_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void RTSL_t_Dictionary();
   static void *new_RTSL_t(void *p = 0);
   static void *newArray_RTSL_t(Long_t size, void *p);
   static void delete_RTSL_t(void *p);
   static void deleteArray_RTSL_t(void *p);
   static void destruct_RTSL_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::RTSL_t*)
   {
      ::RTSL_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RTSL_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("RTSL_t", "./include/bankheader.h", 1970,
                  typeid(::RTSL_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &RTSL_t_Dictionary, isa_proxy, 0,
                  sizeof(::RTSL_t) );
      instance.SetNew(&new_RTSL_t);
      instance.SetNewArray(&newArray_RTSL_t);
      instance.SetDelete(&delete_RTSL_t);
      instance.SetDeleteArray(&deleteArray_RTSL_t);
      instance.SetDestructor(&destruct_RTSL_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::RTSL_t*)
   {
      return GenerateInitInstanceLocal((::RTSL_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::RTSL_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void RTSL_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::RTSL_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void RUNC_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void RUNC_t_Dictionary();
   static void *new_RUNC_t(void *p = 0);
   static void *newArray_RUNC_t(Long_t size, void *p);
   static void delete_RUNC_t(void *p);
   static void deleteArray_RUNC_t(void *p);
   static void destruct_RUNC_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::RUNC_t*)
   {
      ::RUNC_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RUNC_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("RUNC_t", "./include/bankheader.h", 1985,
                  typeid(::RUNC_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &RUNC_t_Dictionary, isa_proxy, 0,
                  sizeof(::RUNC_t) );
      instance.SetNew(&new_RUNC_t);
      instance.SetNewArray(&newArray_RUNC_t);
      instance.SetDelete(&delete_RUNC_t);
      instance.SetDeleteArray(&deleteArray_RUNC_t);
      instance.SetDestructor(&destruct_RUNC_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::RUNC_t*)
   {
      return GenerateInitInstanceLocal((::RUNC_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::RUNC_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void RUNC_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::RUNC_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void S1ST_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void S1ST_t_Dictionary();
   static void *new_S1ST_t(void *p = 0);
   static void *newArray_S1ST_t(Long_t size, void *p);
   static void delete_S1ST_t(void *p);
   static void deleteArray_S1ST_t(void *p);
   static void destruct_S1ST_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::S1ST_t*)
   {
      ::S1ST_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::S1ST_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("S1ST_t", "./include/bankheader.h", 2022,
                  typeid(::S1ST_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &S1ST_t_Dictionary, isa_proxy, 0,
                  sizeof(::S1ST_t) );
      instance.SetNew(&new_S1ST_t);
      instance.SetNewArray(&newArray_S1ST_t);
      instance.SetDelete(&delete_S1ST_t);
      instance.SetDeleteArray(&deleteArray_S1ST_t);
      instance.SetDestructor(&destruct_S1ST_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::S1ST_t*)
   {
      return GenerateInitInstanceLocal((::S1ST_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::S1ST_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void S1ST_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::S1ST_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SC1_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SC1_t_Dictionary();
   static void *new_SC1_t(void *p = 0);
   static void *newArray_SC1_t(Long_t size, void *p);
   static void delete_SC1_t(void *p);
   static void deleteArray_SC1_t(void *p);
   static void destruct_SC1_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SC1_t*)
   {
      ::SC1_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SC1_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SC1_t", "./include/bankheader.h", 2033,
                  typeid(::SC1_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SC1_t_Dictionary, isa_proxy, 0,
                  sizeof(::SC1_t) );
      instance.SetNew(&new_SC1_t);
      instance.SetNewArray(&newArray_SC1_t);
      instance.SetDelete(&delete_SC1_t);
      instance.SetDeleteArray(&deleteArray_SC1_t);
      instance.SetDestructor(&destruct_SC1_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SC1_t*)
   {
      return GenerateInitInstanceLocal((::SC1_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SC1_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SC1_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SC1_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SCC_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SCC_t_Dictionary();
   static void *new_SCC_t(void *p = 0);
   static void *newArray_SCC_t(Long_t size, void *p);
   static void delete_SCC_t(void *p);
   static void deleteArray_SCC_t(void *p);
   static void destruct_SCC_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SCC_t*)
   {
      ::SCC_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SCC_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SCC_t", "./include/bankheader.h", 2083,
                  typeid(::SCC_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SCC_t_Dictionary, isa_proxy, 0,
                  sizeof(::SCC_t) );
      instance.SetNew(&new_SCC_t);
      instance.SetNewArray(&newArray_SCC_t);
      instance.SetDelete(&delete_SCC_t);
      instance.SetDeleteArray(&deleteArray_SCC_t);
      instance.SetDestructor(&destruct_SCC_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SCC_t*)
   {
      return GenerateInitInstanceLocal((::SCC_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SCC_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SCC_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SCC_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SC_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SC_t_Dictionary();
   static void *new_SC_t(void *p = 0);
   static void *newArray_SC_t(Long_t size, void *p);
   static void delete_SC_t(void *p);
   static void deleteArray_SC_t(void *p);
   static void destruct_SC_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SC_t*)
   {
      ::SC_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SC_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SC_t", "./include/bankheader.h", 2090,
                  typeid(::SC_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SC_t_Dictionary, isa_proxy, 0,
                  sizeof(::SC_t) );
      instance.SetNew(&new_SC_t);
      instance.SetNewArray(&newArray_SC_t);
      instance.SetDelete(&delete_SC_t);
      instance.SetDeleteArray(&deleteArray_SC_t);
      instance.SetDestructor(&destruct_SC_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SC_t*)
   {
      return GenerateInitInstanceLocal((::SC_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SC_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SC_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SC_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SCDI_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SCDI_t_Dictionary();
   static void *new_SCDI_t(void *p = 0);
   static void *newArray_SCDI_t(Long_t size, void *p);
   static void delete_SCDI_t(void *p);
   static void deleteArray_SCDI_t(void *p);
   static void destruct_SCDI_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SCDI_t*)
   {
      ::SCDI_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SCDI_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SCDI_t", "./include/bankheader.h", 2097,
                  typeid(::SCDI_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SCDI_t_Dictionary, isa_proxy, 0,
                  sizeof(::SCDI_t) );
      instance.SetNew(&new_SCDI_t);
      instance.SetNewArray(&newArray_SCDI_t);
      instance.SetDelete(&delete_SCDI_t);
      instance.SetDeleteArray(&deleteArray_SCDI_t);
      instance.SetDestructor(&destruct_SCDI_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SCDI_t*)
   {
      return GenerateInitInstanceLocal((::SCDI_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SCDI_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SCDI_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SCDI_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SCGD_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SCGD_t_Dictionary();
   static void *new_SCGD_t(void *p = 0);
   static void *newArray_SCGD_t(Long_t size, void *p);
   static void delete_SCGD_t(void *p);
   static void deleteArray_SCGD_t(void *p);
   static void destruct_SCGD_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SCGD_t*)
   {
      ::SCGD_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SCGD_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SCGD_t", "./include/bankheader.h", 2109,
                  typeid(::SCGD_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SCGD_t_Dictionary, isa_proxy, 0,
                  sizeof(::SCGD_t) );
      instance.SetNew(&new_SCGD_t);
      instance.SetNewArray(&newArray_SCGD_t);
      instance.SetDelete(&delete_SCGD_t);
      instance.SetDeleteArray(&deleteArray_SCGD_t);
      instance.SetDestructor(&destruct_SCGD_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SCGD_t*)
   {
      return GenerateInitInstanceLocal((::SCGD_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SCGD_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SCGD_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SCGD_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SCG_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SCG_t_Dictionary();
   static void *new_SCG_t(void *p = 0);
   static void *newArray_SCG_t(Long_t size, void *p);
   static void delete_SCG_t(void *p);
   static void deleteArray_SCG_t(void *p);
   static void destruct_SCG_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SCG_t*)
   {
      ::SCG_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SCG_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SCG_t", "./include/bankheader.h", 2122,
                  typeid(::SCG_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SCG_t_Dictionary, isa_proxy, 0,
                  sizeof(::SCG_t) );
      instance.SetNew(&new_SCG_t);
      instance.SetNewArray(&newArray_SCG_t);
      instance.SetDelete(&delete_SCG_t);
      instance.SetDeleteArray(&deleteArray_SCG_t);
      instance.SetDestructor(&destruct_SCG_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SCG_t*)
   {
      return GenerateInitInstanceLocal((::SCG_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SCG_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SCG_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SCG_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SCH_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SCH_t_Dictionary();
   static void *new_SCH_t(void *p = 0);
   static void *newArray_SCH_t(Long_t size, void *p);
   static void delete_SCH_t(void *p);
   static void deleteArray_SCH_t(void *p);
   static void destruct_SCH_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SCH_t*)
   {
      ::SCH_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SCH_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SCH_t", "./include/bankheader.h", 2133,
                  typeid(::SCH_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SCH_t_Dictionary, isa_proxy, 0,
                  sizeof(::SCH_t) );
      instance.SetNew(&new_SCH_t);
      instance.SetNewArray(&newArray_SCH_t);
      instance.SetDelete(&delete_SCH_t);
      instance.SetDeleteArray(&deleteArray_SCH_t);
      instance.SetDestructor(&destruct_SCH_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SCH_t*)
   {
      return GenerateInitInstanceLocal((::SCH_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SCH_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SCH_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SCH_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SCMD_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SCMD_t_Dictionary();
   static void *new_SCMD_t(void *p = 0);
   static void *newArray_SCMD_t(Long_t size, void *p);
   static void delete_SCMD_t(void *p);
   static void deleteArray_SCMD_t(void *p);
   static void destruct_SCMD_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SCMD_t*)
   {
      ::SCMD_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SCMD_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SCMD_t", "./include/bankheader.h", 2148,
                  typeid(::SCMD_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SCMD_t_Dictionary, isa_proxy, 0,
                  sizeof(::SCMD_t) );
      instance.SetNew(&new_SCMD_t);
      instance.SetNewArray(&newArray_SCMD_t);
      instance.SetDelete(&delete_SCMD_t);
      instance.SetDeleteArray(&deleteArray_SCMD_t);
      instance.SetDestructor(&destruct_SCMD_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SCMD_t*)
   {
      return GenerateInitInstanceLocal((::SCMD_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SCMD_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SCMD_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SCMD_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SCMT_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SCMT_t_Dictionary();
   static void *new_SCMT_t(void *p = 0);
   static void *newArray_SCMT_t(Long_t size, void *p);
   static void delete_SCMT_t(void *p);
   static void deleteArray_SCMT_t(void *p);
   static void destruct_SCMT_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SCMT_t*)
   {
      ::SCMT_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SCMT_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SCMT_t", "./include/bankheader.h", 2151,
                  typeid(::SCMT_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SCMT_t_Dictionary, isa_proxy, 0,
                  sizeof(::SCMT_t) );
      instance.SetNew(&new_SCMT_t);
      instance.SetNewArray(&newArray_SCMT_t);
      instance.SetDelete(&delete_SCMT_t);
      instance.SetDeleteArray(&deleteArray_SCMT_t);
      instance.SetDestructor(&destruct_SCMT_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SCMT_t*)
   {
      return GenerateInitInstanceLocal((::SCMT_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SCMT_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SCMT_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SCMT_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SCMW_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SCMW_t_Dictionary();
   static void *new_SCMW_t(void *p = 0);
   static void *newArray_SCMW_t(Long_t size, void *p);
   static void delete_SCMW_t(void *p);
   static void deleteArray_SCMW_t(void *p);
   static void destruct_SCMW_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SCMW_t*)
   {
      ::SCMW_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SCMW_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SCMW_t", "./include/bankheader.h", 2154,
                  typeid(::SCMW_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SCMW_t_Dictionary, isa_proxy, 0,
                  sizeof(::SCMW_t) );
      instance.SetNew(&new_SCMW_t);
      instance.SetNewArray(&newArray_SCMW_t);
      instance.SetDelete(&delete_SCMW_t);
      instance.SetDeleteArray(&deleteArray_SCMW_t);
      instance.SetDestructor(&destruct_SCMW_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SCMW_t*)
   {
      return GenerateInitInstanceLocal((::SCMW_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SCMW_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SCMW_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SCMW_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SCPB_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SCPB_t_Dictionary();
   static void *new_SCPB_t(void *p = 0);
   static void *newArray_SCPB_t(Long_t size, void *p);
   static void delete_SCPB_t(void *p);
   static void deleteArray_SCPB_t(void *p);
   static void destruct_SCPB_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SCPB_t*)
   {
      ::SCPB_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SCPB_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SCPB_t", "./include/bankheader.h", 2162,
                  typeid(::SCPB_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SCPB_t_Dictionary, isa_proxy, 0,
                  sizeof(::SCPB_t) );
      instance.SetNew(&new_SCPB_t);
      instance.SetNewArray(&newArray_SCPB_t);
      instance.SetDelete(&delete_SCPB_t);
      instance.SetDeleteArray(&deleteArray_SCPB_t);
      instance.SetDestructor(&destruct_SCPB_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SCPB_t*)
   {
      return GenerateInitInstanceLocal((::SCPB_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SCPB_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SCPB_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SCPB_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SCP_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SCP_t_Dictionary();
   static void *new_SCP_t(void *p = 0);
   static void *newArray_SCP_t(Long_t size, void *p);
   static void delete_SCP_t(void *p);
   static void deleteArray_SCP_t(void *p);
   static void destruct_SCP_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SCP_t*)
   {
      ::SCP_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SCP_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SCP_t", "./include/bankheader.h", 2180,
                  typeid(::SCP_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SCP_t_Dictionary, isa_proxy, 0,
                  sizeof(::SCP_t) );
      instance.SetNew(&new_SCP_t);
      instance.SetNewArray(&newArray_SCP_t);
      instance.SetDelete(&delete_SCP_t);
      instance.SetDeleteArray(&deleteArray_SCP_t);
      instance.SetDestructor(&destruct_SCP_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SCP_t*)
   {
      return GenerateInitInstanceLocal((::SCP_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SCP_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SCP_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SCP_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SCPE_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SCPE_t_Dictionary();
   static void *new_SCPE_t(void *p = 0);
   static void *newArray_SCPE_t(Long_t size, void *p);
   static void delete_SCPE_t(void *p);
   static void deleteArray_SCPE_t(void *p);
   static void destruct_SCPE_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SCPE_t*)
   {
      ::SCPE_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SCPE_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SCPE_t", "./include/bankheader.h", 2187,
                  typeid(::SCPE_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SCPE_t_Dictionary, isa_proxy, 0,
                  sizeof(::SCPE_t) );
      instance.SetNew(&new_SCPE_t);
      instance.SetNewArray(&newArray_SCPE_t);
      instance.SetDelete(&delete_SCPE_t);
      instance.SetDeleteArray(&deleteArray_SCPE_t);
      instance.SetDestructor(&destruct_SCPE_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SCPE_t*)
   {
      return GenerateInitInstanceLocal((::SCPE_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SCPE_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SCPE_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SCPE_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SCPS_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SCPS_t_Dictionary();
   static void *new_SCPS_t(void *p = 0);
   static void *newArray_SCPS_t(Long_t size, void *p);
   static void delete_SCPS_t(void *p);
   static void deleteArray_SCPS_t(void *p);
   static void destruct_SCPS_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SCPS_t*)
   {
      ::SCPS_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SCPS_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SCPS_t", "./include/bankheader.h", 2205,
                  typeid(::SCPS_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SCPS_t_Dictionary, isa_proxy, 0,
                  sizeof(::SCPS_t) );
      instance.SetNew(&new_SCPS_t);
      instance.SetNewArray(&newArray_SCPS_t);
      instance.SetDelete(&delete_SCPS_t);
      instance.SetDeleteArray(&deleteArray_SCPS_t);
      instance.SetDestructor(&destruct_SCPS_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SCPS_t*)
   {
      return GenerateInitInstanceLocal((::SCPS_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SCPS_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SCPS_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SCPS_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SCRC_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SCRC_t_Dictionary();
   static void *new_SCRC_t(void *p = 0);
   static void *newArray_SCRC_t(Long_t size, void *p);
   static void delete_SCRC_t(void *p);
   static void deleteArray_SCRC_t(void *p);
   static void destruct_SCRC_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SCRC_t*)
   {
      ::SCRC_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SCRC_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SCRC_t", "./include/bankheader.h", 2219,
                  typeid(::SCRC_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SCRC_t_Dictionary, isa_proxy, 0,
                  sizeof(::SCRC_t) );
      instance.SetNew(&new_SCRC_t);
      instance.SetNewArray(&newArray_SCRC_t);
      instance.SetDelete(&delete_SCRC_t);
      instance.SetDeleteArray(&deleteArray_SCRC_t);
      instance.SetDestructor(&destruct_SCRC_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SCRC_t*)
   {
      return GenerateInitInstanceLocal((::SCRC_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SCRC_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SCRC_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SCRC_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SCR_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SCR_t_Dictionary();
   static void *new_SCR_t(void *p = 0);
   static void *newArray_SCR_t(Long_t size, void *p);
   static void delete_SCR_t(void *p);
   static void deleteArray_SCR_t(void *p);
   static void destruct_SCR_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SCR_t*)
   {
      ::SCR_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SCR_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SCR_t", "./include/bankheader.h", 2233,
                  typeid(::SCR_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SCR_t_Dictionary, isa_proxy, 0,
                  sizeof(::SCR_t) );
      instance.SetNew(&new_SCR_t);
      instance.SetNewArray(&newArray_SCR_t);
      instance.SetDelete(&delete_SCR_t);
      instance.SetDeleteArray(&deleteArray_SCR_t);
      instance.SetDestructor(&destruct_SCR_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SCR_t*)
   {
      return GenerateInitInstanceLocal((::SCR_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SCR_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SCR_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SCR_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SCS_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SCS_t_Dictionary();
   static void *new_SCS_t(void *p = 0);
   static void *newArray_SCS_t(Long_t size, void *p);
   static void delete_SCS_t(void *p);
   static void deleteArray_SCS_t(void *p);
   static void destruct_SCS_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SCS_t*)
   {
      ::SCS_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SCS_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SCS_t", "./include/bankheader.h", 2427,
                  typeid(::SCS_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SCS_t_Dictionary, isa_proxy, 0,
                  sizeof(::SCS_t) );
      instance.SetNew(&new_SCS_t);
      instance.SetNewArray(&newArray_SCS_t);
      instance.SetDelete(&delete_SCS_t);
      instance.SetDeleteArray(&deleteArray_SCS_t);
      instance.SetDestructor(&destruct_SCS_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SCS_t*)
   {
      return GenerateInitInstanceLocal((::SCS_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SCS_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SCS_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SCS_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SCT_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SCT_t_Dictionary();
   static void *new_SCT_t(void *p = 0);
   static void *newArray_SCT_t(Long_t size, void *p);
   static void delete_SCT_t(void *p);
   static void deleteArray_SCT_t(void *p);
   static void destruct_SCT_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SCT_t*)
   {
      ::SCT_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SCT_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SCT_t", "./include/bankheader.h", 2431,
                  typeid(::SCT_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SCT_t_Dictionary, isa_proxy, 0,
                  sizeof(::SCT_t) );
      instance.SetNew(&new_SCT_t);
      instance.SetNewArray(&newArray_SCT_t);
      instance.SetDelete(&delete_SCT_t);
      instance.SetDeleteArray(&deleteArray_SCT_t);
      instance.SetDestructor(&destruct_SCT_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SCT_t*)
   {
      return GenerateInitInstanceLocal((::SCT_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SCT_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SCT_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SCT_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SGMP_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SGMP_t_Dictionary();
   static void *new_SGMP_t(void *p = 0);
   static void *newArray_SGMP_t(Long_t size, void *p);
   static void delete_SGMP_t(void *p);
   static void deleteArray_SGMP_t(void *p);
   static void destruct_SGMP_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SGMP_t*)
   {
      ::SGMP_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SGMP_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SGMP_t", "./include/bankheader.h", 2440,
                  typeid(::SGMP_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SGMP_t_Dictionary, isa_proxy, 0,
                  sizeof(::SGMP_t) );
      instance.SetNew(&new_SGMP_t);
      instance.SetNewArray(&newArray_SGMP_t);
      instance.SetDelete(&delete_SGMP_t);
      instance.SetDeleteArray(&deleteArray_SGMP_t);
      instance.SetDestructor(&destruct_SGMP_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SGMP_t*)
   {
      return GenerateInitInstanceLocal((::SGMP_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SGMP_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SGMP_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SGMP_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SPAR_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SPAR_t_Dictionary();
   static void *new_SPAR_t(void *p = 0);
   static void *newArray_SPAR_t(Long_t size, void *p);
   static void delete_SPAR_t(void *p);
   static void deleteArray_SPAR_t(void *p);
   static void destruct_SPAR_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SPAR_t*)
   {
      ::SPAR_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SPAR_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SPAR_t", "./include/bankheader.h", 2446,
                  typeid(::SPAR_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SPAR_t_Dictionary, isa_proxy, 0,
                  sizeof(::SPAR_t) );
      instance.SetNew(&new_SPAR_t);
      instance.SetNewArray(&newArray_SPAR_t);
      instance.SetDelete(&delete_SPAR_t);
      instance.SetDeleteArray(&deleteArray_SPAR_t);
      instance.SetDestructor(&destruct_SPAR_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SPAR_t*)
   {
      return GenerateInitInstanceLocal((::SPAR_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SPAR_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SPAR_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SPAR_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SPIN_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SPIN_t_Dictionary();
   static void *new_SPIN_t(void *p = 0);
   static void *newArray_SPIN_t(Long_t size, void *p);
   static void delete_SPIN_t(void *p);
   static void deleteArray_SPIN_t(void *p);
   static void destruct_SPIN_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SPIN_t*)
   {
      ::SPIN_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SPIN_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SPIN_t", "./include/bankheader.h", 2451,
                  typeid(::SPIN_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SPIN_t_Dictionary, isa_proxy, 0,
                  sizeof(::SPIN_t) );
      instance.SetNew(&new_SPIN_t);
      instance.SetNewArray(&newArray_SPIN_t);
      instance.SetDelete(&delete_SPIN_t);
      instance.SetDeleteArray(&deleteArray_SPIN_t);
      instance.SetDestructor(&destruct_SPIN_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SPIN_t*)
   {
      return GenerateInitInstanceLocal((::SPIN_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SPIN_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SPIN_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SPIN_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ST1_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ST1_t_Dictionary();
   static void *new_ST1_t(void *p = 0);
   static void *newArray_ST1_t(Long_t size, void *p);
   static void delete_ST1_t(void *p);
   static void deleteArray_ST1_t(void *p);
   static void destruct_ST1_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ST1_t*)
   {
      ::ST1_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ST1_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ST1_t", "./include/bankheader.h", 2459,
                  typeid(::ST1_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ST1_t_Dictionary, isa_proxy, 0,
                  sizeof(::ST1_t) );
      instance.SetNew(&new_ST1_t);
      instance.SetNewArray(&newArray_ST1_t);
      instance.SetDelete(&delete_ST1_t);
      instance.SetDeleteArray(&deleteArray_ST1_t);
      instance.SetDestructor(&destruct_ST1_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ST1_t*)
   {
      return GenerateInitInstanceLocal((::ST1_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ST1_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ST1_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ST1_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ST_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ST_t_Dictionary();
   static void *new_ST_t(void *p = 0);
   static void *newArray_ST_t(Long_t size, void *p);
   static void delete_ST_t(void *p);
   static void deleteArray_ST_t(void *p);
   static void destruct_ST_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ST_t*)
   {
      ::ST_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ST_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ST_t", "./include/bankheader.h", 2464,
                  typeid(::ST_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ST_t_Dictionary, isa_proxy, 0,
                  sizeof(::ST_t) );
      instance.SetNew(&new_ST_t);
      instance.SetNewArray(&newArray_ST_t);
      instance.SetDelete(&delete_ST_t);
      instance.SetDeleteArray(&deleteArray_ST_t);
      instance.SetDestructor(&destruct_ST_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ST_t*)
   {
      return GenerateInitInstanceLocal((::ST_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ST_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ST_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ST_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void STG_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void STG_t_Dictionary();
   static void *new_STG_t(void *p = 0);
   static void *newArray_STG_t(Long_t size, void *p);
   static void delete_STG_t(void *p);
   static void deleteArray_STG_t(void *p);
   static void destruct_STG_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::STG_t*)
   {
      ::STG_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::STG_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("STG_t", "./include/bankheader.h", 2482,
                  typeid(::STG_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &STG_t_Dictionary, isa_proxy, 0,
                  sizeof(::STG_t) );
      instance.SetNew(&new_STG_t);
      instance.SetNewArray(&newArray_STG_t);
      instance.SetDelete(&delete_STG_t);
      instance.SetDeleteArray(&deleteArray_STG_t);
      instance.SetDestructor(&destruct_STG_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::STG_t*)
   {
      return GenerateInitInstanceLocal((::STG_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::STG_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void STG_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::STG_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void STH_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void STH_t_Dictionary();
   static void *new_STH_t(void *p = 0);
   static void *newArray_STH_t(Long_t size, void *p);
   static void delete_STH_t(void *p);
   static void deleteArray_STH_t(void *p);
   static void destruct_STH_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::STH_t*)
   {
      ::STH_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::STH_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("STH_t", "./include/bankheader.h", 2494,
                  typeid(::STH_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &STH_t_Dictionary, isa_proxy, 0,
                  sizeof(::STH_t) );
      instance.SetNew(&new_STH_t);
      instance.SetNewArray(&newArray_STH_t);
      instance.SetDelete(&delete_STH_t);
      instance.SetDeleteArray(&deleteArray_STH_t);
      instance.SetDestructor(&destruct_STH_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::STH_t*)
   {
      return GenerateInitInstanceLocal((::STH_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::STH_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void STH_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::STH_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void STN0_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void STN0_t_Dictionary();
   static void *new_STN0_t(void *p = 0);
   static void *newArray_STN0_t(Long_t size, void *p);
   static void delete_STN0_t(void *p);
   static void deleteArray_STN0_t(void *p);
   static void destruct_STN0_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::STN0_t*)
   {
      ::STN0_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::STN0_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("STN0_t", "./include/bankheader.h", 2498,
                  typeid(::STN0_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &STN0_t_Dictionary, isa_proxy, 0,
                  sizeof(::STN0_t) );
      instance.SetNew(&new_STN0_t);
      instance.SetNewArray(&newArray_STN0_t);
      instance.SetDelete(&delete_STN0_t);
      instance.SetDeleteArray(&deleteArray_STN0_t);
      instance.SetDestructor(&destruct_STN0_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::STN0_t*)
   {
      return GenerateInitInstanceLocal((::STN0_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::STN0_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void STN0_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::STN0_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void STN1_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void STN1_t_Dictionary();
   static void *new_STN1_t(void *p = 0);
   static void *newArray_STN1_t(Long_t size, void *p);
   static void delete_STN1_t(void *p);
   static void deleteArray_STN1_t(void *p);
   static void destruct_STN1_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::STN1_t*)
   {
      ::STN1_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::STN1_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("STN1_t", "./include/bankheader.h", 2502,
                  typeid(::STN1_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &STN1_t_Dictionary, isa_proxy, 0,
                  sizeof(::STN1_t) );
      instance.SetNew(&new_STN1_t);
      instance.SetNewArray(&newArray_STN1_t);
      instance.SetDelete(&delete_STN1_t);
      instance.SetDeleteArray(&deleteArray_STN1_t);
      instance.SetDestructor(&destruct_STN1_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::STN1_t*)
   {
      return GenerateInitInstanceLocal((::STN1_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::STN1_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void STN1_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::STN1_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void STPB_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void STPB_t_Dictionary();
   static void *new_STPB_t(void *p = 0);
   static void *newArray_STPB_t(Long_t size, void *p);
   static void delete_STPB_t(void *p);
   static void deleteArray_STPB_t(void *p);
   static void destruct_STPB_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::STPB_t*)
   {
      ::STPB_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::STPB_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("STPB_t", "./include/bankheader.h", 2509,
                  typeid(::STPB_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &STPB_t_Dictionary, isa_proxy, 0,
                  sizeof(::STPB_t) );
      instance.SetNew(&new_STPB_t);
      instance.SetNewArray(&newArray_STPB_t);
      instance.SetDelete(&delete_STPB_t);
      instance.SetDeleteArray(&deleteArray_STPB_t);
      instance.SetDestructor(&destruct_STPB_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::STPB_t*)
   {
      return GenerateInitInstanceLocal((::STPB_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::STPB_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void STPB_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::STPB_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void STPE_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void STPE_t_Dictionary();
   static void *new_STPE_t(void *p = 0);
   static void *newArray_STPE_t(Long_t size, void *p);
   static void delete_STPE_t(void *p);
   static void deleteArray_STPE_t(void *p);
   static void destruct_STPE_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::STPE_t*)
   {
      ::STPE_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::STPE_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("STPE_t", "./include/bankheader.h", 2514,
                  typeid(::STPE_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &STPE_t_Dictionary, isa_proxy, 0,
                  sizeof(::STPE_t) );
      instance.SetNew(&new_STPE_t);
      instance.SetNewArray(&newArray_STPE_t);
      instance.SetDelete(&delete_STPE_t);
      instance.SetDeleteArray(&deleteArray_STPE_t);
      instance.SetDestructor(&destruct_STPE_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::STPE_t*)
   {
      return GenerateInitInstanceLocal((::STPE_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::STPE_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void STPE_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::STPE_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void STR_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void STR_t_Dictionary();
   static void *new_STR_t(void *p = 0);
   static void *newArray_STR_t(Long_t size, void *p);
   static void delete_STR_t(void *p);
   static void deleteArray_STR_t(void *p);
   static void destruct_STR_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::STR_t*)
   {
      ::STR_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::STR_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("STR_t", "./include/bankheader.h", 2522,
                  typeid(::STR_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &STR_t_Dictionary, isa_proxy, 0,
                  sizeof(::STR_t) );
      instance.SetNew(&new_STR_t);
      instance.SetNewArray(&newArray_STR_t);
      instance.SetDelete(&delete_STR_t);
      instance.SetDeleteArray(&deleteArray_STR_t);
      instance.SetDestructor(&destruct_STR_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::STR_t*)
   {
      return GenerateInitInstanceLocal((::STR_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::STR_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void STR_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::STR_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void STS_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void STS_t_Dictionary();
   static void *new_STS_t(void *p = 0);
   static void *newArray_STS_t(Long_t size, void *p);
   static void delete_STS_t(void *p);
   static void deleteArray_STS_t(void *p);
   static void destruct_STS_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::STS_t*)
   {
      ::STS_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::STS_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("STS_t", "./include/bankheader.h", 2540,
                  typeid(::STS_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &STS_t_Dictionary, isa_proxy, 0,
                  sizeof(::STS_t) );
      instance.SetNew(&new_STS_t);
      instance.SetNewArray(&newArray_STS_t);
      instance.SetDelete(&delete_STS_t);
      instance.SetDeleteArray(&deleteArray_STS_t);
      instance.SetDestructor(&destruct_STS_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::STS_t*)
   {
      return GenerateInitInstanceLocal((::STS_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::STS_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void STS_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::STS_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void STSN_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void STSN_t_Dictionary();
   static void *new_STSN_t(void *p = 0);
   static void *newArray_STSN_t(Long_t size, void *p);
   static void delete_STSN_t(void *p);
   static void deleteArray_STSN_t(void *p);
   static void destruct_STSN_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::STSN_t*)
   {
      ::STSN_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::STSN_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("STSN_t", "./include/bankheader.h", 2574,
                  typeid(::STSN_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &STSN_t_Dictionary, isa_proxy, 0,
                  sizeof(::STSN_t) );
      instance.SetNew(&new_STSN_t);
      instance.SetNewArray(&newArray_STSN_t);
      instance.SetDelete(&delete_STSN_t);
      instance.SetDeleteArray(&deleteArray_STSN_t);
      instance.SetDestructor(&destruct_STSN_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::STSN_t*)
   {
      return GenerateInitInstanceLocal((::STSN_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::STSN_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void STSN_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::STSN_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void SYNC_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SYNC_t_Dictionary();
   static void *new_SYNC_t(void *p = 0);
   static void *newArray_SYNC_t(Long_t size, void *p);
   static void delete_SYNC_t(void *p);
   static void deleteArray_SYNC_t(void *p);
   static void destruct_SYNC_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::SYNC_t*)
   {
      ::SYNC_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SYNC_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SYNC_t", "./include/bankheader.h", 2579,
                  typeid(::SYNC_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &SYNC_t_Dictionary, isa_proxy, 0,
                  sizeof(::SYNC_t) );
      instance.SetNew(&new_SYNC_t);
      instance.SetNewArray(&newArray_SYNC_t);
      instance.SetDelete(&delete_SYNC_t);
      instance.SetDeleteArray(&deleteArray_SYNC_t);
      instance.SetDestructor(&destruct_SYNC_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::SYNC_t*)
   {
      return GenerateInitInstanceLocal((::SYNC_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SYNC_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SYNC_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::SYNC_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TACO_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TACO_t_Dictionary();
   static void *new_TACO_t(void *p = 0);
   static void *newArray_TACO_t(Long_t size, void *p);
   static void delete_TACO_t(void *p);
   static void deleteArray_TACO_t(void *p);
   static void destruct_TACO_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TACO_t*)
   {
      ::TACO_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TACO_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TACO_t", "./include/bankheader.h", 2591,
                  typeid(::TACO_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TACO_t_Dictionary, isa_proxy, 0,
                  sizeof(::TACO_t) );
      instance.SetNew(&new_TACO_t);
      instance.SetNewArray(&newArray_TACO_t);
      instance.SetDelete(&delete_TACO_t);
      instance.SetDeleteArray(&deleteArray_TACO_t);
      instance.SetDestructor(&destruct_TACO_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TACO_t*)
   {
      return GenerateInitInstanceLocal((::TACO_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TACO_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TACO_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TACO_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TAGE_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TAGE_t_Dictionary();
   static void *new_TAGE_t(void *p = 0);
   static void *newArray_TAGE_t(Long_t size, void *p);
   static void delete_TAGE_t(void *p);
   static void deleteArray_TAGE_t(void *p);
   static void destruct_TAGE_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TAGE_t*)
   {
      ::TAGE_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TAGE_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TAGE_t", "./include/bankheader.h", 2595,
                  typeid(::TAGE_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TAGE_t_Dictionary, isa_proxy, 0,
                  sizeof(::TAGE_t) );
      instance.SetNew(&new_TAGE_t);
      instance.SetNewArray(&newArray_TAGE_t);
      instance.SetDelete(&delete_TAGE_t);
      instance.SetDeleteArray(&deleteArray_TAGE_t);
      instance.SetDestructor(&destruct_TAGE_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TAGE_t*)
   {
      return GenerateInitInstanceLocal((::TAGE_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TAGE_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TAGE_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TAGE_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TAGI_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TAGI_t_Dictionary();
   static void *new_TAGI_t(void *p = 0);
   static void *newArray_TAGI_t(Long_t size, void *p);
   static void delete_TAGI_t(void *p);
   static void deleteArray_TAGI_t(void *p);
   static void destruct_TAGI_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TAGI_t*)
   {
      ::TAGI_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TAGI_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TAGI_t", "./include/bankheader.h", 2605,
                  typeid(::TAGI_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TAGI_t_Dictionary, isa_proxy, 0,
                  sizeof(::TAGI_t) );
      instance.SetNew(&new_TAGI_t);
      instance.SetNewArray(&newArray_TAGI_t);
      instance.SetDelete(&delete_TAGI_t);
      instance.SetDeleteArray(&deleteArray_TAGI_t);
      instance.SetDestructor(&destruct_TAGI_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TAGI_t*)
   {
      return GenerateInitInstanceLocal((::TAGI_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TAGI_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TAGI_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TAGI_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TAGM_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TAGM_t_Dictionary();
   static void *new_TAGM_t(void *p = 0);
   static void *newArray_TAGM_t(Long_t size, void *p);
   static void delete_TAGM_t(void *p);
   static void deleteArray_TAGM_t(void *p);
   static void destruct_TAGM_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TAGM_t*)
   {
      ::TAGM_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TAGM_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TAGM_t", "./include/bankheader.h", 2613,
                  typeid(::TAGM_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TAGM_t_Dictionary, isa_proxy, 0,
                  sizeof(::TAGM_t) );
      instance.SetNew(&new_TAGM_t);
      instance.SetNewArray(&newArray_TAGM_t);
      instance.SetDelete(&delete_TAGM_t);
      instance.SetDeleteArray(&deleteArray_TAGM_t);
      instance.SetDestructor(&destruct_TAGM_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TAGM_t*)
   {
      return GenerateInitInstanceLocal((::TAGM_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TAGM_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TAGM_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TAGM_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TAGR_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TAGR_t_Dictionary();
   static void *new_TAGR_t(void *p = 0);
   static void *newArray_TAGR_t(Long_t size, void *p);
   static void delete_TAGR_t(void *p);
   static void deleteArray_TAGR_t(void *p);
   static void destruct_TAGR_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TAGR_t*)
   {
      ::TAGR_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TAGR_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TAGR_t", "./include/bankheader.h", 2621,
                  typeid(::TAGR_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TAGR_t_Dictionary, isa_proxy, 0,
                  sizeof(::TAGR_t) );
      instance.SetNew(&new_TAGR_t);
      instance.SetNewArray(&newArray_TAGR_t);
      instance.SetDelete(&delete_TAGR_t);
      instance.SetDeleteArray(&deleteArray_TAGR_t);
      instance.SetDestructor(&destruct_TAGR_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TAGR_t*)
   {
      return GenerateInitInstanceLocal((::TAGR_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TAGR_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TAGR_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TAGR_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TAGT_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TAGT_t_Dictionary();
   static void *new_TAGT_t(void *p = 0);
   static void *newArray_TAGT_t(Long_t size, void *p);
   static void delete_TAGT_t(void *p);
   static void deleteArray_TAGT_t(void *p);
   static void destruct_TAGT_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TAGT_t*)
   {
      ::TAGT_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TAGT_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TAGT_t", "./include/bankheader.h", 2626,
                  typeid(::TAGT_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TAGT_t_Dictionary, isa_proxy, 0,
                  sizeof(::TAGT_t) );
      instance.SetNew(&new_TAGT_t);
      instance.SetNewArray(&newArray_TAGT_t);
      instance.SetDelete(&delete_TAGT_t);
      instance.SetDeleteArray(&deleteArray_TAGT_t);
      instance.SetDestructor(&destruct_TAGT_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TAGT_t*)
   {
      return GenerateInitInstanceLocal((::TAGT_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TAGT_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TAGT_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TAGT_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TATL_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TATL_t_Dictionary();
   static void *new_TATL_t(void *p = 0);
   static void *newArray_TATL_t(Long_t size, void *p);
   static void delete_TATL_t(void *p);
   static void deleteArray_TATL_t(void *p);
   static void destruct_TATL_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TATL_t*)
   {
      ::TATL_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TATL_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TATL_t", "./include/bankheader.h", 2630,
                  typeid(::TATL_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TATL_t_Dictionary, isa_proxy, 0,
                  sizeof(::TATL_t) );
      instance.SetNew(&new_TATL_t);
      instance.SetNewArray(&newArray_TATL_t);
      instance.SetDelete(&delete_TATL_t);
      instance.SetDeleteArray(&deleteArray_TATL_t);
      instance.SetDestructor(&destruct_TATL_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TATL_t*)
   {
      return GenerateInitInstanceLocal((::TATL_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TATL_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TATL_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TATL_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TATR_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TATR_t_Dictionary();
   static void *new_TATR_t(void *p = 0);
   static void *newArray_TATR_t(Long_t size, void *p);
   static void delete_TATR_t(void *p);
   static void deleteArray_TATR_t(void *p);
   static void destruct_TATR_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TATR_t*)
   {
      ::TATR_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TATR_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TATR_t", "./include/bankheader.h", 2634,
                  typeid(::TATR_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TATR_t_Dictionary, isa_proxy, 0,
                  sizeof(::TATR_t) );
      instance.SetNew(&new_TATR_t);
      instance.SetNewArray(&newArray_TATR_t);
      instance.SetDelete(&delete_TATR_t);
      instance.SetDeleteArray(&deleteArray_TATR_t);
      instance.SetDestructor(&destruct_TATR_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TATR_t*)
   {
      return GenerateInitInstanceLocal((::TATR_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TATR_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TATR_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TATR_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TBER_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TBER_t_Dictionary();
   static void *new_TBER_t(void *p = 0);
   static void *newArray_TBER_t(Long_t size, void *p);
   static void delete_TBER_t(void *p);
   static void deleteArray_TBER_t(void *p);
   static void destruct_TBER_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TBER_t*)
   {
      ::TBER_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TBER_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TBER_t", "./include/bankheader.h", 2659,
                  typeid(::TBER_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TBER_t_Dictionary, isa_proxy, 0,
                  sizeof(::TBER_t) );
      instance.SetNew(&new_TBER_t);
      instance.SetNewArray(&newArray_TBER_t);
      instance.SetDelete(&delete_TBER_t);
      instance.SetDeleteArray(&deleteArray_TBER_t);
      instance.SetDestructor(&destruct_TBER_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TBER_t*)
   {
      return GenerateInitInstanceLocal((::TBER_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TBER_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TBER_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TBER_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TBID_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TBID_t_Dictionary();
   static void *new_TBID_t(void *p = 0);
   static void *newArray_TBID_t(Long_t size, void *p);
   static void delete_TBID_t(void *p);
   static void deleteArray_TBID_t(void *p);
   static void destruct_TBID_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TBID_t*)
   {
      ::TBID_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TBID_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TBID_t", "./include/bankheader.h", 2695,
                  typeid(::TBID_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TBID_t_Dictionary, isa_proxy, 0,
                  sizeof(::TBID_t) );
      instance.SetNew(&new_TBID_t);
      instance.SetNewArray(&newArray_TBID_t);
      instance.SetDelete(&delete_TBID_t);
      instance.SetDeleteArray(&deleteArray_TBID_t);
      instance.SetDestructor(&destruct_TBID_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TBID_t*)
   {
      return GenerateInitInstanceLocal((::TBID_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TBID_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TBID_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TBID_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TBLA_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TBLA_t_Dictionary();
   static void *new_TBLA_t(void *p = 0);
   static void *newArray_TBLA_t(Long_t size, void *p);
   static void delete_TBLA_t(void *p);
   static void deleteArray_TBLA_t(void *p);
   static void destruct_TBLA_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TBLA_t*)
   {
      ::TBLA_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TBLA_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TBLA_t", "./include/bankheader.h", 2714,
                  typeid(::TBLA_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TBLA_t_Dictionary, isa_proxy, 0,
                  sizeof(::TBLA_t) );
      instance.SetNew(&new_TBLA_t);
      instance.SetNewArray(&newArray_TBLA_t);
      instance.SetDelete(&delete_TBLA_t);
      instance.SetDeleteArray(&deleteArray_TBLA_t);
      instance.SetDestructor(&destruct_TBLA_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TBLA_t*)
   {
      return GenerateInitInstanceLocal((::TBLA_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TBLA_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TBLA_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TBLA_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TBTR_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TBTR_t_Dictionary();
   static void *new_TBTR_t(void *p = 0);
   static void *newArray_TBTR_t(Long_t size, void *p);
   static void delete_TBTR_t(void *p);
   static void deleteArray_TBTR_t(void *p);
   static void destruct_TBTR_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TBTR_t*)
   {
      ::TBTR_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TBTR_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TBTR_t", "./include/bankheader.h", 2726,
                  typeid(::TBTR_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TBTR_t_Dictionary, isa_proxy, 0,
                  sizeof(::TBTR_t) );
      instance.SetNew(&new_TBTR_t);
      instance.SetNewArray(&newArray_TBTR_t);
      instance.SetDelete(&delete_TBTR_t);
      instance.SetDeleteArray(&deleteArray_TBTR_t);
      instance.SetDestructor(&destruct_TBTR_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TBTR_t*)
   {
      return GenerateInitInstanceLocal((::TBTR_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TBTR_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TBTR_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TBTR_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TCSB_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TCSB_t_Dictionary();
   static void *new_TCSB_t(void *p = 0);
   static void *newArray_TCSB_t(Long_t size, void *p);
   static void delete_TCSB_t(void *p);
   static void deleteArray_TCSB_t(void *p);
   static void destruct_TCSB_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TCSB_t*)
   {
      ::TCSB_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TCSB_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TCSB_t", "./include/bankheader.h", 2734,
                  typeid(::TCSB_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TCSB_t_Dictionary, isa_proxy, 0,
                  sizeof(::TCSB_t) );
      instance.SetNew(&new_TCSB_t);
      instance.SetNewArray(&newArray_TCSB_t);
      instance.SetDelete(&delete_TCSB_t);
      instance.SetDeleteArray(&deleteArray_TCSB_t);
      instance.SetDestructor(&destruct_TCSB_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TCSB_t*)
   {
      return GenerateInitInstanceLocal((::TCSB_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TCSB_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TCSB_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TCSB_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TCT_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TCT_t_Dictionary();
   static void *new_TCT_t(void *p = 0);
   static void *newArray_TCT_t(Long_t size, void *p);
   static void delete_TCT_t(void *p);
   static void deleteArray_TCT_t(void *p);
   static void destruct_TCT_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TCT_t*)
   {
      ::TCT_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TCT_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TCT_t", "./include/bankheader.h", 2738,
                  typeid(::TCT_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TCT_t_Dictionary, isa_proxy, 0,
                  sizeof(::TCT_t) );
      instance.SetNew(&new_TCT_t);
      instance.SetNewArray(&newArray_TCT_t);
      instance.SetDelete(&delete_TCT_t);
      instance.SetDeleteArray(&deleteArray_TCT_t);
      instance.SetDestructor(&destruct_TCT_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TCT_t*)
   {
      return GenerateInitInstanceLocal((::TCT_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TCT_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TCT_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TCT_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TDPL_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TDPL_t_Dictionary();
   static void *new_TDPL_t(void *p = 0);
   static void *newArray_TDPL_t(Long_t size, void *p);
   static void delete_TDPL_t(void *p);
   static void deleteArray_TDPL_t(void *p);
   static void destruct_TDPL_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TDPL_t*)
   {
      ::TDPL_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TDPL_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TDPL_t", "./include/bankheader.h", 2748,
                  typeid(::TDPL_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TDPL_t_Dictionary, isa_proxy, 0,
                  sizeof(::TDPL_t) );
      instance.SetNew(&new_TDPL_t);
      instance.SetNewArray(&newArray_TDPL_t);
      instance.SetDelete(&delete_TDPL_t);
      instance.SetDeleteArray(&deleteArray_TDPL_t);
      instance.SetDestructor(&destruct_TDPL_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TDPL_t*)
   {
      return GenerateInitInstanceLocal((::TDPL_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TDPL_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TDPL_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TDPL_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TESC_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TESC_t_Dictionary();
   static void *new_TESC_t(void *p = 0);
   static void *newArray_TESC_t(Long_t size, void *p);
   static void delete_TESC_t(void *p);
   static void deleteArray_TESC_t(void *p);
   static void destruct_TESC_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TESC_t*)
   {
      ::TESC_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TESC_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TESC_t", "./include/bankheader.h", 2751,
                  typeid(::TESC_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TESC_t_Dictionary, isa_proxy, 0,
                  sizeof(::TESC_t) );
      instance.SetNew(&new_TESC_t);
      instance.SetNewArray(&newArray_TESC_t);
      instance.SetDelete(&delete_TESC_t);
      instance.SetDeleteArray(&deleteArray_TESC_t);
      instance.SetDestructor(&destruct_TESC_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TESC_t*)
   {
      return GenerateInitInstanceLocal((::TESC_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TESC_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TESC_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TESC_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TGBI_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TGBI_t_Dictionary();
   static void *new_TGBI_t(void *p = 0);
   static void *newArray_TGBI_t(Long_t size, void *p);
   static void delete_TGBI_t(void *p);
   static void deleteArray_TGBI_t(void *p);
   static void destruct_TGBI_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TGBI_t*)
   {
      ::TGBI_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TGBI_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TGBI_t", "./include/bankheader.h", 2758,
                  typeid(::TGBI_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TGBI_t_Dictionary, isa_proxy, 0,
                  sizeof(::TGBI_t) );
      instance.SetNew(&new_TGBI_t);
      instance.SetNewArray(&newArray_TGBI_t);
      instance.SetDelete(&delete_TGBI_t);
      instance.SetDeleteArray(&deleteArray_TGBI_t);
      instance.SetDestructor(&destruct_TGBI_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TGBI_t*)
   {
      return GenerateInitInstanceLocal((::TGBI_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TGBI_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TGBI_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TGBI_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TGEO_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TGEO_t_Dictionary();
   static void *new_TGEO_t(void *p = 0);
   static void *newArray_TGEO_t(Long_t size, void *p);
   static void delete_TGEO_t(void *p);
   static void deleteArray_TGEO_t(void *p);
   static void destruct_TGEO_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TGEO_t*)
   {
      ::TGEO_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TGEO_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TGEO_t", "./include/bankheader.h", 2766,
                  typeid(::TGEO_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TGEO_t_Dictionary, isa_proxy, 0,
                  sizeof(::TGEO_t) );
      instance.SetNew(&new_TGEO_t);
      instance.SetNewArray(&newArray_TGEO_t);
      instance.SetDelete(&delete_TGEO_t);
      instance.SetDeleteArray(&deleteArray_TGEO_t);
      instance.SetDestructor(&destruct_TGEO_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TGEO_t*)
   {
      return GenerateInitInstanceLocal((::TGEO_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TGEO_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TGEO_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TGEO_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TGPB_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TGPB_t_Dictionary();
   static void *new_TGPB_t(void *p = 0);
   static void *newArray_TGPB_t(Long_t size, void *p);
   static void delete_TGPB_t(void *p);
   static void deleteArray_TGPB_t(void *p);
   static void destruct_TGPB_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TGPB_t*)
   {
      ::TGPB_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TGPB_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TGPB_t", "./include/bankheader.h", 2772,
                  typeid(::TGPB_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TGPB_t_Dictionary, isa_proxy, 0,
                  sizeof(::TGPB_t) );
      instance.SetNew(&new_TGPB_t);
      instance.SetNewArray(&newArray_TGPB_t);
      instance.SetDelete(&delete_TGPB_t);
      instance.SetDeleteArray(&deleteArray_TGPB_t);
      instance.SetDestructor(&destruct_TGPB_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TGPB_t*)
   {
      return GenerateInitInstanceLocal((::TGPB_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TGPB_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TGPB_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TGPB_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TGS_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TGS_t_Dictionary();
   static void *new_TGS_t(void *p = 0);
   static void *newArray_TGS_t(Long_t size, void *p);
   static void delete_TGS_t(void *p);
   static void deleteArray_TGS_t(void *p);
   static void destruct_TGS_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TGS_t*)
   {
      ::TGS_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TGS_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TGS_t", "./include/bankheader.h", 2966,
                  typeid(::TGS_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TGS_t_Dictionary, isa_proxy, 0,
                  sizeof(::TGS_t) );
      instance.SetNew(&new_TGS_t);
      instance.SetNewArray(&newArray_TGS_t);
      instance.SetDelete(&delete_TGS_t);
      instance.SetDeleteArray(&deleteArray_TGS_t);
      instance.SetDestructor(&destruct_TGS_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TGS_t*)
   {
      return GenerateInitInstanceLocal((::TGS_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TGS_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TGS_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TGS_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TGTL_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TGTL_t_Dictionary();
   static void *new_TGTL_t(void *p = 0);
   static void *newArray_TGTL_t(Long_t size, void *p);
   static void delete_TGTL_t(void *p);
   static void deleteArray_TGTL_t(void *p);
   static void destruct_TGTL_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TGTL_t*)
   {
      ::TGTL_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TGTL_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TGTL_t", "./include/bankheader.h", 2970,
                  typeid(::TGTL_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TGTL_t_Dictionary, isa_proxy, 0,
                  sizeof(::TGTL_t) );
      instance.SetNew(&new_TGTL_t);
      instance.SetNewArray(&newArray_TGTL_t);
      instance.SetDelete(&delete_TGTL_t);
      instance.SetDeleteArray(&deleteArray_TGTL_t);
      instance.SetDestructor(&destruct_TGTL_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TGTL_t*)
   {
      return GenerateInitInstanceLocal((::TGTL_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TGTL_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TGTL_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TGTL_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TGTR_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TGTR_t_Dictionary();
   static void *new_TGTR_t(void *p = 0);
   static void *newArray_TGTR_t(Long_t size, void *p);
   static void delete_TGTR_t(void *p);
   static void deleteArray_TGTR_t(void *p);
   static void destruct_TGTR_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TGTR_t*)
   {
      ::TGTR_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TGTR_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TGTR_t", "./include/bankheader.h", 2974,
                  typeid(::TGTR_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TGTR_t_Dictionary, isa_proxy, 0,
                  sizeof(::TGTR_t) );
      instance.SetNew(&new_TGTR_t);
      instance.SetNewArray(&newArray_TGTR_t);
      instance.SetDelete(&delete_TGTR_t);
      instance.SetDeleteArray(&deleteArray_TGTR_t);
      instance.SetDestructor(&destruct_TGTR_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TGTR_t*)
   {
      return GenerateInitInstanceLocal((::TGTR_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TGTR_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TGTR_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TGTR_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TLV1_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TLV1_t_Dictionary();
   static void *new_TLV1_t(void *p = 0);
   static void *newArray_TLV1_t(Long_t size, void *p);
   static void delete_TLV1_t(void *p);
   static void deleteArray_TLV1_t(void *p);
   static void destruct_TLV1_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TLV1_t*)
   {
      ::TLV1_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TLV1_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TLV1_t", "./include/bankheader.h", 2978,
                  typeid(::TLV1_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TLV1_t_Dictionary, isa_proxy, 0,
                  sizeof(::TLV1_t) );
      instance.SetNew(&new_TLV1_t);
      instance.SetNewArray(&newArray_TLV1_t);
      instance.SetDelete(&delete_TLV1_t);
      instance.SetDeleteArray(&deleteArray_TLV1_t);
      instance.SetDestructor(&destruct_TLV1_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TLV1_t*)
   {
      return GenerateInitInstanceLocal((::TLV1_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TLV1_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TLV1_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TLV1_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TRCF_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TRCF_t_Dictionary();
   static void *new_TRCF_t(void *p = 0);
   static void *newArray_TRCF_t(Long_t size, void *p);
   static void delete_TRCF_t(void *p);
   static void deleteArray_TRCF_t(void *p);
   static void destruct_TRCF_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TRCF_t*)
   {
      ::TRCF_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TRCF_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TRCF_t", "./include/bankheader.h", 2981,
                  typeid(::TRCF_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TRCF_t_Dictionary, isa_proxy, 0,
                  sizeof(::TRCF_t) );
      instance.SetNew(&new_TRCF_t);
      instance.SetNewArray(&newArray_TRCF_t);
      instance.SetDelete(&delete_TRCF_t);
      instance.SetDeleteArray(&deleteArray_TRCF_t);
      instance.SetDestructor(&destruct_TRCF_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TRCF_t*)
   {
      return GenerateInitInstanceLocal((::TRCF_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TRCF_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TRCF_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TRCF_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TRGS_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TRGS_t_Dictionary();
   static void *new_TRGS_t(void *p = 0);
   static void *newArray_TRGS_t(Long_t size, void *p);
   static void delete_TRGS_t(void *p);
   static void deleteArray_TRGS_t(void *p);
   static void destruct_TRGS_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TRGS_t*)
   {
      ::TRGS_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TRGS_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TRGS_t", "./include/bankheader.h", 3079,
                  typeid(::TRGS_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TRGS_t_Dictionary, isa_proxy, 0,
                  sizeof(::TRGS_t) );
      instance.SetNew(&new_TRGS_t);
      instance.SetNewArray(&newArray_TRGS_t);
      instance.SetDelete(&delete_TRGS_t);
      instance.SetDeleteArray(&deleteArray_TRGS_t);
      instance.SetDestructor(&destruct_TRGS_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TRGS_t*)
   {
      return GenerateInitInstanceLocal((::TRGS_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TRGS_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TRGS_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TRGS_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TRKS_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TRKS_t_Dictionary();
   static void *new_TRKS_t(void *p = 0);
   static void *newArray_TRKS_t(Long_t size, void *p);
   static void delete_TRKS_t(void *p);
   static void deleteArray_TRKS_t(void *p);
   static void destruct_TRKS_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TRKS_t*)
   {
      ::TRKS_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TRKS_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TRKS_t", "./include/bankheader.h", 3091,
                  typeid(::TRKS_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TRKS_t_Dictionary, isa_proxy, 0,
                  sizeof(::TRKS_t) );
      instance.SetNew(&new_TRKS_t);
      instance.SetNewArray(&newArray_TRKS_t);
      instance.SetDelete(&delete_TRKS_t);
      instance.SetDeleteArray(&deleteArray_TRKS_t);
      instance.SetDestructor(&destruct_TRKS_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TRKS_t*)
   {
      return GenerateInitInstanceLocal((::TRKS_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TRKS_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TRKS_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TRKS_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TRL1_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TRL1_t_Dictionary();
   static void *new_TRL1_t(void *p = 0);
   static void *newArray_TRL1_t(Long_t size, void *p);
   static void delete_TRL1_t(void *p);
   static void deleteArray_TRL1_t(void *p);
   static void destruct_TRL1_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TRL1_t*)
   {
      ::TRL1_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TRL1_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TRL1_t", "./include/bankheader.h", 3103,
                  typeid(::TRL1_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TRL1_t_Dictionary, isa_proxy, 0,
                  sizeof(::TRL1_t) );
      instance.SetNew(&new_TRL1_t);
      instance.SetNewArray(&newArray_TRL1_t);
      instance.SetDelete(&delete_TRL1_t);
      instance.SetDeleteArray(&deleteArray_TRL1_t);
      instance.SetDestructor(&destruct_TRL1_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TRL1_t*)
   {
      return GenerateInitInstanceLocal((::TRL1_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TRL1_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TRL1_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TRL1_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TRPB_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TRPB_t_Dictionary();
   static void *new_TRPB_t(void *p = 0);
   static void *newArray_TRPB_t(Long_t size, void *p);
   static void delete_TRPB_t(void *p);
   static void deleteArray_TRPB_t(void *p);
   static void destruct_TRPB_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TRPB_t*)
   {
      ::TRPB_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TRPB_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TRPB_t", "./include/bankheader.h", 3113,
                  typeid(::TRPB_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TRPB_t_Dictionary, isa_proxy, 0,
                  sizeof(::TRPB_t) );
      instance.SetNew(&new_TRPB_t);
      instance.SetNewArray(&newArray_TRPB_t);
      instance.SetDelete(&delete_TRPB_t);
      instance.SetDeleteArray(&deleteArray_TRPB_t);
      instance.SetDestructor(&destruct_TRPB_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TRPB_t*)
   {
      return GenerateInitInstanceLocal((::TRPB_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TRPB_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TRPB_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TRPB_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TSPR_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TSPR_t_Dictionary();
   static void *new_TSPR_t(void *p = 0);
   static void *newArray_TSPR_t(Long_t size, void *p);
   static void delete_TSPR_t(void *p);
   static void deleteArray_TSPR_t(void *p);
   static void destruct_TSPR_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TSPR_t*)
   {
      ::TSPR_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TSPR_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TSPR_t", "./include/bankheader.h", 3116,
                  typeid(::TSPR_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TSPR_t_Dictionary, isa_proxy, 0,
                  sizeof(::TSPR_t) );
      instance.SetNew(&new_TSPR_t);
      instance.SetNewArray(&newArray_TSPR_t);
      instance.SetDelete(&delete_TSPR_t);
      instance.SetDeleteArray(&deleteArray_TSPR_t);
      instance.SetDestructor(&destruct_TSPR_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TSPR_t*)
   {
      return GenerateInitInstanceLocal((::TSPR_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TSPR_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TSPR_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TSPR_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void TSRG_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TSRG_t_Dictionary();
   static void *new_TSRG_t(void *p = 0);
   static void *newArray_TSRG_t(Long_t size, void *p);
   static void delete_TSRG_t(void *p);
   static void deleteArray_TSRG_t(void *p);
   static void destruct_TSRG_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::TSRG_t*)
   {
      ::TSRG_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TSRG_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("TSRG_t", "./include/bankheader.h", 3119,
                  typeid(::TSRG_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &TSRG_t_Dictionary, isa_proxy, 0,
                  sizeof(::TSRG_t) );
      instance.SetNew(&new_TSRG_t);
      instance.SetNewArray(&newArray_TSRG_t);
      instance.SetDelete(&delete_TSRG_t);
      instance.SetDeleteArray(&deleteArray_TSRG_t);
      instance.SetDestructor(&destruct_TSRG_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::TSRG_t*)
   {
      return GenerateInitInstanceLocal((::TSRG_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TSRG_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TSRG_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::TSRG_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void UNUS_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void UNUS_t_Dictionary();
   static void *new_UNUS_t(void *p = 0);
   static void *newArray_UNUS_t(Long_t size, void *p);
   static void delete_UNUS_t(void *p);
   static void deleteArray_UNUS_t(void *p);
   static void destruct_UNUS_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::UNUS_t*)
   {
      ::UNUS_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::UNUS_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("UNUS_t", "./include/bankheader.h", 3129,
                  typeid(::UNUS_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &UNUS_t_Dictionary, isa_proxy, 0,
                  sizeof(::UNUS_t) );
      instance.SetNew(&new_UNUS_t);
      instance.SetNewArray(&newArray_UNUS_t);
      instance.SetDelete(&delete_UNUS_t);
      instance.SetDeleteArray(&deleteArray_UNUS_t);
      instance.SetDestructor(&destruct_UNUS_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::UNUS_t*)
   {
      return GenerateInitInstanceLocal((::UNUS_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::UNUS_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void UNUS_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::UNUS_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void VERT_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void VERT_t_Dictionary();
   static void *new_VERT_t(void *p = 0);
   static void *newArray_VERT_t(Long_t size, void *p);
   static void delete_VERT_t(void *p);
   static void deleteArray_VERT_t(void *p);
   static void destruct_VERT_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::VERT_t*)
   {
      ::VERT_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::VERT_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("VERT_t", "./include/bankheader.h", 3138,
                  typeid(::VERT_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &VERT_t_Dictionary, isa_proxy, 0,
                  sizeof(::VERT_t) );
      instance.SetNew(&new_VERT_t);
      instance.SetNewArray(&newArray_VERT_t);
      instance.SetDelete(&delete_VERT_t);
      instance.SetDeleteArray(&deleteArray_VERT_t);
      instance.SetDestructor(&destruct_VERT_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::VERT_t*)
   {
      return GenerateInitInstanceLocal((::VERT_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::VERT_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void VERT_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::VERT_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void RC26_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void RC26_t_Dictionary();
   static void *new_RC26_t(void *p = 0);
   static void *newArray_RC26_t(Long_t size, void *p);
   static void delete_RC26_t(void *p);
   static void deleteArray_RC26_t(void *p);
   static void destruct_RC26_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::RC26_t*)
   {
      ::RC26_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RC26_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("RC26_t", "./include/bankheader.h", 3143,
                  typeid(::RC26_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &RC26_t_Dictionary, isa_proxy, 0,
                  sizeof(::RC26_t) );
      instance.SetNew(&new_RC26_t);
      instance.SetNewArray(&newArray_RC26_t);
      instance.SetDelete(&delete_RC26_t);
      instance.SetDeleteArray(&deleteArray_RC26_t);
      instance.SetDestructor(&destruct_RC26_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::RC26_t*)
   {
      return GenerateInitInstanceLocal((::RC26_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::RC26_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void RC26_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::RC26_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void STRE_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void STRE_t_Dictionary();
   static void *new_STRE_t(void *p = 0);
   static void *newArray_STRE_t(Long_t size, void *p);
   static void delete_STRE_t(void *p);
   static void deleteArray_STRE_t(void *p);
   static void destruct_STRE_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::STRE_t*)
   {
      ::STRE_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::STRE_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("STRE_t", "./include/bankheader.h", 3153,
                  typeid(::STRE_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &STRE_t_Dictionary, isa_proxy, 0,
                  sizeof(::STRE_t) );
      instance.SetNew(&new_STRE_t);
      instance.SetNewArray(&newArray_STRE_t);
      instance.SetDelete(&delete_STRE_t);
      instance.SetDeleteArray(&deleteArray_STRE_t);
      instance.SetDestructor(&destruct_STRE_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::STRE_t*)
   {
      return GenerateInitInstanceLocal((::STRE_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::STRE_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void STRE_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::STRE_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void addressBanks_t_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void addressBanks_t_Dictionary();
   static void *new_addressBanks_t(void *p = 0);
   static void *newArray_addressBanks_t(Long_t size, void *p);
   static void delete_addressBanks_t(void *p);
   static void deleteArray_addressBanks_t(void *p);
   static void destruct_addressBanks_t(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::addressBanks_t*)
   {
      ::addressBanks_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::addressBanks_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("addressBanks_t", "./include/RootBeerTypes.h", 38,
                  typeid(::addressBanks_t), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &addressBanks_t_Dictionary, isa_proxy, 0,
                  sizeof(::addressBanks_t) );
      instance.SetNew(&new_addressBanks_t);
      instance.SetNewArray(&newArray_addressBanks_t);
      instance.SetDelete(&delete_addressBanks_t);
      instance.SetDeleteArray(&deleteArray_addressBanks_t);
      instance.SetDestructor(&destruct_addressBanks_t);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::addressBanks_t*)
   {
      return GenerateInitInstanceLocal((::addressBanks_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::addressBanks_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void addressBanks_t_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::addressBanks_t*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_BEAM_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::BEAM_t : new ::BEAM_t;
   }
   static void *newArray_BEAM_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::BEAM_t[nElements] : new ::BEAM_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_BEAM_t(void *p) {
      delete ((::BEAM_t*)p);
   }
   static void deleteArray_BEAM_t(void *p) {
      delete [] ((::BEAM_t*)p);
   }
   static void destruct_BEAM_t(void *p) {
      typedef ::BEAM_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::BEAM_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_BMPR_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::BMPR_t : new ::BMPR_t;
   }
   static void *newArray_BMPR_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::BMPR_t[nElements] : new ::BMPR_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_BMPR_t(void *p) {
      delete ((::BMPR_t*)p);
   }
   static void deleteArray_BMPR_t(void *p) {
      delete [] ((::BMPR_t*)p);
   }
   static void destruct_BMPR_t(void *p) {
      typedef ::BMPR_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::BMPR_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_BREP_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::BREP_t : new ::BREP_t;
   }
   static void *newArray_BREP_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::BREP_t[nElements] : new ::BREP_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_BREP_t(void *p) {
      delete ((::BREP_t*)p);
   }
   static void deleteArray_BREP_t(void *p) {
      delete [] ((::BREP_t*)p);
   }
   static void destruct_BREP_t(void *p) {
      typedef ::BREP_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::BREP_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CALB_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CALB_t : new ::CALB_t;
   }
   static void *newArray_CALB_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CALB_t[nElements] : new ::CALB_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CALB_t(void *p) {
      delete ((::CALB_t*)p);
   }
   static void deleteArray_CALB_t(void *p) {
      delete [] ((::CALB_t*)p);
   }
   static void destruct_CALB_t(void *p) {
      typedef ::CALB_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CALB_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CALL_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CALL_t : new ::CALL_t;
   }
   static void *newArray_CALL_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CALL_t[nElements] : new ::CALL_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CALL_t(void *p) {
      delete ((::CALL_t*)p);
   }
   static void deleteArray_CALL_t(void *p) {
      delete [] ((::CALL_t*)p);
   }
   static void destruct_CALL_t(void *p) {
      typedef ::CALL_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CALL_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CC01_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CC01_t : new ::CC01_t;
   }
   static void *newArray_CC01_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CC01_t[nElements] : new ::CC01_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CC01_t(void *p) {
      delete ((::CC01_t*)p);
   }
   static void deleteArray_CC01_t(void *p) {
      delete [] ((::CC01_t*)p);
   }
   static void destruct_CC01_t(void *p) {
      typedef ::CC01_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CC01_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CC1_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CC1_t : new ::CC1_t;
   }
   static void *newArray_CC1_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CC1_t[nElements] : new ::CC1_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CC1_t(void *p) {
      delete ((::CC1_t*)p);
   }
   static void deleteArray_CC1_t(void *p) {
      delete [] ((::CC1_t*)p);
   }
   static void destruct_CC1_t(void *p) {
      typedef ::CC1_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CC1_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CC_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CC_t : new ::CC_t;
   }
   static void *newArray_CC_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CC_t[nElements] : new ::CC_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CC_t(void *p) {
      delete ((::CC_t*)p);
   }
   static void deleteArray_CC_t(void *p) {
      delete [] ((::CC_t*)p);
   }
   static void destruct_CC_t(void *p) {
      typedef ::CC_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CC_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CCDI_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CCDI_t : new ::CCDI_t;
   }
   static void *newArray_CCDI_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CCDI_t[nElements] : new ::CCDI_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CCDI_t(void *p) {
      delete ((::CCDI_t*)p);
   }
   static void deleteArray_CCDI_t(void *p) {
      delete [] ((::CCDI_t*)p);
   }
   static void destruct_CCDI_t(void *p) {
      typedef ::CCDI_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CCDI_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CCH_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CCH_t : new ::CCH_t;
   }
   static void *newArray_CCH_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CCH_t[nElements] : new ::CCH_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CCH_t(void *p) {
      delete ((::CCH_t*)p);
   }
   static void deleteArray_CCH_t(void *p) {
      delete [] ((::CCH_t*)p);
   }
   static void destruct_CCH_t(void *p) {
      typedef ::CCH_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CCH_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CCMT_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CCMT_t : new ::CCMT_t;
   }
   static void *newArray_CCMT_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CCMT_t[nElements] : new ::CCMT_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CCMT_t(void *p) {
      delete ((::CCMT_t*)p);
   }
   static void deleteArray_CCMT_t(void *p) {
      delete [] ((::CCMT_t*)p);
   }
   static void destruct_CCMT_t(void *p) {
      typedef ::CCMT_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CCMT_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CCPB_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CCPB_t : new ::CCPB_t;
   }
   static void *newArray_CCPB_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CCPB_t[nElements] : new ::CCPB_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CCPB_t(void *p) {
      delete ((::CCPB_t*)p);
   }
   static void deleteArray_CCPB_t(void *p) {
      delete [] ((::CCPB_t*)p);
   }
   static void destruct_CCPB_t(void *p) {
      typedef ::CCPB_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CCPB_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CCPE_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CCPE_t : new ::CCPE_t;
   }
   static void *newArray_CCPE_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CCPE_t[nElements] : new ::CCPE_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CCPE_t(void *p) {
      delete ((::CCPE_t*)p);
   }
   static void deleteArray_CCPE_t(void *p) {
      delete [] ((::CCPE_t*)p);
   }
   static void destruct_CCPE_t(void *p) {
      typedef ::CCPE_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CCPE_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CCRC_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CCRC_t : new ::CCRC_t;
   }
   static void *newArray_CCRC_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CCRC_t[nElements] : new ::CCRC_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CCRC_t(void *p) {
      delete ((::CCRC_t*)p);
   }
   static void deleteArray_CCRC_t(void *p) {
      delete [] ((::CCRC_t*)p);
   }
   static void destruct_CCRC_t(void *p) {
      typedef ::CCRC_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CCRC_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CCS_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CCS_t : new ::CCS_t;
   }
   static void *newArray_CCS_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CCS_t[nElements] : new ::CCS_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CCS_t(void *p) {
      delete ((::CCS_t*)p);
   }
   static void deleteArray_CCS_t(void *p) {
      delete [] ((::CCS_t*)p);
   }
   static void destruct_CCS_t(void *p) {
      typedef ::CCS_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CCS_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CCT_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CCT_t : new ::CCT_t;
   }
   static void *newArray_CCT_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CCT_t[nElements] : new ::CCT_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CCT_t(void *p) {
      delete ((::CCT_t*)p);
   }
   static void deleteArray_CCT_t(void *p) {
      delete [] ((::CCT_t*)p);
   }
   static void destruct_CCT_t(void *p) {
      typedef ::CCT_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CCT_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CHI2_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CHI2_t : new ::CHI2_t;
   }
   static void *newArray_CHI2_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CHI2_t[nElements] : new ::CHI2_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CHI2_t(void *p) {
      delete ((::CHI2_t*)p);
   }
   static void deleteArray_CHI2_t(void *p) {
      delete [] ((::CHI2_t*)p);
   }
   static void destruct_CHI2_t(void *p) {
      typedef ::CHI2_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CHI2_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CL01_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CL01_t : new ::CL01_t;
   }
   static void *newArray_CL01_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CL01_t[nElements] : new ::CL01_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CL01_t(void *p) {
      delete ((::CL01_t*)p);
   }
   static void deleteArray_CL01_t(void *p) {
      delete [] ((::CL01_t*)p);
   }
   static void destruct_CL01_t(void *p) {
      typedef ::CL01_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CL01_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CLST_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CLST_t : new ::CLST_t;
   }
   static void *newArray_CLST_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CLST_t[nElements] : new ::CLST_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CLST_t(void *p) {
      delete ((::CLST_t*)p);
   }
   static void deleteArray_CLST_t(void *p) {
      delete [] ((::CLST_t*)p);
   }
   static void destruct_CLST_t(void *p) {
      typedef ::CLST_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CLST_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CPED_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CPED_t : new ::CPED_t;
   }
   static void *newArray_CPED_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CPED_t[nElements] : new ::CPED_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CPED_t(void *p) {
      delete ((::CPED_t*)p);
   }
   static void deleteArray_CPED_t(void *p) {
      delete [] ((::CPED_t*)p);
   }
   static void destruct_CPED_t(void *p) {
      typedef ::CPED_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CPED_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_CSQL_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CSQL_t : new ::CSQL_t;
   }
   static void *newArray_CSQL_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::CSQL_t[nElements] : new ::CSQL_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CSQL_t(void *p) {
      delete ((::CSQL_t*)p);
   }
   static void deleteArray_CSQL_t(void *p) {
      delete [] ((::CSQL_t*)p);
   }
   static void destruct_CSQL_t(void *p) {
      typedef ::CSQL_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::CSQL_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DC0_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DC0_t : new ::DC0_t;
   }
   static void *newArray_DC0_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DC0_t[nElements] : new ::DC0_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DC0_t(void *p) {
      delete ((::DC0_t*)p);
   }
   static void deleteArray_DC0_t(void *p) {
      delete [] ((::DC0_t*)p);
   }
   static void destruct_DC0_t(void *p) {
      typedef ::DC0_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DC0_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DC1_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DC1_t : new ::DC1_t;
   }
   static void *newArray_DC1_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DC1_t[nElements] : new ::DC1_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DC1_t(void *p) {
      delete ((::DC1_t*)p);
   }
   static void deleteArray_DC1_t(void *p) {
      delete [] ((::DC1_t*)p);
   }
   static void destruct_DC1_t(void *p) {
      typedef ::DC1_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DC1_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DCDW_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCDW_t : new ::DCDW_t;
   }
   static void *newArray_DCDW_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCDW_t[nElements] : new ::DCDW_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DCDW_t(void *p) {
      delete ((::DCDW_t*)p);
   }
   static void deleteArray_DCDW_t(void *p) {
      delete [] ((::DCDW_t*)p);
   }
   static void destruct_DCDW_t(void *p) {
      typedef ::DCDW_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DCDW_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DCGM_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCGM_t : new ::DCGM_t;
   }
   static void *newArray_DCGM_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCGM_t[nElements] : new ::DCGM_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DCGM_t(void *p) {
      delete ((::DCGM_t*)p);
   }
   static void deleteArray_DCGM_t(void *p) {
      delete [] ((::DCGM_t*)p);
   }
   static void destruct_DCGM_t(void *p) {
      typedef ::DCGM_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DCGM_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DCGW_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCGW_t : new ::DCGW_t;
   }
   static void *newArray_DCGW_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCGW_t[nElements] : new ::DCGW_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DCGW_t(void *p) {
      delete ((::DCGW_t*)p);
   }
   static void deleteArray_DCGW_t(void *p) {
      delete [] ((::DCGW_t*)p);
   }
   static void destruct_DCGW_t(void *p) {
      typedef ::DCGW_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DCGW_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DCH_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCH_t : new ::DCH_t;
   }
   static void *newArray_DCH_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCH_t[nElements] : new ::DCH_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DCH_t(void *p) {
      delete ((::DCH_t*)p);
   }
   static void deleteArray_DCH_t(void *p) {
      delete [] ((::DCH_t*)p);
   }
   static void destruct_DCH_t(void *p) {
      typedef ::DCH_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DCH_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DCMN_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCMN_t : new ::DCMN_t;
   }
   static void *newArray_DCMN_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCMN_t[nElements] : new ::DCMN_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DCMN_t(void *p) {
      delete ((::DCMN_t*)p);
   }
   static void deleteArray_DCMN_t(void *p) {
      delete [] ((::DCMN_t*)p);
   }
   static void destruct_DCMN_t(void *p) {
      typedef ::DCMN_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DCMN_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DCPB_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCPB_t : new ::DCPB_t;
   }
   static void *newArray_DCPB_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCPB_t[nElements] : new ::DCPB_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DCPB_t(void *p) {
      delete ((::DCPB_t*)p);
   }
   static void deleteArray_DCPB_t(void *p) {
      delete [] ((::DCPB_t*)p);
   }
   static void destruct_DCPB_t(void *p) {
      typedef ::DCPB_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DCPB_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DCV1_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCV1_t : new ::DCV1_t;
   }
   static void *newArray_DCV1_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCV1_t[nElements] : new ::DCV1_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DCV1_t(void *p) {
      delete ((::DCV1_t*)p);
   }
   static void deleteArray_DCV1_t(void *p) {
      delete [] ((::DCV1_t*)p);
   }
   static void destruct_DCV1_t(void *p) {
      typedef ::DCV1_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DCV1_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DCV2_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCV2_t : new ::DCV2_t;
   }
   static void *newArray_DCV2_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCV2_t[nElements] : new ::DCV2_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DCV2_t(void *p) {
      delete ((::DCV2_t*)p);
   }
   static void deleteArray_DCV2_t(void *p) {
      delete [] ((::DCV2_t*)p);
   }
   static void destruct_DCV2_t(void *p) {
      typedef ::DCV2_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DCV2_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DCV3_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCV3_t : new ::DCV3_t;
   }
   static void *newArray_DCV3_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DCV3_t[nElements] : new ::DCV3_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DCV3_t(void *p) {
      delete ((::DCV3_t*)p);
   }
   static void deleteArray_DCV3_t(void *p) {
      delete [] ((::DCV3_t*)p);
   }
   static void destruct_DCV3_t(void *p) {
      typedef ::DCV3_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DCV3_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DDLY_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DDLY_t : new ::DDLY_t;
   }
   static void *newArray_DDLY_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DDLY_t[nElements] : new ::DDLY_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DDLY_t(void *p) {
      delete ((::DDLY_t*)p);
   }
   static void deleteArray_DDLY_t(void *p) {
      delete [] ((::DDLY_t*)p);
   }
   static void destruct_DDLY_t(void *p) {
      typedef ::DDLY_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DDLY_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DGEO_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DGEO_t : new ::DGEO_t;
   }
   static void *newArray_DGEO_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DGEO_t[nElements] : new ::DGEO_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DGEO_t(void *p) {
      delete ((::DGEO_t*)p);
   }
   static void deleteArray_DGEO_t(void *p) {
      delete [] ((::DGEO_t*)p);
   }
   static void destruct_DGEO_t(void *p) {
      typedef ::DGEO_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DGEO_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DHCL_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DHCL_t : new ::DHCL_t;
   }
   static void *newArray_DHCL_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DHCL_t[nElements] : new ::DHCL_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DHCL_t(void *p) {
      delete ((::DHCL_t*)p);
   }
   static void deleteArray_DHCL_t(void *p) {
      delete [] ((::DHCL_t*)p);
   }
   static void destruct_DHCL_t(void *p) {
      typedef ::DHCL_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DHCL_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DITM_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DITM_t : new ::DITM_t;
   }
   static void *newArray_DITM_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DITM_t[nElements] : new ::DITM_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DITM_t(void *p) {
      delete ((::DITM_t*)p);
   }
   static void deleteArray_DITM_t(void *p) {
      delete [] ((::DITM_t*)p);
   }
   static void destruct_DITM_t(void *p) {
      typedef ::DITM_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DITM_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DOCA_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DOCA_t : new ::DOCA_t;
   }
   static void *newArray_DOCA_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DOCA_t[nElements] : new ::DOCA_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DOCA_t(void *p) {
      delete ((::DOCA_t*)p);
   }
   static void deleteArray_DOCA_t(void *p) {
      delete [] ((::DOCA_t*)p);
   }
   static void destruct_DOCA_t(void *p) {
      typedef ::DOCA_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DOCA_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DPCP_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DPCP_t : new ::DPCP_t;
   }
   static void *newArray_DPCP_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DPCP_t[nElements] : new ::DPCP_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DPCP_t(void *p) {
      delete ((::DPCP_t*)p);
   }
   static void deleteArray_DPCP_t(void *p) {
      delete [] ((::DPCP_t*)p);
   }
   static void destruct_DPCP_t(void *p) {
      typedef ::DPCP_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DPCP_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DPSP_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DPSP_t : new ::DPSP_t;
   }
   static void *newArray_DPSP_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DPSP_t[nElements] : new ::DPSP_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DPSP_t(void *p) {
      delete ((::DPSP_t*)p);
   }
   static void deleteArray_DPSP_t(void *p) {
      delete [] ((::DPSP_t*)p);
   }
   static void destruct_DPSP_t(void *p) {
      typedef ::DPSP_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DPSP_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DSPC_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DSPC_t : new ::DSPC_t;
   }
   static void *newArray_DSPC_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DSPC_t[nElements] : new ::DSPC_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DSPC_t(void *p) {
      delete ((::DSPC_t*)p);
   }
   static void deleteArray_DSPC_t(void *p) {
      delete [] ((::DSPC_t*)p);
   }
   static void destruct_DSPC_t(void *p) {
      typedef ::DSPC_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DSPC_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DSPS_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DSPS_t : new ::DSPS_t;
   }
   static void *newArray_DSPS_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DSPS_t[nElements] : new ::DSPS_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DSPS_t(void *p) {
      delete ((::DSPS_t*)p);
   }
   static void deleteArray_DSPS_t(void *p) {
      delete [] ((::DSPS_t*)p);
   }
   static void destruct_DSPS_t(void *p) {
      typedef ::DSPS_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DSPS_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DSTC_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DSTC_t : new ::DSTC_t;
   }
   static void *newArray_DSTC_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DSTC_t[nElements] : new ::DSTC_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DSTC_t(void *p) {
      delete ((::DSTC_t*)p);
   }
   static void deleteArray_DSTC_t(void *p) {
      delete [] ((::DSTC_t*)p);
   }
   static void destruct_DSTC_t(void *p) {
      typedef ::DSTC_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DSTC_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DTCP_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DTCP_t : new ::DTCP_t;
   }
   static void *newArray_DTCP_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DTCP_t[nElements] : new ::DTCP_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DTCP_t(void *p) {
      delete ((::DTCP_t*)p);
   }
   static void deleteArray_DTCP_t(void *p) {
      delete [] ((::DTCP_t*)p);
   }
   static void destruct_DTCP_t(void *p) {
      typedef ::DTCP_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DTCP_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DTRK_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DTRK_t : new ::DTRK_t;
   }
   static void *newArray_DTRK_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DTRK_t[nElements] : new ::DTRK_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_DTRK_t(void *p) {
      delete ((::DTRK_t*)p);
   }
   static void deleteArray_DTRK_t(void *p) {
      delete [] ((::DTRK_t*)p);
   }
   static void destruct_DTRK_t(void *p) {
      typedef ::DTRK_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DTRK_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_EC01_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EC01_t : new ::EC01_t;
   }
   static void *newArray_EC01_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EC01_t[nElements] : new ::EC01_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_EC01_t(void *p) {
      delete ((::EC01_t*)p);
   }
   static void deleteArray_EC01_t(void *p) {
      delete [] ((::EC01_t*)p);
   }
   static void destruct_EC01_t(void *p) {
      typedef ::EC01_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::EC01_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_EC1_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EC1_t : new ::EC1_t;
   }
   static void *newArray_EC1_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EC1_t[nElements] : new ::EC1_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_EC1_t(void *p) {
      delete ((::EC1_t*)p);
   }
   static void deleteArray_EC1_t(void *p) {
      delete [] ((::EC1_t*)p);
   }
   static void destruct_EC1_t(void *p) {
      typedef ::EC1_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::EC1_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_EC1P_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EC1P_t : new ::EC1P_t;
   }
   static void *newArray_EC1P_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EC1P_t[nElements] : new ::EC1P_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_EC1P_t(void *p) {
      delete ((::EC1P_t*)p);
   }
   static void deleteArray_EC1P_t(void *p) {
      delete [] ((::EC1P_t*)p);
   }
   static void destruct_EC1P_t(void *p) {
      typedef ::EC1P_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::EC1P_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_EC1R_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EC1R_t : new ::EC1R_t;
   }
   static void *newArray_EC1R_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EC1R_t[nElements] : new ::EC1R_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_EC1R_t(void *p) {
      delete ((::EC1R_t*)p);
   }
   static void deleteArray_EC1R_t(void *p) {
      delete [] ((::EC1R_t*)p);
   }
   static void destruct_EC1R_t(void *p) {
      typedef ::EC1R_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::EC1R_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECCA_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECCA_t : new ::ECCA_t;
   }
   static void *newArray_ECCA_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECCA_t[nElements] : new ::ECCA_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECCA_t(void *p) {
      delete ((::ECCA_t*)p);
   }
   static void deleteArray_ECCA_t(void *p) {
      delete [] ((::ECCA_t*)p);
   }
   static void destruct_ECCA_t(void *p) {
      typedef ::ECCA_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECCA_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECCL_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECCL_t : new ::ECCL_t;
   }
   static void *newArray_ECCL_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECCL_t[nElements] : new ::ECCL_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECCL_t(void *p) {
      delete ((::ECCL_t*)p);
   }
   static void deleteArray_ECCL_t(void *p) {
      delete [] ((::ECCL_t*)p);
   }
   static void destruct_ECCL_t(void *p) {
      typedef ::ECCL_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECCL_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECCT_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECCT_t : new ::ECCT_t;
   }
   static void *newArray_ECCT_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECCT_t[nElements] : new ::ECCT_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECCT_t(void *p) {
      delete ((::ECCT_t*)p);
   }
   static void deleteArray_ECCT_t(void *p) {
      delete [] ((::ECCT_t*)p);
   }
   static void destruct_ECCT_t(void *p) {
      typedef ::ECCT_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECCT_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_EC_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EC_t : new ::EC_t;
   }
   static void *newArray_EC_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EC_t[nElements] : new ::EC_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_EC_t(void *p) {
      delete ((::EC_t*)p);
   }
   static void deleteArray_EC_t(void *p) {
      delete [] ((::EC_t*)p);
   }
   static void destruct_EC_t(void *p) {
      typedef ::EC_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::EC_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECDI_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECDI_t : new ::ECDI_t;
   }
   static void *newArray_ECDI_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECDI_t[nElements] : new ::ECDI_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECDI_t(void *p) {
      delete ((::ECDI_t*)p);
   }
   static void deleteArray_ECDI_t(void *p) {
      delete [] ((::ECDI_t*)p);
   }
   static void destruct_ECDI_t(void *p) {
      typedef ::ECDI_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECDI_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECG_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECG_t : new ::ECG_t;
   }
   static void *newArray_ECG_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECG_t[nElements] : new ::ECG_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECG_t(void *p) {
      delete ((::ECG_t*)p);
   }
   static void deleteArray_ECG_t(void *p) {
      delete [] ((::ECG_t*)p);
   }
   static void destruct_ECG_t(void *p) {
      typedef ::ECG_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECG_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECHB_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECHB_t : new ::ECHB_t;
   }
   static void *newArray_ECHB_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECHB_t[nElements] : new ::ECHB_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECHB_t(void *p) {
      delete ((::ECHB_t*)p);
   }
   static void deleteArray_ECHB_t(void *p) {
      delete [] ((::ECHB_t*)p);
   }
   static void destruct_ECHB_t(void *p) {
      typedef ::ECHB_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECHB_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECH_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECH_t : new ::ECH_t;
   }
   static void *newArray_ECH_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECH_t[nElements] : new ::ECH_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECH_t(void *p) {
      delete ((::ECH_t*)p);
   }
   static void deleteArray_ECH_t(void *p) {
      delete [] ((::ECH_t*)p);
   }
   static void destruct_ECH_t(void *p) {
      typedef ::ECH_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECH_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECMT_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECMT_t : new ::ECMT_t;
   }
   static void *newArray_ECMT_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECMT_t[nElements] : new ::ECMT_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECMT_t(void *p) {
      delete ((::ECMT_t*)p);
   }
   static void deleteArray_ECMT_t(void *p) {
      delete [] ((::ECMT_t*)p);
   }
   static void destruct_ECMT_t(void *p) {
      typedef ::ECMT_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECMT_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECP1_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECP1_t : new ::ECP1_t;
   }
   static void *newArray_ECP1_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECP1_t[nElements] : new ::ECP1_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECP1_t(void *p) {
      delete ((::ECP1_t*)p);
   }
   static void deleteArray_ECP1_t(void *p) {
      delete [] ((::ECP1_t*)p);
   }
   static void destruct_ECP1_t(void *p) {
      typedef ::ECP1_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECP1_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECPB_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECPB_t : new ::ECPB_t;
   }
   static void *newArray_ECPB_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECPB_t[nElements] : new ::ECPB_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECPB_t(void *p) {
      delete ((::ECPB_t*)p);
   }
   static void deleteArray_ECPB_t(void *p) {
      delete [] ((::ECPB_t*)p);
   }
   static void destruct_ECPB_t(void *p) {
      typedef ::ECPB_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECPB_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECPC_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECPC_t : new ::ECPC_t;
   }
   static void *newArray_ECPC_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECPC_t[nElements] : new ::ECPC_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECPC_t(void *p) {
      delete ((::ECPC_t*)p);
   }
   static void deleteArray_ECPC_t(void *p) {
      delete [] ((::ECPC_t*)p);
   }
   static void destruct_ECPC_t(void *p) {
      typedef ::ECPC_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECPC_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECP_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECP_t : new ::ECP_t;
   }
   static void *newArray_ECP_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECP_t[nElements] : new ::ECP_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECP_t(void *p) {
      delete ((::ECP_t*)p);
   }
   static void deleteArray_ECP_t(void *p) {
      delete [] ((::ECP_t*)p);
   }
   static void destruct_ECP_t(void *p) {
      typedef ::ECP_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECP_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECPE_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECPE_t : new ::ECPE_t;
   }
   static void *newArray_ECPE_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECPE_t[nElements] : new ::ECPE_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECPE_t(void *p) {
      delete ((::ECPE_t*)p);
   }
   static void deleteArray_ECPE_t(void *p) {
      delete [] ((::ECPE_t*)p);
   }
   static void destruct_ECPE_t(void *p) {
      typedef ::ECPE_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECPE_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECPI_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECPI_t : new ::ECPI_t;
   }
   static void *newArray_ECPI_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECPI_t[nElements] : new ::ECPI_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECPI_t(void *p) {
      delete ((::ECPI_t*)p);
   }
   static void deleteArray_ECPI_t(void *p) {
      delete [] ((::ECPI_t*)p);
   }
   static void destruct_ECPI_t(void *p) {
      typedef ::ECPI_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECPI_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECPO_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECPO_t : new ::ECPO_t;
   }
   static void *newArray_ECPO_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECPO_t[nElements] : new ::ECPO_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECPO_t(void *p) {
      delete ((::ECPO_t*)p);
   }
   static void deleteArray_ECPO_t(void *p) {
      delete [] ((::ECPO_t*)p);
   }
   static void destruct_ECPO_t(void *p) {
      typedef ::ECPO_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECPO_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECRB_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECRB_t : new ::ECRB_t;
   }
   static void *newArray_ECRB_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECRB_t[nElements] : new ::ECRB_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECRB_t(void *p) {
      delete ((::ECRB_t*)p);
   }
   static void deleteArray_ECRB_t(void *p) {
      delete [] ((::ECRB_t*)p);
   }
   static void destruct_ECRB_t(void *p) {
      typedef ::ECRB_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECRB_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECS_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECS_t : new ::ECS_t;
   }
   static void *newArray_ECS_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECS_t[nElements] : new ::ECS_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECS_t(void *p) {
      delete ((::ECS_t*)p);
   }
   static void deleteArray_ECS_t(void *p) {
      delete [] ((::ECS_t*)p);
   }
   static void destruct_ECS_t(void *p) {
      typedef ::ECS_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECS_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ECT_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECT_t : new ::ECT_t;
   }
   static void *newArray_ECT_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ECT_t[nElements] : new ::ECT_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ECT_t(void *p) {
      delete ((::ECT_t*)p);
   }
   static void deleteArray_ECT_t(void *p) {
      delete [] ((::ECT_t*)p);
   }
   static void destruct_ECT_t(void *p) {
      typedef ::ECT_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ECT_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_EID0_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EID0_t : new ::EID0_t;
   }
   static void *newArray_EID0_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EID0_t[nElements] : new ::EID0_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_EID0_t(void *p) {
      delete ((::EID0_t*)p);
   }
   static void deleteArray_EID0_t(void *p) {
      delete [] ((::EID0_t*)p);
   }
   static void destruct_EID0_t(void *p) {
      typedef ::EID0_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::EID0_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_EPIC_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EPIC_t : new ::EPIC_t;
   }
   static void *newArray_EPIC_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EPIC_t[nElements] : new ::EPIC_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_EPIC_t(void *p) {
      delete ((::EPIC_t*)p);
   }
   static void deleteArray_EPIC_t(void *p) {
      delete [] ((::EPIC_t*)p);
   }
   static void destruct_EPIC_t(void *p) {
      typedef ::EPIC_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::EPIC_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_EVNT_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EVNT_t : new ::EVNT_t;
   }
   static void *newArray_EVNT_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EVNT_t[nElements] : new ::EVNT_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_EVNT_t(void *p) {
      delete ((::EVNT_t*)p);
   }
   static void deleteArray_EVNT_t(void *p) {
      delete [] ((::EVNT_t*)p);
   }
   static void destruct_EVNT_t(void *p) {
      typedef ::EVNT_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::EVNT_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_FBPM_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FBPM_t : new ::FBPM_t;
   }
   static void *newArray_FBPM_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FBPM_t[nElements] : new ::FBPM_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_FBPM_t(void *p) {
      delete ((::FBPM_t*)p);
   }
   static void deleteArray_FBPM_t(void *p) {
      delete [] ((::FBPM_t*)p);
   }
   static void destruct_FBPM_t(void *p) {
      typedef ::FBPM_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::FBPM_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_G1SL_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::G1SL_t : new ::G1SL_t;
   }
   static void *newArray_G1SL_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::G1SL_t[nElements] : new ::G1SL_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_G1SL_t(void *p) {
      delete ((::G1SL_t*)p);
   }
   static void deleteArray_G1SL_t(void *p) {
      delete [] ((::G1SL_t*)p);
   }
   static void destruct_G1SL_t(void *p) {
      typedef ::G1SL_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::G1SL_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_G2SL_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::G2SL_t : new ::G2SL_t;
   }
   static void *newArray_G2SL_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::G2SL_t[nElements] : new ::G2SL_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_G2SL_t(void *p) {
      delete ((::G2SL_t*)p);
   }
   static void deleteArray_G2SL_t(void *p) {
      delete [] ((::G2SL_t*)p);
   }
   static void destruct_G2SL_t(void *p) {
      typedef ::G2SL_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::G2SL_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_G3SL_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::G3SL_t : new ::G3SL_t;
   }
   static void *newArray_G3SL_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::G3SL_t[nElements] : new ::G3SL_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_G3SL_t(void *p) {
      delete ((::G3SL_t*)p);
   }
   static void deleteArray_G3SL_t(void *p) {
      delete [] ((::G3SL_t*)p);
   }
   static void destruct_G3SL_t(void *p) {
      typedef ::G3SL_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::G3SL_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_G4SL_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::G4SL_t : new ::G4SL_t;
   }
   static void *newArray_G4SL_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::G4SL_t[nElements] : new ::G4SL_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_G4SL_t(void *p) {
      delete ((::G4SL_t*)p);
   }
   static void deleteArray_G4SL_t(void *p) {
      delete [] ((::G4SL_t*)p);
   }
   static void destruct_G4SL_t(void *p) {
      typedef ::G4SL_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::G4SL_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_GPAR_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GPAR_t : new ::GPAR_t;
   }
   static void *newArray_GPAR_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GPAR_t[nElements] : new ::GPAR_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_GPAR_t(void *p) {
      delete ((::GPAR_t*)p);
   }
   static void deleteArray_GPAR_t(void *p) {
      delete [] ((::GPAR_t*)p);
   }
   static void destruct_GPAR_t(void *p) {
      typedef ::GPAR_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::GPAR_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_GPID_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GPID_t : new ::GPID_t;
   }
   static void *newArray_GPID_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GPID_t[nElements] : new ::GPID_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_GPID_t(void *p) {
      delete ((::GPID_t*)p);
   }
   static void deleteArray_GPID_t(void *p) {
      delete [] ((::GPID_t*)p);
   }
   static void destruct_GPID_t(void *p) {
      typedef ::GPID_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::GPID_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_GP_X_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GP_X_t : new ::GP_X_t;
   }
   static void *newArray_GP_X_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GP_X_t[nElements] : new ::GP_X_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_GP_X_t(void *p) {
      delete ((::GP_X_t*)p);
   }
   static void deleteArray_GP_X_t(void *p) {
      delete [] ((::GP_X_t*)p);
   }
   static void destruct_GP_X_t(void *p) {
      typedef ::GP_X_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::GP_X_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_GP_Y_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GP_Y_t : new ::GP_Y_t;
   }
   static void *newArray_GP_Y_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GP_Y_t[nElements] : new ::GP_Y_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_GP_Y_t(void *p) {
      delete ((::GP_Y_t*)p);
   }
   static void deleteArray_GP_Y_t(void *p) {
      delete [] ((::GP_Y_t*)p);
   }
   static void destruct_GP_Y_t(void *p) {
      typedef ::GP_Y_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::GP_Y_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_HBER_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HBER_t : new ::HBER_t;
   }
   static void *newArray_HBER_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HBER_t[nElements] : new ::HBER_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_HBER_t(void *p) {
      delete ((::HBER_t*)p);
   }
   static void deleteArray_HBER_t(void *p) {
      delete [] ((::HBER_t*)p);
   }
   static void destruct_HBER_t(void *p) {
      typedef ::HBER_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::HBER_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_HBID_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HBID_t : new ::HBID_t;
   }
   static void *newArray_HBID_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HBID_t[nElements] : new ::HBID_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_HBID_t(void *p) {
      delete ((::HBID_t*)p);
   }
   static void deleteArray_HBID_t(void *p) {
      delete [] ((::HBID_t*)p);
   }
   static void destruct_HBID_t(void *p) {
      typedef ::HBID_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::HBID_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_HBLA_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HBLA_t : new ::HBLA_t;
   }
   static void *newArray_HBLA_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HBLA_t[nElements] : new ::HBLA_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_HBLA_t(void *p) {
      delete ((::HBLA_t*)p);
   }
   static void deleteArray_HBLA_t(void *p) {
      delete [] ((::HBLA_t*)p);
   }
   static void destruct_HBLA_t(void *p) {
      typedef ::HBLA_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::HBLA_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_HBTB_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HBTB_t : new ::HBTB_t;
   }
   static void *newArray_HBTB_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HBTB_t[nElements] : new ::HBTB_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_HBTB_t(void *p) {
      delete ((::HBTB_t*)p);
   }
   static void deleteArray_HBTB_t(void *p) {
      delete [] ((::HBTB_t*)p);
   }
   static void destruct_HBTB_t(void *p) {
      typedef ::HBTB_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::HBTB_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_HBTR_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HBTR_t : new ::HBTR_t;
   }
   static void *newArray_HBTR_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HBTR_t[nElements] : new ::HBTR_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_HBTR_t(void *p) {
      delete ((::HBTR_t*)p);
   }
   static void deleteArray_HBTR_t(void *p) {
      delete [] ((::HBTR_t*)p);
   }
   static void destruct_HBTR_t(void *p) {
      typedef ::HBTR_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::HBTR_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_HCAL_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HCAL_t : new ::HCAL_t;
   }
   static void *newArray_HCAL_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HCAL_t[nElements] : new ::HCAL_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_HCAL_t(void *p) {
      delete ((::HCAL_t*)p);
   }
   static void deleteArray_HCAL_t(void *p) {
      delete [] ((::HCAL_t*)p);
   }
   static void destruct_HCAL_t(void *p) {
      typedef ::HCAL_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::HCAL_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_HDPL_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HDPL_t : new ::HDPL_t;
   }
   static void *newArray_HDPL_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HDPL_t[nElements] : new ::HDPL_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_HDPL_t(void *p) {
      delete ((::HDPL_t*)p);
   }
   static void deleteArray_HDPL_t(void *p) {
      delete [] ((::HDPL_t*)p);
   }
   static void destruct_HDPL_t(void *p) {
      typedef ::HDPL_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::HDPL_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_HEAD_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HEAD_t : new ::HEAD_t;
   }
   static void *newArray_HEAD_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HEAD_t[nElements] : new ::HEAD_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_HEAD_t(void *p) {
      delete ((::HEAD_t*)p);
   }
   static void deleteArray_HEAD_t(void *p) {
      delete [] ((::HEAD_t*)p);
   }
   static void destruct_HEAD_t(void *p) {
      typedef ::HEAD_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::HEAD_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_HEVT_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HEVT_t : new ::HEVT_t;
   }
   static void *newArray_HEVT_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HEVT_t[nElements] : new ::HEVT_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_HEVT_t(void *p) {
      delete ((::HEVT_t*)p);
   }
   static void deleteArray_HEVT_t(void *p) {
      delete [] ((::HEVT_t*)p);
   }
   static void destruct_HEVT_t(void *p) {
      typedef ::HEVT_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::HEVT_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_HLS_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HLS_t : new ::HLS_t;
   }
   static void *newArray_HLS_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::HLS_t[nElements] : new ::HLS_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_HLS_t(void *p) {
      delete ((::HLS_t*)p);
   }
   static void deleteArray_HLS_t(void *p) {
      delete [] ((::HLS_t*)p);
   }
   static void destruct_HLS_t(void *p) {
      typedef ::HLS_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::HLS_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_IC_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::IC_t : new ::IC_t;
   }
   static void *newArray_IC_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::IC_t[nElements] : new ::IC_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_IC_t(void *p) {
      delete ((::IC_t*)p);
   }
   static void deleteArray_IC_t(void *p) {
      delete [] ((::IC_t*)p);
   }
   static void destruct_IC_t(void *p) {
      typedef ::IC_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::IC_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ICHB_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ICHB_t : new ::ICHB_t;
   }
   static void *newArray_ICHB_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ICHB_t[nElements] : new ::ICHB_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ICHB_t(void *p) {
      delete ((::ICHB_t*)p);
   }
   static void deleteArray_ICHB_t(void *p) {
      delete [] ((::ICHB_t*)p);
   }
   static void destruct_ICHB_t(void *p) {
      typedef ::ICHB_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ICHB_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_KFIT_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::KFIT_t : new ::KFIT_t;
   }
   static void *newArray_KFIT_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::KFIT_t[nElements] : new ::KFIT_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_KFIT_t(void *p) {
      delete ((::KFIT_t*)p);
   }
   static void deleteArray_KFIT_t(void *p) {
      delete [] ((::KFIT_t*)p);
   }
   static void destruct_KFIT_t(void *p) {
      typedef ::KFIT_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::KFIT_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_L1PG_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::L1PG_t : new ::L1PG_t;
   }
   static void *newArray_L1PG_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::L1PG_t[nElements] : new ::L1PG_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_L1PG_t(void *p) {
      delete ((::L1PG_t*)p);
   }
   static void deleteArray_L1PG_t(void *p) {
      delete [] ((::L1PG_t*)p);
   }
   static void destruct_L1PG_t(void *p) {
      typedef ::L1PG_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::L1PG_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_L2H_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::L2H_t : new ::L2H_t;
   }
   static void *newArray_L2H_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::L2H_t[nElements] : new ::L2H_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_L2H_t(void *p) {
      delete ((::L2H_t*)p);
   }
   static void deleteArray_L2H_t(void *p) {
      delete [] ((::L2H_t*)p);
   }
   static void destruct_L2H_t(void *p) {
      typedef ::L2H_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::L2H_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_L2S_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::L2S_t : new ::L2S_t;
   }
   static void *newArray_L2S_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::L2S_t[nElements] : new ::L2S_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_L2S_t(void *p) {
      delete ((::L2S_t*)p);
   }
   static void deleteArray_L2S_t(void *p) {
      delete [] ((::L2S_t*)p);
   }
   static void destruct_L2S_t(void *p) {
      typedef ::L2S_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::L2S_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_LASR_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::LASR_t : new ::LASR_t;
   }
   static void *newArray_LASR_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::LASR_t[nElements] : new ::LASR_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_LASR_t(void *p) {
      delete ((::LASR_t*)p);
   }
   static void deleteArray_LASR_t(void *p) {
      delete [] ((::LASR_t*)p);
   }
   static void destruct_LASR_t(void *p) {
      typedef ::LASR_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::LASR_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_LCDI_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::LCDI_t : new ::LCDI_t;
   }
   static void *newArray_LCDI_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::LCDI_t[nElements] : new ::LCDI_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_LCDI_t(void *p) {
      delete ((::LCDI_t*)p);
   }
   static void deleteArray_LCDI_t(void *p) {
      delete [] ((::LCDI_t*)p);
   }
   static void destruct_LCDI_t(void *p) {
      typedef ::LCDI_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::LCDI_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_LCPB_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::LCPB_t : new ::LCPB_t;
   }
   static void *newArray_LCPB_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::LCPB_t[nElements] : new ::LCPB_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_LCPB_t(void *p) {
      delete ((::LCPB_t*)p);
   }
   static void deleteArray_LCPB_t(void *p) {
      delete [] ((::LCPB_t*)p);
   }
   static void destruct_LCPB_t(void *p) {
      typedef ::LCPB_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::LCPB_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_LOWQ_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::LOWQ_t : new ::LOWQ_t;
   }
   static void *newArray_LOWQ_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::LOWQ_t[nElements] : new ::LOWQ_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_LOWQ_t(void *p) {
      delete ((::LOWQ_t*)p);
   }
   static void deleteArray_LOWQ_t(void *p) {
      delete [] ((::LOWQ_t*)p);
   }
   static void destruct_LOWQ_t(void *p) {
      typedef ::LOWQ_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::LOWQ_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_MCEV_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::MCEV_t : new ::MCEV_t;
   }
   static void *newArray_MCEV_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::MCEV_t[nElements] : new ::MCEV_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_MCEV_t(void *p) {
      delete ((::MCEV_t*)p);
   }
   static void deleteArray_MCEV_t(void *p) {
      delete [] ((::MCEV_t*)p);
   }
   static void destruct_MCEV_t(void *p) {
      typedef ::MCEV_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::MCEV_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_MCHD_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::MCHD_t : new ::MCHD_t;
   }
   static void *newArray_MCHD_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::MCHD_t[nElements] : new ::MCHD_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_MCHD_t(void *p) {
      delete ((::MCHD_t*)p);
   }
   static void deleteArray_MCHD_t(void *p) {
      delete [] ((::MCHD_t*)p);
   }
   static void destruct_MCHD_t(void *p) {
      typedef ::MCHD_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::MCHD_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_MCTK_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::MCTK_t : new ::MCTK_t;
   }
   static void *newArray_MCTK_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::MCTK_t[nElements] : new ::MCTK_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_MCTK_t(void *p) {
      delete ((::MCTK_t*)p);
   }
   static void deleteArray_MCTK_t(void *p) {
      delete [] ((::MCTK_t*)p);
   }
   static void destruct_MCTK_t(void *p) {
      typedef ::MCTK_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::MCTK_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_MCVX_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::MCVX_t : new ::MCVX_t;
   }
   static void *newArray_MCVX_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::MCVX_t[nElements] : new ::MCVX_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_MCVX_t(void *p) {
      delete ((::MCVX_t*)p);
   }
   static void deleteArray_MCVX_t(void *p) {
      delete [] ((::MCVX_t*)p);
   }
   static void destruct_MCVX_t(void *p) {
      typedef ::MCVX_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::MCVX_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_MS1_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::MS1_t : new ::MS1_t;
   }
   static void *newArray_MS1_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::MS1_t[nElements] : new ::MS1_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_MS1_t(void *p) {
      delete ((::MS1_t*)p);
   }
   static void deleteArray_MS1_t(void *p) {
      delete [] ((::MS1_t*)p);
   }
   static void destruct_MS1_t(void *p) {
      typedef ::MS1_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::MS1_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_MTRK_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::MTRK_t : new ::MTRK_t;
   }
   static void *newArray_MTRK_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::MTRK_t[nElements] : new ::MTRK_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_MTRK_t(void *p) {
      delete ((::MTRK_t*)p);
   }
   static void deleteArray_MTRK_t(void *p) {
      delete [] ((::MTRK_t*)p);
   }
   static void destruct_MTRK_t(void *p) {
      typedef ::MTRK_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::MTRK_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_MVRT_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::MVRT_t : new ::MVRT_t;
   }
   static void *newArray_MVRT_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::MVRT_t[nElements] : new ::MVRT_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_MVRT_t(void *p) {
      delete ((::MVRT_t*)p);
   }
   static void deleteArray_MVRT_t(void *p) {
      delete [] ((::MVRT_t*)p);
   }
   static void destruct_MVRT_t(void *p) {
      typedef ::MVRT_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::MVRT_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_PART_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PART_t : new ::PART_t;
   }
   static void *newArray_PART_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PART_t[nElements] : new ::PART_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_PART_t(void *p) {
      delete ((::PART_t*)p);
   }
   static void deleteArray_PART_t(void *p) {
      delete [] ((::PART_t*)p);
   }
   static void destruct_PART_t(void *p) {
      typedef ::PART_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::PART_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_PCO_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PCO_t : new ::PCO_t;
   }
   static void *newArray_PCO_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PCO_t[nElements] : new ::PCO_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_PCO_t(void *p) {
      delete ((::PCO_t*)p);
   }
   static void deleteArray_PCO_t(void *p) {
      delete [] ((::PCO_t*)p);
   }
   static void destruct_PCO_t(void *p) {
      typedef ::PCO_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::PCO_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_PHTM_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PHTM_t : new ::PHTM_t;
   }
   static void *newArray_PHTM_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PHTM_t[nElements] : new ::PHTM_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_PHTM_t(void *p) {
      delete ((::PHTM_t*)p);
   }
   static void deleteArray_PHTM_t(void *p) {
      delete [] ((::PHTM_t*)p);
   }
   static void destruct_PHTM_t(void *p) {
      typedef ::PHTM_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::PHTM_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_PID1_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PID1_t : new ::PID1_t;
   }
   static void *newArray_PID1_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PID1_t[nElements] : new ::PID1_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_PID1_t(void *p) {
      delete ((::PID1_t*)p);
   }
   static void deleteArray_PID1_t(void *p) {
      delete [] ((::PID1_t*)p);
   }
   static void destruct_PID1_t(void *p) {
      typedef ::PID1_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::PID1_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_PID2_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PID2_t : new ::PID2_t;
   }
   static void *newArray_PID2_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PID2_t[nElements] : new ::PID2_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_PID2_t(void *p) {
      delete ((::PID2_t*)p);
   }
   static void deleteArray_PID2_t(void *p) {
      delete [] ((::PID2_t*)p);
   }
   static void destruct_PID2_t(void *p) {
      typedef ::PID2_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::PID2_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_PID3_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PID3_t : new ::PID3_t;
   }
   static void *newArray_PID3_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PID3_t[nElements] : new ::PID3_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_PID3_t(void *p) {
      delete ((::PID3_t*)p);
   }
   static void deleteArray_PID3_t(void *p) {
      delete [] ((::PID3_t*)p);
   }
   static void destruct_PID3_t(void *p) {
      typedef ::PID3_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::PID3_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_PID4_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PID4_t : new ::PID4_t;
   }
   static void *newArray_PID4_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PID4_t[nElements] : new ::PID4_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_PID4_t(void *p) {
      delete ((::PID4_t*)p);
   }
   static void deleteArray_PID4_t(void *p) {
      delete [] ((::PID4_t*)p);
   }
   static void destruct_PID4_t(void *p) {
      typedef ::PID4_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::PID4_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_PID5_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PID5_t : new ::PID5_t;
   }
   static void *newArray_PID5_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PID5_t[nElements] : new ::PID5_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_PID5_t(void *p) {
      delete ((::PID5_t*)p);
   }
   static void deleteArray_PID5_t(void *p) {
      delete [] ((::PID5_t*)p);
   }
   static void destruct_PID5_t(void *p) {
      typedef ::PID5_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::PID5_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_PID6_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PID6_t : new ::PID6_t;
   }
   static void *newArray_PID6_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PID6_t[nElements] : new ::PID6_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_PID6_t(void *p) {
      delete ((::PID6_t*)p);
   }
   static void deleteArray_PID6_t(void *p) {
      delete [] ((::PID6_t*)p);
   }
   static void destruct_PID6_t(void *p) {
      typedef ::PID6_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::PID6_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_PIDT_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PIDT_t : new ::PIDT_t;
   }
   static void *newArray_PIDT_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PIDT_t[nElements] : new ::PIDT_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_PIDT_t(void *p) {
      delete ((::PIDT_t*)p);
   }
   static void deleteArray_PIDT_t(void *p) {
      delete [] ((::PIDT_t*)p);
   }
   static void destruct_PIDT_t(void *p) {
      typedef ::PIDT_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::PIDT_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_PRTM_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PRTM_t : new ::PRTM_t;
   }
   static void *newArray_PRTM_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PRTM_t[nElements] : new ::PRTM_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_PRTM_t(void *p) {
      delete ((::PRTM_t*)p);
   }
   static void deleteArray_PRTM_t(void *p) {
      delete [] ((::PRTM_t*)p);
   }
   static void destruct_PRTM_t(void *p) {
      typedef ::PRTM_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::PRTM_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_PSO_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PSO_t : new ::PSO_t;
   }
   static void *newArray_PSO_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PSO_t[nElements] : new ::PSO_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_PSO_t(void *p) {
      delete ((::PSO_t*)p);
   }
   static void deleteArray_PSO_t(void *p) {
      delete [] ((::PSO_t*)p);
   }
   static void destruct_PSO_t(void *p) {
      typedef ::PSO_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::PSO_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_PTDB_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PTDB_t : new ::PTDB_t;
   }
   static void *newArray_PTDB_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PTDB_t[nElements] : new ::PTDB_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_PTDB_t(void *p) {
      delete ((::PTDB_t*)p);
   }
   static void deleteArray_PTDB_t(void *p) {
      delete [] ((::PTDB_t*)p);
   }
   static void destruct_PTDB_t(void *p) {
      typedef ::PTDB_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::PTDB_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_RCST_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RCST_t : new ::RCST_t;
   }
   static void *newArray_RCST_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RCST_t[nElements] : new ::RCST_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_RCST_t(void *p) {
      delete ((::RCST_t*)p);
   }
   static void deleteArray_RCST_t(void *p) {
      delete [] ((::RCST_t*)p);
   }
   static void destruct_RCST_t(void *p) {
      typedef ::RCST_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::RCST_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_REF_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::REF_t : new ::REF_t;
   }
   static void *newArray_REF_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::REF_t[nElements] : new ::REF_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_REF_t(void *p) {
      delete ((::REF_t*)p);
   }
   static void deleteArray_REF_t(void *p) {
      delete [] ((::REF_t*)p);
   }
   static void destruct_REF_t(void *p) {
      typedef ::REF_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::REF_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_RF_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RF_t : new ::RF_t;
   }
   static void *newArray_RF_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RF_t[nElements] : new ::RF_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_RF_t(void *p) {
      delete ((::RF_t*)p);
   }
   static void deleteArray_RF_t(void *p) {
      delete [] ((::RF_t*)p);
   }
   static void destruct_RF_t(void *p) {
      typedef ::RF_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::RF_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_RFT_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RFT_t : new ::RFT_t;
   }
   static void *newArray_RFT_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RFT_t[nElements] : new ::RFT_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_RFT_t(void *p) {
      delete ((::RFT_t*)p);
   }
   static void deleteArray_RFT_t(void *p) {
      delete [] ((::RFT_t*)p);
   }
   static void destruct_RFT_t(void *p) {
      typedef ::RFT_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::RFT_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_RGLK_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RGLK_t : new ::RGLK_t;
   }
   static void *newArray_RGLK_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RGLK_t[nElements] : new ::RGLK_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_RGLK_t(void *p) {
      delete ((::RGLK_t*)p);
   }
   static void deleteArray_RGLK_t(void *p) {
      delete [] ((::RGLK_t*)p);
   }
   static void destruct_RGLK_t(void *p) {
      typedef ::RGLK_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::RGLK_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_RNLG_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RNLG_t : new ::RNLG_t;
   }
   static void *newArray_RNLG_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RNLG_t[nElements] : new ::RNLG_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_RNLG_t(void *p) {
      delete ((::RNLG_t*)p);
   }
   static void deleteArray_RNLG_t(void *p) {
      delete [] ((::RNLG_t*)p);
   }
   static void destruct_RNLG_t(void *p) {
      typedef ::RNLG_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::RNLG_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_RNPE_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RNPE_t : new ::RNPE_t;
   }
   static void *newArray_RNPE_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RNPE_t[nElements] : new ::RNPE_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_RNPE_t(void *p) {
      delete ((::RNPE_t*)p);
   }
   static void deleteArray_RNPE_t(void *p) {
      delete [] ((::RNPE_t*)p);
   }
   static void destruct_RNPE_t(void *p) {
      typedef ::RNPE_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::RNPE_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_RTSL_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RTSL_t : new ::RTSL_t;
   }
   static void *newArray_RTSL_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RTSL_t[nElements] : new ::RTSL_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_RTSL_t(void *p) {
      delete ((::RTSL_t*)p);
   }
   static void deleteArray_RTSL_t(void *p) {
      delete [] ((::RTSL_t*)p);
   }
   static void destruct_RTSL_t(void *p) {
      typedef ::RTSL_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::RTSL_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_RUNC_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RUNC_t : new ::RUNC_t;
   }
   static void *newArray_RUNC_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RUNC_t[nElements] : new ::RUNC_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_RUNC_t(void *p) {
      delete ((::RUNC_t*)p);
   }
   static void deleteArray_RUNC_t(void *p) {
      delete [] ((::RUNC_t*)p);
   }
   static void destruct_RUNC_t(void *p) {
      typedef ::RUNC_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::RUNC_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_S1ST_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::S1ST_t : new ::S1ST_t;
   }
   static void *newArray_S1ST_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::S1ST_t[nElements] : new ::S1ST_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_S1ST_t(void *p) {
      delete ((::S1ST_t*)p);
   }
   static void deleteArray_S1ST_t(void *p) {
      delete [] ((::S1ST_t*)p);
   }
   static void destruct_S1ST_t(void *p) {
      typedef ::S1ST_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::S1ST_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SC1_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SC1_t : new ::SC1_t;
   }
   static void *newArray_SC1_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SC1_t[nElements] : new ::SC1_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SC1_t(void *p) {
      delete ((::SC1_t*)p);
   }
   static void deleteArray_SC1_t(void *p) {
      delete [] ((::SC1_t*)p);
   }
   static void destruct_SC1_t(void *p) {
      typedef ::SC1_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SC1_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SCC_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCC_t : new ::SCC_t;
   }
   static void *newArray_SCC_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCC_t[nElements] : new ::SCC_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SCC_t(void *p) {
      delete ((::SCC_t*)p);
   }
   static void deleteArray_SCC_t(void *p) {
      delete [] ((::SCC_t*)p);
   }
   static void destruct_SCC_t(void *p) {
      typedef ::SCC_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SCC_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SC_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SC_t : new ::SC_t;
   }
   static void *newArray_SC_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SC_t[nElements] : new ::SC_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SC_t(void *p) {
      delete ((::SC_t*)p);
   }
   static void deleteArray_SC_t(void *p) {
      delete [] ((::SC_t*)p);
   }
   static void destruct_SC_t(void *p) {
      typedef ::SC_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SC_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SCDI_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCDI_t : new ::SCDI_t;
   }
   static void *newArray_SCDI_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCDI_t[nElements] : new ::SCDI_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SCDI_t(void *p) {
      delete ((::SCDI_t*)p);
   }
   static void deleteArray_SCDI_t(void *p) {
      delete [] ((::SCDI_t*)p);
   }
   static void destruct_SCDI_t(void *p) {
      typedef ::SCDI_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SCDI_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SCGD_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCGD_t : new ::SCGD_t;
   }
   static void *newArray_SCGD_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCGD_t[nElements] : new ::SCGD_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SCGD_t(void *p) {
      delete ((::SCGD_t*)p);
   }
   static void deleteArray_SCGD_t(void *p) {
      delete [] ((::SCGD_t*)p);
   }
   static void destruct_SCGD_t(void *p) {
      typedef ::SCGD_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SCGD_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SCG_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCG_t : new ::SCG_t;
   }
   static void *newArray_SCG_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCG_t[nElements] : new ::SCG_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SCG_t(void *p) {
      delete ((::SCG_t*)p);
   }
   static void deleteArray_SCG_t(void *p) {
      delete [] ((::SCG_t*)p);
   }
   static void destruct_SCG_t(void *p) {
      typedef ::SCG_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SCG_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SCH_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCH_t : new ::SCH_t;
   }
   static void *newArray_SCH_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCH_t[nElements] : new ::SCH_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SCH_t(void *p) {
      delete ((::SCH_t*)p);
   }
   static void deleteArray_SCH_t(void *p) {
      delete [] ((::SCH_t*)p);
   }
   static void destruct_SCH_t(void *p) {
      typedef ::SCH_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SCH_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SCMD_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCMD_t : new ::SCMD_t;
   }
   static void *newArray_SCMD_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCMD_t[nElements] : new ::SCMD_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SCMD_t(void *p) {
      delete ((::SCMD_t*)p);
   }
   static void deleteArray_SCMD_t(void *p) {
      delete [] ((::SCMD_t*)p);
   }
   static void destruct_SCMD_t(void *p) {
      typedef ::SCMD_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SCMD_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SCMT_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCMT_t : new ::SCMT_t;
   }
   static void *newArray_SCMT_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCMT_t[nElements] : new ::SCMT_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SCMT_t(void *p) {
      delete ((::SCMT_t*)p);
   }
   static void deleteArray_SCMT_t(void *p) {
      delete [] ((::SCMT_t*)p);
   }
   static void destruct_SCMT_t(void *p) {
      typedef ::SCMT_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SCMT_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SCMW_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCMW_t : new ::SCMW_t;
   }
   static void *newArray_SCMW_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCMW_t[nElements] : new ::SCMW_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SCMW_t(void *p) {
      delete ((::SCMW_t*)p);
   }
   static void deleteArray_SCMW_t(void *p) {
      delete [] ((::SCMW_t*)p);
   }
   static void destruct_SCMW_t(void *p) {
      typedef ::SCMW_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SCMW_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SCPB_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCPB_t : new ::SCPB_t;
   }
   static void *newArray_SCPB_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCPB_t[nElements] : new ::SCPB_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SCPB_t(void *p) {
      delete ((::SCPB_t*)p);
   }
   static void deleteArray_SCPB_t(void *p) {
      delete [] ((::SCPB_t*)p);
   }
   static void destruct_SCPB_t(void *p) {
      typedef ::SCPB_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SCPB_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SCP_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCP_t : new ::SCP_t;
   }
   static void *newArray_SCP_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCP_t[nElements] : new ::SCP_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SCP_t(void *p) {
      delete ((::SCP_t*)p);
   }
   static void deleteArray_SCP_t(void *p) {
      delete [] ((::SCP_t*)p);
   }
   static void destruct_SCP_t(void *p) {
      typedef ::SCP_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SCP_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SCPE_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCPE_t : new ::SCPE_t;
   }
   static void *newArray_SCPE_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCPE_t[nElements] : new ::SCPE_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SCPE_t(void *p) {
      delete ((::SCPE_t*)p);
   }
   static void deleteArray_SCPE_t(void *p) {
      delete [] ((::SCPE_t*)p);
   }
   static void destruct_SCPE_t(void *p) {
      typedef ::SCPE_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SCPE_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SCPS_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCPS_t : new ::SCPS_t;
   }
   static void *newArray_SCPS_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCPS_t[nElements] : new ::SCPS_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SCPS_t(void *p) {
      delete ((::SCPS_t*)p);
   }
   static void deleteArray_SCPS_t(void *p) {
      delete [] ((::SCPS_t*)p);
   }
   static void destruct_SCPS_t(void *p) {
      typedef ::SCPS_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SCPS_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SCRC_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCRC_t : new ::SCRC_t;
   }
   static void *newArray_SCRC_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCRC_t[nElements] : new ::SCRC_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SCRC_t(void *p) {
      delete ((::SCRC_t*)p);
   }
   static void deleteArray_SCRC_t(void *p) {
      delete [] ((::SCRC_t*)p);
   }
   static void destruct_SCRC_t(void *p) {
      typedef ::SCRC_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SCRC_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SCR_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCR_t : new ::SCR_t;
   }
   static void *newArray_SCR_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCR_t[nElements] : new ::SCR_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SCR_t(void *p) {
      delete ((::SCR_t*)p);
   }
   static void deleteArray_SCR_t(void *p) {
      delete [] ((::SCR_t*)p);
   }
   static void destruct_SCR_t(void *p) {
      typedef ::SCR_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SCR_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SCS_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCS_t : new ::SCS_t;
   }
   static void *newArray_SCS_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCS_t[nElements] : new ::SCS_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SCS_t(void *p) {
      delete ((::SCS_t*)p);
   }
   static void deleteArray_SCS_t(void *p) {
      delete [] ((::SCS_t*)p);
   }
   static void destruct_SCS_t(void *p) {
      typedef ::SCS_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SCS_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SCT_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCT_t : new ::SCT_t;
   }
   static void *newArray_SCT_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SCT_t[nElements] : new ::SCT_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SCT_t(void *p) {
      delete ((::SCT_t*)p);
   }
   static void deleteArray_SCT_t(void *p) {
      delete [] ((::SCT_t*)p);
   }
   static void destruct_SCT_t(void *p) {
      typedef ::SCT_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SCT_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SGMP_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SGMP_t : new ::SGMP_t;
   }
   static void *newArray_SGMP_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SGMP_t[nElements] : new ::SGMP_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SGMP_t(void *p) {
      delete ((::SGMP_t*)p);
   }
   static void deleteArray_SGMP_t(void *p) {
      delete [] ((::SGMP_t*)p);
   }
   static void destruct_SGMP_t(void *p) {
      typedef ::SGMP_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SGMP_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SPAR_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SPAR_t : new ::SPAR_t;
   }
   static void *newArray_SPAR_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SPAR_t[nElements] : new ::SPAR_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SPAR_t(void *p) {
      delete ((::SPAR_t*)p);
   }
   static void deleteArray_SPAR_t(void *p) {
      delete [] ((::SPAR_t*)p);
   }
   static void destruct_SPAR_t(void *p) {
      typedef ::SPAR_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SPAR_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SPIN_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SPIN_t : new ::SPIN_t;
   }
   static void *newArray_SPIN_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SPIN_t[nElements] : new ::SPIN_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SPIN_t(void *p) {
      delete ((::SPIN_t*)p);
   }
   static void deleteArray_SPIN_t(void *p) {
      delete [] ((::SPIN_t*)p);
   }
   static void destruct_SPIN_t(void *p) {
      typedef ::SPIN_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SPIN_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ST1_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ST1_t : new ::ST1_t;
   }
   static void *newArray_ST1_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ST1_t[nElements] : new ::ST1_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ST1_t(void *p) {
      delete ((::ST1_t*)p);
   }
   static void deleteArray_ST1_t(void *p) {
      delete [] ((::ST1_t*)p);
   }
   static void destruct_ST1_t(void *p) {
      typedef ::ST1_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ST1_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ST_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ST_t : new ::ST_t;
   }
   static void *newArray_ST_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ST_t[nElements] : new ::ST_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ST_t(void *p) {
      delete ((::ST_t*)p);
   }
   static void deleteArray_ST_t(void *p) {
      delete [] ((::ST_t*)p);
   }
   static void destruct_ST_t(void *p) {
      typedef ::ST_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ST_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_STG_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STG_t : new ::STG_t;
   }
   static void *newArray_STG_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STG_t[nElements] : new ::STG_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_STG_t(void *p) {
      delete ((::STG_t*)p);
   }
   static void deleteArray_STG_t(void *p) {
      delete [] ((::STG_t*)p);
   }
   static void destruct_STG_t(void *p) {
      typedef ::STG_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::STG_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_STH_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STH_t : new ::STH_t;
   }
   static void *newArray_STH_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STH_t[nElements] : new ::STH_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_STH_t(void *p) {
      delete ((::STH_t*)p);
   }
   static void deleteArray_STH_t(void *p) {
      delete [] ((::STH_t*)p);
   }
   static void destruct_STH_t(void *p) {
      typedef ::STH_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::STH_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_STN0_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STN0_t : new ::STN0_t;
   }
   static void *newArray_STN0_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STN0_t[nElements] : new ::STN0_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_STN0_t(void *p) {
      delete ((::STN0_t*)p);
   }
   static void deleteArray_STN0_t(void *p) {
      delete [] ((::STN0_t*)p);
   }
   static void destruct_STN0_t(void *p) {
      typedef ::STN0_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::STN0_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_STN1_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STN1_t : new ::STN1_t;
   }
   static void *newArray_STN1_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STN1_t[nElements] : new ::STN1_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_STN1_t(void *p) {
      delete ((::STN1_t*)p);
   }
   static void deleteArray_STN1_t(void *p) {
      delete [] ((::STN1_t*)p);
   }
   static void destruct_STN1_t(void *p) {
      typedef ::STN1_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::STN1_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_STPB_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STPB_t : new ::STPB_t;
   }
   static void *newArray_STPB_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STPB_t[nElements] : new ::STPB_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_STPB_t(void *p) {
      delete ((::STPB_t*)p);
   }
   static void deleteArray_STPB_t(void *p) {
      delete [] ((::STPB_t*)p);
   }
   static void destruct_STPB_t(void *p) {
      typedef ::STPB_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::STPB_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_STPE_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STPE_t : new ::STPE_t;
   }
   static void *newArray_STPE_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STPE_t[nElements] : new ::STPE_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_STPE_t(void *p) {
      delete ((::STPE_t*)p);
   }
   static void deleteArray_STPE_t(void *p) {
      delete [] ((::STPE_t*)p);
   }
   static void destruct_STPE_t(void *p) {
      typedef ::STPE_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::STPE_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_STR_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STR_t : new ::STR_t;
   }
   static void *newArray_STR_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STR_t[nElements] : new ::STR_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_STR_t(void *p) {
      delete ((::STR_t*)p);
   }
   static void deleteArray_STR_t(void *p) {
      delete [] ((::STR_t*)p);
   }
   static void destruct_STR_t(void *p) {
      typedef ::STR_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::STR_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_STS_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STS_t : new ::STS_t;
   }
   static void *newArray_STS_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STS_t[nElements] : new ::STS_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_STS_t(void *p) {
      delete ((::STS_t*)p);
   }
   static void deleteArray_STS_t(void *p) {
      delete [] ((::STS_t*)p);
   }
   static void destruct_STS_t(void *p) {
      typedef ::STS_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::STS_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_STSN_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STSN_t : new ::STSN_t;
   }
   static void *newArray_STSN_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STSN_t[nElements] : new ::STSN_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_STSN_t(void *p) {
      delete ((::STSN_t*)p);
   }
   static void deleteArray_STSN_t(void *p) {
      delete [] ((::STSN_t*)p);
   }
   static void destruct_STSN_t(void *p) {
      typedef ::STSN_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::STSN_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_SYNC_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SYNC_t : new ::SYNC_t;
   }
   static void *newArray_SYNC_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SYNC_t[nElements] : new ::SYNC_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SYNC_t(void *p) {
      delete ((::SYNC_t*)p);
   }
   static void deleteArray_SYNC_t(void *p) {
      delete [] ((::SYNC_t*)p);
   }
   static void destruct_SYNC_t(void *p) {
      typedef ::SYNC_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::SYNC_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TACO_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TACO_t : new ::TACO_t;
   }
   static void *newArray_TACO_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TACO_t[nElements] : new ::TACO_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TACO_t(void *p) {
      delete ((::TACO_t*)p);
   }
   static void deleteArray_TACO_t(void *p) {
      delete [] ((::TACO_t*)p);
   }
   static void destruct_TACO_t(void *p) {
      typedef ::TACO_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TACO_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TAGE_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TAGE_t : new ::TAGE_t;
   }
   static void *newArray_TAGE_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TAGE_t[nElements] : new ::TAGE_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TAGE_t(void *p) {
      delete ((::TAGE_t*)p);
   }
   static void deleteArray_TAGE_t(void *p) {
      delete [] ((::TAGE_t*)p);
   }
   static void destruct_TAGE_t(void *p) {
      typedef ::TAGE_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TAGE_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TAGI_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TAGI_t : new ::TAGI_t;
   }
   static void *newArray_TAGI_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TAGI_t[nElements] : new ::TAGI_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TAGI_t(void *p) {
      delete ((::TAGI_t*)p);
   }
   static void deleteArray_TAGI_t(void *p) {
      delete [] ((::TAGI_t*)p);
   }
   static void destruct_TAGI_t(void *p) {
      typedef ::TAGI_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TAGI_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TAGM_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TAGM_t : new ::TAGM_t;
   }
   static void *newArray_TAGM_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TAGM_t[nElements] : new ::TAGM_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TAGM_t(void *p) {
      delete ((::TAGM_t*)p);
   }
   static void deleteArray_TAGM_t(void *p) {
      delete [] ((::TAGM_t*)p);
   }
   static void destruct_TAGM_t(void *p) {
      typedef ::TAGM_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TAGM_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TAGR_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TAGR_t : new ::TAGR_t;
   }
   static void *newArray_TAGR_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TAGR_t[nElements] : new ::TAGR_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TAGR_t(void *p) {
      delete ((::TAGR_t*)p);
   }
   static void deleteArray_TAGR_t(void *p) {
      delete [] ((::TAGR_t*)p);
   }
   static void destruct_TAGR_t(void *p) {
      typedef ::TAGR_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TAGR_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TAGT_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TAGT_t : new ::TAGT_t;
   }
   static void *newArray_TAGT_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TAGT_t[nElements] : new ::TAGT_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TAGT_t(void *p) {
      delete ((::TAGT_t*)p);
   }
   static void deleteArray_TAGT_t(void *p) {
      delete [] ((::TAGT_t*)p);
   }
   static void destruct_TAGT_t(void *p) {
      typedef ::TAGT_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TAGT_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TATL_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TATL_t : new ::TATL_t;
   }
   static void *newArray_TATL_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TATL_t[nElements] : new ::TATL_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TATL_t(void *p) {
      delete ((::TATL_t*)p);
   }
   static void deleteArray_TATL_t(void *p) {
      delete [] ((::TATL_t*)p);
   }
   static void destruct_TATL_t(void *p) {
      typedef ::TATL_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TATL_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TATR_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TATR_t : new ::TATR_t;
   }
   static void *newArray_TATR_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TATR_t[nElements] : new ::TATR_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TATR_t(void *p) {
      delete ((::TATR_t*)p);
   }
   static void deleteArray_TATR_t(void *p) {
      delete [] ((::TATR_t*)p);
   }
   static void destruct_TATR_t(void *p) {
      typedef ::TATR_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TATR_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TBER_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TBER_t : new ::TBER_t;
   }
   static void *newArray_TBER_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TBER_t[nElements] : new ::TBER_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TBER_t(void *p) {
      delete ((::TBER_t*)p);
   }
   static void deleteArray_TBER_t(void *p) {
      delete [] ((::TBER_t*)p);
   }
   static void destruct_TBER_t(void *p) {
      typedef ::TBER_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TBER_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TBID_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TBID_t : new ::TBID_t;
   }
   static void *newArray_TBID_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TBID_t[nElements] : new ::TBID_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TBID_t(void *p) {
      delete ((::TBID_t*)p);
   }
   static void deleteArray_TBID_t(void *p) {
      delete [] ((::TBID_t*)p);
   }
   static void destruct_TBID_t(void *p) {
      typedef ::TBID_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TBID_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TBLA_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TBLA_t : new ::TBLA_t;
   }
   static void *newArray_TBLA_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TBLA_t[nElements] : new ::TBLA_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TBLA_t(void *p) {
      delete ((::TBLA_t*)p);
   }
   static void deleteArray_TBLA_t(void *p) {
      delete [] ((::TBLA_t*)p);
   }
   static void destruct_TBLA_t(void *p) {
      typedef ::TBLA_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TBLA_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TBTR_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TBTR_t : new ::TBTR_t;
   }
   static void *newArray_TBTR_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TBTR_t[nElements] : new ::TBTR_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TBTR_t(void *p) {
      delete ((::TBTR_t*)p);
   }
   static void deleteArray_TBTR_t(void *p) {
      delete [] ((::TBTR_t*)p);
   }
   static void destruct_TBTR_t(void *p) {
      typedef ::TBTR_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TBTR_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TCSB_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TCSB_t : new ::TCSB_t;
   }
   static void *newArray_TCSB_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TCSB_t[nElements] : new ::TCSB_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TCSB_t(void *p) {
      delete ((::TCSB_t*)p);
   }
   static void deleteArray_TCSB_t(void *p) {
      delete [] ((::TCSB_t*)p);
   }
   static void destruct_TCSB_t(void *p) {
      typedef ::TCSB_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TCSB_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TCT_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TCT_t : new ::TCT_t;
   }
   static void *newArray_TCT_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TCT_t[nElements] : new ::TCT_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TCT_t(void *p) {
      delete ((::TCT_t*)p);
   }
   static void deleteArray_TCT_t(void *p) {
      delete [] ((::TCT_t*)p);
   }
   static void destruct_TCT_t(void *p) {
      typedef ::TCT_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TCT_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TDPL_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TDPL_t : new ::TDPL_t;
   }
   static void *newArray_TDPL_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TDPL_t[nElements] : new ::TDPL_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TDPL_t(void *p) {
      delete ((::TDPL_t*)p);
   }
   static void deleteArray_TDPL_t(void *p) {
      delete [] ((::TDPL_t*)p);
   }
   static void destruct_TDPL_t(void *p) {
      typedef ::TDPL_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TDPL_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TESC_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TESC_t : new ::TESC_t;
   }
   static void *newArray_TESC_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TESC_t[nElements] : new ::TESC_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TESC_t(void *p) {
      delete ((::TESC_t*)p);
   }
   static void deleteArray_TESC_t(void *p) {
      delete [] ((::TESC_t*)p);
   }
   static void destruct_TESC_t(void *p) {
      typedef ::TESC_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TESC_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TGBI_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TGBI_t : new ::TGBI_t;
   }
   static void *newArray_TGBI_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TGBI_t[nElements] : new ::TGBI_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TGBI_t(void *p) {
      delete ((::TGBI_t*)p);
   }
   static void deleteArray_TGBI_t(void *p) {
      delete [] ((::TGBI_t*)p);
   }
   static void destruct_TGBI_t(void *p) {
      typedef ::TGBI_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TGBI_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TGEO_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TGEO_t : new ::TGEO_t;
   }
   static void *newArray_TGEO_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TGEO_t[nElements] : new ::TGEO_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TGEO_t(void *p) {
      delete ((::TGEO_t*)p);
   }
   static void deleteArray_TGEO_t(void *p) {
      delete [] ((::TGEO_t*)p);
   }
   static void destruct_TGEO_t(void *p) {
      typedef ::TGEO_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TGEO_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TGPB_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TGPB_t : new ::TGPB_t;
   }
   static void *newArray_TGPB_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TGPB_t[nElements] : new ::TGPB_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TGPB_t(void *p) {
      delete ((::TGPB_t*)p);
   }
   static void deleteArray_TGPB_t(void *p) {
      delete [] ((::TGPB_t*)p);
   }
   static void destruct_TGPB_t(void *p) {
      typedef ::TGPB_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TGPB_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TGS_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TGS_t : new ::TGS_t;
   }
   static void *newArray_TGS_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TGS_t[nElements] : new ::TGS_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TGS_t(void *p) {
      delete ((::TGS_t*)p);
   }
   static void deleteArray_TGS_t(void *p) {
      delete [] ((::TGS_t*)p);
   }
   static void destruct_TGS_t(void *p) {
      typedef ::TGS_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TGS_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TGTL_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TGTL_t : new ::TGTL_t;
   }
   static void *newArray_TGTL_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TGTL_t[nElements] : new ::TGTL_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TGTL_t(void *p) {
      delete ((::TGTL_t*)p);
   }
   static void deleteArray_TGTL_t(void *p) {
      delete [] ((::TGTL_t*)p);
   }
   static void destruct_TGTL_t(void *p) {
      typedef ::TGTL_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TGTL_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TGTR_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TGTR_t : new ::TGTR_t;
   }
   static void *newArray_TGTR_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TGTR_t[nElements] : new ::TGTR_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TGTR_t(void *p) {
      delete ((::TGTR_t*)p);
   }
   static void deleteArray_TGTR_t(void *p) {
      delete [] ((::TGTR_t*)p);
   }
   static void destruct_TGTR_t(void *p) {
      typedef ::TGTR_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TGTR_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TLV1_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TLV1_t : new ::TLV1_t;
   }
   static void *newArray_TLV1_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TLV1_t[nElements] : new ::TLV1_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TLV1_t(void *p) {
      delete ((::TLV1_t*)p);
   }
   static void deleteArray_TLV1_t(void *p) {
      delete [] ((::TLV1_t*)p);
   }
   static void destruct_TLV1_t(void *p) {
      typedef ::TLV1_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TLV1_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TRCF_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TRCF_t : new ::TRCF_t;
   }
   static void *newArray_TRCF_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TRCF_t[nElements] : new ::TRCF_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRCF_t(void *p) {
      delete ((::TRCF_t*)p);
   }
   static void deleteArray_TRCF_t(void *p) {
      delete [] ((::TRCF_t*)p);
   }
   static void destruct_TRCF_t(void *p) {
      typedef ::TRCF_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TRCF_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TRGS_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TRGS_t : new ::TRGS_t;
   }
   static void *newArray_TRGS_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TRGS_t[nElements] : new ::TRGS_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRGS_t(void *p) {
      delete ((::TRGS_t*)p);
   }
   static void deleteArray_TRGS_t(void *p) {
      delete [] ((::TRGS_t*)p);
   }
   static void destruct_TRGS_t(void *p) {
      typedef ::TRGS_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TRGS_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TRKS_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TRKS_t : new ::TRKS_t;
   }
   static void *newArray_TRKS_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TRKS_t[nElements] : new ::TRKS_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRKS_t(void *p) {
      delete ((::TRKS_t*)p);
   }
   static void deleteArray_TRKS_t(void *p) {
      delete [] ((::TRKS_t*)p);
   }
   static void destruct_TRKS_t(void *p) {
      typedef ::TRKS_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TRKS_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TRL1_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TRL1_t : new ::TRL1_t;
   }
   static void *newArray_TRL1_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TRL1_t[nElements] : new ::TRL1_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRL1_t(void *p) {
      delete ((::TRL1_t*)p);
   }
   static void deleteArray_TRL1_t(void *p) {
      delete [] ((::TRL1_t*)p);
   }
   static void destruct_TRL1_t(void *p) {
      typedef ::TRL1_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TRL1_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TRPB_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TRPB_t : new ::TRPB_t;
   }
   static void *newArray_TRPB_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TRPB_t[nElements] : new ::TRPB_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRPB_t(void *p) {
      delete ((::TRPB_t*)p);
   }
   static void deleteArray_TRPB_t(void *p) {
      delete [] ((::TRPB_t*)p);
   }
   static void destruct_TRPB_t(void *p) {
      typedef ::TRPB_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TRPB_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TSPR_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TSPR_t : new ::TSPR_t;
   }
   static void *newArray_TSPR_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TSPR_t[nElements] : new ::TSPR_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TSPR_t(void *p) {
      delete ((::TSPR_t*)p);
   }
   static void deleteArray_TSPR_t(void *p) {
      delete [] ((::TSPR_t*)p);
   }
   static void destruct_TSPR_t(void *p) {
      typedef ::TSPR_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TSPR_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_TSRG_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TSRG_t : new ::TSRG_t;
   }
   static void *newArray_TSRG_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TSRG_t[nElements] : new ::TSRG_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_TSRG_t(void *p) {
      delete ((::TSRG_t*)p);
   }
   static void deleteArray_TSRG_t(void *p) {
      delete [] ((::TSRG_t*)p);
   }
   static void destruct_TSRG_t(void *p) {
      typedef ::TSRG_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::TSRG_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_UNUS_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::UNUS_t : new ::UNUS_t;
   }
   static void *newArray_UNUS_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::UNUS_t[nElements] : new ::UNUS_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_UNUS_t(void *p) {
      delete ((::UNUS_t*)p);
   }
   static void deleteArray_UNUS_t(void *p) {
      delete [] ((::UNUS_t*)p);
   }
   static void destruct_UNUS_t(void *p) {
      typedef ::UNUS_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::UNUS_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_VERT_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::VERT_t : new ::VERT_t;
   }
   static void *newArray_VERT_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::VERT_t[nElements] : new ::VERT_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_VERT_t(void *p) {
      delete ((::VERT_t*)p);
   }
   static void deleteArray_VERT_t(void *p) {
      delete [] ((::VERT_t*)p);
   }
   static void destruct_VERT_t(void *p) {
      typedef ::VERT_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::VERT_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_RC26_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RC26_t : new ::RC26_t;
   }
   static void *newArray_RC26_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::RC26_t[nElements] : new ::RC26_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_RC26_t(void *p) {
      delete ((::RC26_t*)p);
   }
   static void deleteArray_RC26_t(void *p) {
      delete [] ((::RC26_t*)p);
   }
   static void destruct_RC26_t(void *p) {
      typedef ::RC26_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::RC26_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_STRE_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STRE_t : new ::STRE_t;
   }
   static void *newArray_STRE_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::STRE_t[nElements] : new ::STRE_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_STRE_t(void *p) {
      delete ((::STRE_t*)p);
   }
   static void deleteArray_STRE_t(void *p) {
      delete [] ((::STRE_t*)p);
   }
   static void destruct_STRE_t(void *p) {
      typedef ::STRE_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::STRE_t

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_addressBanks_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::addressBanks_t : new ::addressBanks_t;
   }
   static void *newArray_addressBanks_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::addressBanks_t[nElements] : new ::addressBanks_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_addressBanks_t(void *p) {
      delete ((::addressBanks_t*)p);
   }
   static void deleteArray_addressBanks_t(void *p) {
      delete [] ((::addressBanks_t*)p);
   }
   static void destruct_addressBanks_t(void *p) {
      typedef ::addressBanks_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::addressBanks_t

/********************************************************
* src/bankvarsDict.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtablebankvarsDict();

extern "C" void G__set_cpp_environmentbankvarsDict() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("include/bankvars.h");
  G__cpp_reset_tagtablebankvarsDict();
}
#include <new>
extern "C" int G__cpp_dllrevbankvarsDict() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* BEAM_t */
// automatic default constructor
static int G__bankvarsDict_168_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   BEAM_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new BEAM_t[n];
     } else {
       p = new((void*) gvp) BEAM_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new BEAM_t;
     } else {
       p = new((void*) gvp) BEAM_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_BEAM_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_168_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   BEAM_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new BEAM_t(*(BEAM_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_BEAM_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef BEAM_t G__TBEAM_t;
static int G__bankvarsDict_168_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (BEAM_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((BEAM_t*) (soff+(sizeof(BEAM_t)*i)))->~G__TBEAM_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (BEAM_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((BEAM_t*) (soff))->~G__TBEAM_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_168_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   BEAM_t* dest = (BEAM_t*) G__getstructoffset();
   *dest = *(BEAM_t*) libp->para[0].ref;
   const BEAM_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* BMPR_t */
// automatic default constructor
static int G__bankvarsDict_169_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   BMPR_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new BMPR_t[n];
     } else {
       p = new((void*) gvp) BMPR_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new BMPR_t;
     } else {
       p = new((void*) gvp) BMPR_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_BMPR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_169_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   BMPR_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new BMPR_t(*(BMPR_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_BMPR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef BMPR_t G__TBMPR_t;
static int G__bankvarsDict_169_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (BMPR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((BMPR_t*) (soff+(sizeof(BMPR_t)*i)))->~G__TBMPR_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (BMPR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((BMPR_t*) (soff))->~G__TBMPR_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_169_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   BMPR_t* dest = (BMPR_t*) G__getstructoffset();
   *dest = *(BMPR_t*) libp->para[0].ref;
   const BMPR_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* BREP_t */
// automatic default constructor
static int G__bankvarsDict_170_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   BREP_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new BREP_t[n];
     } else {
       p = new((void*) gvp) BREP_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new BREP_t;
     } else {
       p = new((void*) gvp) BREP_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_BREP_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_170_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   BREP_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new BREP_t(*(BREP_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_BREP_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef BREP_t G__TBREP_t;
static int G__bankvarsDict_170_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (BREP_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((BREP_t*) (soff+(sizeof(BREP_t)*i)))->~G__TBREP_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (BREP_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((BREP_t*) (soff))->~G__TBREP_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_170_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   BREP_t* dest = (BREP_t*) G__getstructoffset();
   *dest = *(BREP_t*) libp->para[0].ref;
   const BREP_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CALB_t */
// automatic default constructor
static int G__bankvarsDict_171_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CALB_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CALB_t[n];
     } else {
       p = new((void*) gvp) CALB_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CALB_t;
     } else {
       p = new((void*) gvp) CALB_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CALB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_171_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CALB_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CALB_t(*(CALB_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CALB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CALB_t G__TCALB_t;
static int G__bankvarsDict_171_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CALB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CALB_t*) (soff+(sizeof(CALB_t)*i)))->~G__TCALB_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CALB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CALB_t*) (soff))->~G__TCALB_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_171_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CALB_t* dest = (CALB_t*) G__getstructoffset();
   *dest = *(CALB_t*) libp->para[0].ref;
   const CALB_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CALL_t */
// automatic default constructor
static int G__bankvarsDict_172_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CALL_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CALL_t[n];
     } else {
       p = new((void*) gvp) CALL_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CALL_t;
     } else {
       p = new((void*) gvp) CALL_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CALL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_172_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CALL_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CALL_t(*(CALL_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CALL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CALL_t G__TCALL_t;
static int G__bankvarsDict_172_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CALL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CALL_t*) (soff+(sizeof(CALL_t)*i)))->~G__TCALL_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CALL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CALL_t*) (soff))->~G__TCALL_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_172_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CALL_t* dest = (CALL_t*) G__getstructoffset();
   *dest = *(CALL_t*) libp->para[0].ref;
   const CALL_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CC01_t */
// automatic default constructor
static int G__bankvarsDict_173_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CC01_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CC01_t[n];
     } else {
       p = new((void*) gvp) CC01_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CC01_t;
     } else {
       p = new((void*) gvp) CC01_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CC01_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_173_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CC01_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CC01_t(*(CC01_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CC01_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CC01_t G__TCC01_t;
static int G__bankvarsDict_173_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CC01_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CC01_t*) (soff+(sizeof(CC01_t)*i)))->~G__TCC01_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CC01_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CC01_t*) (soff))->~G__TCC01_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_173_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CC01_t* dest = (CC01_t*) G__getstructoffset();
   *dest = *(CC01_t*) libp->para[0].ref;
   const CC01_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CC1_t */
// automatic default constructor
static int G__bankvarsDict_174_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CC1_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CC1_t[n];
     } else {
       p = new((void*) gvp) CC1_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CC1_t;
     } else {
       p = new((void*) gvp) CC1_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CC1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_174_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CC1_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CC1_t(*(CC1_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CC1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CC1_t G__TCC1_t;
static int G__bankvarsDict_174_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CC1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CC1_t*) (soff+(sizeof(CC1_t)*i)))->~G__TCC1_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CC1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CC1_t*) (soff))->~G__TCC1_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_174_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CC1_t* dest = (CC1_t*) G__getstructoffset();
   *dest = *(CC1_t*) libp->para[0].ref;
   const CC1_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CC_t */
// automatic default constructor
static int G__bankvarsDict_175_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CC_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CC_t[n];
     } else {
       p = new((void*) gvp) CC_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CC_t;
     } else {
       p = new((void*) gvp) CC_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_175_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CC_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CC_t(*(CC_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CC_t G__TCC_t;
static int G__bankvarsDict_175_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CC_t*) (soff+(sizeof(CC_t)*i)))->~G__TCC_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CC_t*) (soff))->~G__TCC_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_175_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CC_t* dest = (CC_t*) G__getstructoffset();
   *dest = *(CC_t*) libp->para[0].ref;
   const CC_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CCDI_t */
// automatic default constructor
static int G__bankvarsDict_176_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CCDI_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CCDI_t[n];
     } else {
       p = new((void*) gvp) CCDI_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CCDI_t;
     } else {
       p = new((void*) gvp) CCDI_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CCDI_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_176_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CCDI_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CCDI_t(*(CCDI_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CCDI_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CCDI_t G__TCCDI_t;
static int G__bankvarsDict_176_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CCDI_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CCDI_t*) (soff+(sizeof(CCDI_t)*i)))->~G__TCCDI_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CCDI_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CCDI_t*) (soff))->~G__TCCDI_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_176_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CCDI_t* dest = (CCDI_t*) G__getstructoffset();
   *dest = *(CCDI_t*) libp->para[0].ref;
   const CCDI_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CCH_t */
// automatic default constructor
static int G__bankvarsDict_177_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CCH_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CCH_t[n];
     } else {
       p = new((void*) gvp) CCH_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CCH_t;
     } else {
       p = new((void*) gvp) CCH_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CCH_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_177_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CCH_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CCH_t(*(CCH_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CCH_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CCH_t G__TCCH_t;
static int G__bankvarsDict_177_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CCH_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CCH_t*) (soff+(sizeof(CCH_t)*i)))->~G__TCCH_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CCH_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CCH_t*) (soff))->~G__TCCH_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_177_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CCH_t* dest = (CCH_t*) G__getstructoffset();
   *dest = *(CCH_t*) libp->para[0].ref;
   const CCH_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CCMT_t */
// automatic default constructor
static int G__bankvarsDict_178_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CCMT_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CCMT_t[n];
     } else {
       p = new((void*) gvp) CCMT_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CCMT_t;
     } else {
       p = new((void*) gvp) CCMT_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CCMT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_178_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CCMT_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CCMT_t(*(CCMT_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CCMT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CCMT_t G__TCCMT_t;
static int G__bankvarsDict_178_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CCMT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CCMT_t*) (soff+(sizeof(CCMT_t)*i)))->~G__TCCMT_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CCMT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CCMT_t*) (soff))->~G__TCCMT_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_178_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CCMT_t* dest = (CCMT_t*) G__getstructoffset();
   *dest = *(CCMT_t*) libp->para[0].ref;
   const CCMT_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CCPB_t */
// automatic default constructor
static int G__bankvarsDict_179_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CCPB_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CCPB_t[n];
     } else {
       p = new((void*) gvp) CCPB_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CCPB_t;
     } else {
       p = new((void*) gvp) CCPB_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CCPB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_179_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CCPB_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CCPB_t(*(CCPB_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CCPB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CCPB_t G__TCCPB_t;
static int G__bankvarsDict_179_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CCPB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CCPB_t*) (soff+(sizeof(CCPB_t)*i)))->~G__TCCPB_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CCPB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CCPB_t*) (soff))->~G__TCCPB_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_179_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CCPB_t* dest = (CCPB_t*) G__getstructoffset();
   *dest = *(CCPB_t*) libp->para[0].ref;
   const CCPB_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CCPE_t */
// automatic default constructor
static int G__bankvarsDict_180_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CCPE_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CCPE_t[n];
     } else {
       p = new((void*) gvp) CCPE_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CCPE_t;
     } else {
       p = new((void*) gvp) CCPE_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CCPE_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_180_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CCPE_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CCPE_t(*(CCPE_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CCPE_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CCPE_t G__TCCPE_t;
static int G__bankvarsDict_180_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CCPE_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CCPE_t*) (soff+(sizeof(CCPE_t)*i)))->~G__TCCPE_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CCPE_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CCPE_t*) (soff))->~G__TCCPE_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_180_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CCPE_t* dest = (CCPE_t*) G__getstructoffset();
   *dest = *(CCPE_t*) libp->para[0].ref;
   const CCPE_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CCRC_t */
// automatic default constructor
static int G__bankvarsDict_181_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CCRC_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CCRC_t[n];
     } else {
       p = new((void*) gvp) CCRC_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CCRC_t;
     } else {
       p = new((void*) gvp) CCRC_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CCRC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_181_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CCRC_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CCRC_t(*(CCRC_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CCRC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CCRC_t G__TCCRC_t;
static int G__bankvarsDict_181_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CCRC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CCRC_t*) (soff+(sizeof(CCRC_t)*i)))->~G__TCCRC_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CCRC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CCRC_t*) (soff))->~G__TCCRC_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_181_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CCRC_t* dest = (CCRC_t*) G__getstructoffset();
   *dest = *(CCRC_t*) libp->para[0].ref;
   const CCRC_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CCS_t */
// automatic default constructor
static int G__bankvarsDict_182_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CCS_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CCS_t[n];
     } else {
       p = new((void*) gvp) CCS_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CCS_t;
     } else {
       p = new((void*) gvp) CCS_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CCS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_182_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CCS_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CCS_t(*(CCS_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CCS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CCS_t G__TCCS_t;
static int G__bankvarsDict_182_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CCS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CCS_t*) (soff+(sizeof(CCS_t)*i)))->~G__TCCS_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CCS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CCS_t*) (soff))->~G__TCCS_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_182_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CCS_t* dest = (CCS_t*) G__getstructoffset();
   *dest = *(CCS_t*) libp->para[0].ref;
   const CCS_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CCT_t */
// automatic default constructor
static int G__bankvarsDict_183_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CCT_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CCT_t[n];
     } else {
       p = new((void*) gvp) CCT_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CCT_t;
     } else {
       p = new((void*) gvp) CCT_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CCT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_183_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CCT_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CCT_t(*(CCT_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CCT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CCT_t G__TCCT_t;
static int G__bankvarsDict_183_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CCT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CCT_t*) (soff+(sizeof(CCT_t)*i)))->~G__TCCT_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CCT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CCT_t*) (soff))->~G__TCCT_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_183_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CCT_t* dest = (CCT_t*) G__getstructoffset();
   *dest = *(CCT_t*) libp->para[0].ref;
   const CCT_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CHI2_t */
// automatic default constructor
static int G__bankvarsDict_184_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CHI2_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CHI2_t[n];
     } else {
       p = new((void*) gvp) CHI2_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CHI2_t;
     } else {
       p = new((void*) gvp) CHI2_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CHI2_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_184_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CHI2_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CHI2_t(*(CHI2_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CHI2_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CHI2_t G__TCHI2_t;
static int G__bankvarsDict_184_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CHI2_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CHI2_t*) (soff+(sizeof(CHI2_t)*i)))->~G__TCHI2_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CHI2_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CHI2_t*) (soff))->~G__TCHI2_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_184_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CHI2_t* dest = (CHI2_t*) G__getstructoffset();
   *dest = *(CHI2_t*) libp->para[0].ref;
   const CHI2_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CL01_t */
// automatic default constructor
static int G__bankvarsDict_185_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CL01_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CL01_t[n];
     } else {
       p = new((void*) gvp) CL01_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CL01_t;
     } else {
       p = new((void*) gvp) CL01_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CL01_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_185_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CL01_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CL01_t(*(CL01_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CL01_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CL01_t G__TCL01_t;
static int G__bankvarsDict_185_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CL01_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CL01_t*) (soff+(sizeof(CL01_t)*i)))->~G__TCL01_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CL01_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CL01_t*) (soff))->~G__TCL01_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_185_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CL01_t* dest = (CL01_t*) G__getstructoffset();
   *dest = *(CL01_t*) libp->para[0].ref;
   const CL01_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CLST_t */
// automatic default constructor
static int G__bankvarsDict_186_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CLST_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CLST_t[n];
     } else {
       p = new((void*) gvp) CLST_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CLST_t;
     } else {
       p = new((void*) gvp) CLST_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CLST_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_186_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CLST_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CLST_t(*(CLST_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CLST_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CLST_t G__TCLST_t;
static int G__bankvarsDict_186_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CLST_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CLST_t*) (soff+(sizeof(CLST_t)*i)))->~G__TCLST_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CLST_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CLST_t*) (soff))->~G__TCLST_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_186_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CLST_t* dest = (CLST_t*) G__getstructoffset();
   *dest = *(CLST_t*) libp->para[0].ref;
   const CLST_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CPED_t */
// automatic default constructor
static int G__bankvarsDict_187_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CPED_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CPED_t[n];
     } else {
       p = new((void*) gvp) CPED_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CPED_t;
     } else {
       p = new((void*) gvp) CPED_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CPED_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_187_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CPED_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CPED_t(*(CPED_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CPED_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CPED_t G__TCPED_t;
static int G__bankvarsDict_187_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CPED_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CPED_t*) (soff+(sizeof(CPED_t)*i)))->~G__TCPED_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CPED_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CPED_t*) (soff))->~G__TCPED_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_187_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CPED_t* dest = (CPED_t*) G__getstructoffset();
   *dest = *(CPED_t*) libp->para[0].ref;
   const CPED_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* CSQL_t */
// automatic default constructor
static int G__bankvarsDict_188_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CSQL_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CSQL_t[n];
     } else {
       p = new((void*) gvp) CSQL_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new CSQL_t;
     } else {
       p = new((void*) gvp) CSQL_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CSQL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_188_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   CSQL_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new CSQL_t(*(CSQL_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_CSQL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef CSQL_t G__TCSQL_t;
static int G__bankvarsDict_188_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (CSQL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((CSQL_t*) (soff+(sizeof(CSQL_t)*i)))->~G__TCSQL_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (CSQL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((CSQL_t*) (soff))->~G__TCSQL_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_188_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   CSQL_t* dest = (CSQL_t*) G__getstructoffset();
   *dest = *(CSQL_t*) libp->para[0].ref;
   const CSQL_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DC0_t */
// automatic default constructor
static int G__bankvarsDict_189_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DC0_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DC0_t[n];
     } else {
       p = new((void*) gvp) DC0_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DC0_t;
     } else {
       p = new((void*) gvp) DC0_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DC0_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_189_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DC0_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DC0_t(*(DC0_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DC0_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DC0_t G__TDC0_t;
static int G__bankvarsDict_189_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DC0_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DC0_t*) (soff+(sizeof(DC0_t)*i)))->~G__TDC0_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DC0_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DC0_t*) (soff))->~G__TDC0_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_189_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DC0_t* dest = (DC0_t*) G__getstructoffset();
   *dest = *(DC0_t*) libp->para[0].ref;
   const DC0_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DC1_t */
// automatic default constructor
static int G__bankvarsDict_190_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DC1_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DC1_t[n];
     } else {
       p = new((void*) gvp) DC1_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DC1_t;
     } else {
       p = new((void*) gvp) DC1_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DC1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_190_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DC1_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DC1_t(*(DC1_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DC1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DC1_t G__TDC1_t;
static int G__bankvarsDict_190_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DC1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DC1_t*) (soff+(sizeof(DC1_t)*i)))->~G__TDC1_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DC1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DC1_t*) (soff))->~G__TDC1_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_190_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DC1_t* dest = (DC1_t*) G__getstructoffset();
   *dest = *(DC1_t*) libp->para[0].ref;
   const DC1_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DCDW_t */
// automatic default constructor
static int G__bankvarsDict_191_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCDW_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCDW_t[n];
     } else {
       p = new((void*) gvp) DCDW_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCDW_t;
     } else {
       p = new((void*) gvp) DCDW_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCDW_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_191_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DCDW_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DCDW_t(*(DCDW_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCDW_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DCDW_t G__TDCDW_t;
static int G__bankvarsDict_191_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DCDW_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DCDW_t*) (soff+(sizeof(DCDW_t)*i)))->~G__TDCDW_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DCDW_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DCDW_t*) (soff))->~G__TDCDW_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_191_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCDW_t* dest = (DCDW_t*) G__getstructoffset();
   *dest = *(DCDW_t*) libp->para[0].ref;
   const DCDW_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DCGM_t */
// automatic default constructor
static int G__bankvarsDict_192_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCGM_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCGM_t[n];
     } else {
       p = new((void*) gvp) DCGM_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCGM_t;
     } else {
       p = new((void*) gvp) DCGM_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCGM_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_192_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DCGM_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DCGM_t(*(DCGM_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCGM_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DCGM_t G__TDCGM_t;
static int G__bankvarsDict_192_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DCGM_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DCGM_t*) (soff+(sizeof(DCGM_t)*i)))->~G__TDCGM_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DCGM_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DCGM_t*) (soff))->~G__TDCGM_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_192_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCGM_t* dest = (DCGM_t*) G__getstructoffset();
   *dest = *(DCGM_t*) libp->para[0].ref;
   const DCGM_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DCGW_t */
// automatic default constructor
static int G__bankvarsDict_193_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCGW_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCGW_t[n];
     } else {
       p = new((void*) gvp) DCGW_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCGW_t;
     } else {
       p = new((void*) gvp) DCGW_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCGW_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_193_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DCGW_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DCGW_t(*(DCGW_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCGW_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DCGW_t G__TDCGW_t;
static int G__bankvarsDict_193_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DCGW_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DCGW_t*) (soff+(sizeof(DCGW_t)*i)))->~G__TDCGW_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DCGW_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DCGW_t*) (soff))->~G__TDCGW_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_193_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCGW_t* dest = (DCGW_t*) G__getstructoffset();
   *dest = *(DCGW_t*) libp->para[0].ref;
   const DCGW_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DCH_t */
// automatic default constructor
static int G__bankvarsDict_194_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCH_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCH_t[n];
     } else {
       p = new((void*) gvp) DCH_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCH_t;
     } else {
       p = new((void*) gvp) DCH_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCH_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_194_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DCH_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DCH_t(*(DCH_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCH_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DCH_t G__TDCH_t;
static int G__bankvarsDict_194_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DCH_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DCH_t*) (soff+(sizeof(DCH_t)*i)))->~G__TDCH_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DCH_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DCH_t*) (soff))->~G__TDCH_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_194_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCH_t* dest = (DCH_t*) G__getstructoffset();
   *dest = *(DCH_t*) libp->para[0].ref;
   const DCH_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DCMN_t */
// automatic default constructor
static int G__bankvarsDict_195_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCMN_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCMN_t[n];
     } else {
       p = new((void*) gvp) DCMN_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCMN_t;
     } else {
       p = new((void*) gvp) DCMN_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCMN_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_195_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DCMN_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DCMN_t(*(DCMN_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCMN_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DCMN_t G__TDCMN_t;
static int G__bankvarsDict_195_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DCMN_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DCMN_t*) (soff+(sizeof(DCMN_t)*i)))->~G__TDCMN_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DCMN_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DCMN_t*) (soff))->~G__TDCMN_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_195_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCMN_t* dest = (DCMN_t*) G__getstructoffset();
   *dest = *(DCMN_t*) libp->para[0].ref;
   const DCMN_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DCPB_t */
// automatic default constructor
static int G__bankvarsDict_196_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCPB_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCPB_t[n];
     } else {
       p = new((void*) gvp) DCPB_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCPB_t;
     } else {
       p = new((void*) gvp) DCPB_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCPB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_196_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DCPB_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DCPB_t(*(DCPB_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCPB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DCPB_t G__TDCPB_t;
static int G__bankvarsDict_196_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DCPB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DCPB_t*) (soff+(sizeof(DCPB_t)*i)))->~G__TDCPB_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DCPB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DCPB_t*) (soff))->~G__TDCPB_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_196_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCPB_t* dest = (DCPB_t*) G__getstructoffset();
   *dest = *(DCPB_t*) libp->para[0].ref;
   const DCPB_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DCV1_t */
// automatic default constructor
static int G__bankvarsDict_197_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCV1_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCV1_t[n];
     } else {
       p = new((void*) gvp) DCV1_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCV1_t;
     } else {
       p = new((void*) gvp) DCV1_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCV1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_197_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DCV1_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DCV1_t(*(DCV1_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCV1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DCV1_t G__TDCV1_t;
static int G__bankvarsDict_197_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DCV1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DCV1_t*) (soff+(sizeof(DCV1_t)*i)))->~G__TDCV1_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DCV1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DCV1_t*) (soff))->~G__TDCV1_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_197_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCV1_t* dest = (DCV1_t*) G__getstructoffset();
   *dest = *(DCV1_t*) libp->para[0].ref;
   const DCV1_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DCV2_t */
// automatic default constructor
static int G__bankvarsDict_198_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCV2_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCV2_t[n];
     } else {
       p = new((void*) gvp) DCV2_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCV2_t;
     } else {
       p = new((void*) gvp) DCV2_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCV2_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_198_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DCV2_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DCV2_t(*(DCV2_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCV2_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DCV2_t G__TDCV2_t;
static int G__bankvarsDict_198_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DCV2_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DCV2_t*) (soff+(sizeof(DCV2_t)*i)))->~G__TDCV2_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DCV2_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DCV2_t*) (soff))->~G__TDCV2_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_198_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCV2_t* dest = (DCV2_t*) G__getstructoffset();
   *dest = *(DCV2_t*) libp->para[0].ref;
   const DCV2_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DCV3_t */
// automatic default constructor
static int G__bankvarsDict_199_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCV3_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCV3_t[n];
     } else {
       p = new((void*) gvp) DCV3_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DCV3_t;
     } else {
       p = new((void*) gvp) DCV3_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCV3_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_199_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DCV3_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DCV3_t(*(DCV3_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DCV3_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DCV3_t G__TDCV3_t;
static int G__bankvarsDict_199_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DCV3_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DCV3_t*) (soff+(sizeof(DCV3_t)*i)))->~G__TDCV3_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DCV3_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DCV3_t*) (soff))->~G__TDCV3_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_199_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DCV3_t* dest = (DCV3_t*) G__getstructoffset();
   *dest = *(DCV3_t*) libp->para[0].ref;
   const DCV3_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DDLY_t */
// automatic default constructor
static int G__bankvarsDict_200_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DDLY_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DDLY_t[n];
     } else {
       p = new((void*) gvp) DDLY_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DDLY_t;
     } else {
       p = new((void*) gvp) DDLY_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DDLY_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_200_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DDLY_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DDLY_t(*(DDLY_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DDLY_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DDLY_t G__TDDLY_t;
static int G__bankvarsDict_200_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DDLY_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DDLY_t*) (soff+(sizeof(DDLY_t)*i)))->~G__TDDLY_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DDLY_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DDLY_t*) (soff))->~G__TDDLY_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_200_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DDLY_t* dest = (DDLY_t*) G__getstructoffset();
   *dest = *(DDLY_t*) libp->para[0].ref;
   const DDLY_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DGEO_t */
// automatic default constructor
static int G__bankvarsDict_201_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DGEO_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DGEO_t[n];
     } else {
       p = new((void*) gvp) DGEO_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DGEO_t;
     } else {
       p = new((void*) gvp) DGEO_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DGEO_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_201_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DGEO_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DGEO_t(*(DGEO_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DGEO_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DGEO_t G__TDGEO_t;
static int G__bankvarsDict_201_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DGEO_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DGEO_t*) (soff+(sizeof(DGEO_t)*i)))->~G__TDGEO_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DGEO_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DGEO_t*) (soff))->~G__TDGEO_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_201_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DGEO_t* dest = (DGEO_t*) G__getstructoffset();
   *dest = *(DGEO_t*) libp->para[0].ref;
   const DGEO_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DHCL_t */
// automatic default constructor
static int G__bankvarsDict_202_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DHCL_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DHCL_t[n];
     } else {
       p = new((void*) gvp) DHCL_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DHCL_t;
     } else {
       p = new((void*) gvp) DHCL_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DHCL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_202_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DHCL_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DHCL_t(*(DHCL_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DHCL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DHCL_t G__TDHCL_t;
static int G__bankvarsDict_202_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DHCL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DHCL_t*) (soff+(sizeof(DHCL_t)*i)))->~G__TDHCL_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DHCL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DHCL_t*) (soff))->~G__TDHCL_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_202_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DHCL_t* dest = (DHCL_t*) G__getstructoffset();
   *dest = *(DHCL_t*) libp->para[0].ref;
   const DHCL_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DITM_t */
// automatic default constructor
static int G__bankvarsDict_203_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DITM_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DITM_t[n];
     } else {
       p = new((void*) gvp) DITM_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DITM_t;
     } else {
       p = new((void*) gvp) DITM_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DITM_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_203_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DITM_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DITM_t(*(DITM_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DITM_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DITM_t G__TDITM_t;
static int G__bankvarsDict_203_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DITM_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DITM_t*) (soff+(sizeof(DITM_t)*i)))->~G__TDITM_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DITM_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DITM_t*) (soff))->~G__TDITM_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_203_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DITM_t* dest = (DITM_t*) G__getstructoffset();
   *dest = *(DITM_t*) libp->para[0].ref;
   const DITM_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DOCA_t */
// automatic default constructor
static int G__bankvarsDict_204_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DOCA_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DOCA_t[n];
     } else {
       p = new((void*) gvp) DOCA_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DOCA_t;
     } else {
       p = new((void*) gvp) DOCA_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DOCA_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_204_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DOCA_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DOCA_t(*(DOCA_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DOCA_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DOCA_t G__TDOCA_t;
static int G__bankvarsDict_204_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DOCA_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DOCA_t*) (soff+(sizeof(DOCA_t)*i)))->~G__TDOCA_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DOCA_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DOCA_t*) (soff))->~G__TDOCA_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_204_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DOCA_t* dest = (DOCA_t*) G__getstructoffset();
   *dest = *(DOCA_t*) libp->para[0].ref;
   const DOCA_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DPCP_t */
// automatic default constructor
static int G__bankvarsDict_205_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DPCP_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DPCP_t[n];
     } else {
       p = new((void*) gvp) DPCP_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DPCP_t;
     } else {
       p = new((void*) gvp) DPCP_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DPCP_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_205_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DPCP_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DPCP_t(*(DPCP_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DPCP_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DPCP_t G__TDPCP_t;
static int G__bankvarsDict_205_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DPCP_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DPCP_t*) (soff+(sizeof(DPCP_t)*i)))->~G__TDPCP_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DPCP_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DPCP_t*) (soff))->~G__TDPCP_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_205_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DPCP_t* dest = (DPCP_t*) G__getstructoffset();
   *dest = *(DPCP_t*) libp->para[0].ref;
   const DPCP_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DPSP_t */
// automatic default constructor
static int G__bankvarsDict_206_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DPSP_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DPSP_t[n];
     } else {
       p = new((void*) gvp) DPSP_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DPSP_t;
     } else {
       p = new((void*) gvp) DPSP_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DPSP_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_206_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DPSP_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DPSP_t(*(DPSP_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DPSP_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DPSP_t G__TDPSP_t;
static int G__bankvarsDict_206_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DPSP_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DPSP_t*) (soff+(sizeof(DPSP_t)*i)))->~G__TDPSP_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DPSP_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DPSP_t*) (soff))->~G__TDPSP_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_206_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DPSP_t* dest = (DPSP_t*) G__getstructoffset();
   *dest = *(DPSP_t*) libp->para[0].ref;
   const DPSP_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DSPC_t */
// automatic default constructor
static int G__bankvarsDict_207_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DSPC_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DSPC_t[n];
     } else {
       p = new((void*) gvp) DSPC_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DSPC_t;
     } else {
       p = new((void*) gvp) DSPC_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DSPC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_207_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DSPC_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DSPC_t(*(DSPC_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DSPC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DSPC_t G__TDSPC_t;
static int G__bankvarsDict_207_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DSPC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DSPC_t*) (soff+(sizeof(DSPC_t)*i)))->~G__TDSPC_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DSPC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DSPC_t*) (soff))->~G__TDSPC_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_207_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DSPC_t* dest = (DSPC_t*) G__getstructoffset();
   *dest = *(DSPC_t*) libp->para[0].ref;
   const DSPC_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DSPS_t */
// automatic default constructor
static int G__bankvarsDict_208_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DSPS_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DSPS_t[n];
     } else {
       p = new((void*) gvp) DSPS_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DSPS_t;
     } else {
       p = new((void*) gvp) DSPS_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DSPS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_208_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DSPS_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DSPS_t(*(DSPS_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DSPS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DSPS_t G__TDSPS_t;
static int G__bankvarsDict_208_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DSPS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DSPS_t*) (soff+(sizeof(DSPS_t)*i)))->~G__TDSPS_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DSPS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DSPS_t*) (soff))->~G__TDSPS_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_208_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DSPS_t* dest = (DSPS_t*) G__getstructoffset();
   *dest = *(DSPS_t*) libp->para[0].ref;
   const DSPS_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DSTC_t */
// automatic default constructor
static int G__bankvarsDict_209_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DSTC_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DSTC_t[n];
     } else {
       p = new((void*) gvp) DSTC_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DSTC_t;
     } else {
       p = new((void*) gvp) DSTC_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DSTC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_209_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DSTC_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DSTC_t(*(DSTC_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DSTC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DSTC_t G__TDSTC_t;
static int G__bankvarsDict_209_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DSTC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DSTC_t*) (soff+(sizeof(DSTC_t)*i)))->~G__TDSTC_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DSTC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DSTC_t*) (soff))->~G__TDSTC_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_209_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DSTC_t* dest = (DSTC_t*) G__getstructoffset();
   *dest = *(DSTC_t*) libp->para[0].ref;
   const DSTC_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DTCP_t */
// automatic default constructor
static int G__bankvarsDict_210_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DTCP_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DTCP_t[n];
     } else {
       p = new((void*) gvp) DTCP_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DTCP_t;
     } else {
       p = new((void*) gvp) DTCP_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DTCP_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_210_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DTCP_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DTCP_t(*(DTCP_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DTCP_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DTCP_t G__TDTCP_t;
static int G__bankvarsDict_210_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DTCP_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DTCP_t*) (soff+(sizeof(DTCP_t)*i)))->~G__TDTCP_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DTCP_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DTCP_t*) (soff))->~G__TDTCP_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_210_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DTCP_t* dest = (DTCP_t*) G__getstructoffset();
   *dest = *(DTCP_t*) libp->para[0].ref;
   const DTCP_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DTRK_t */
// automatic default constructor
static int G__bankvarsDict_211_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DTRK_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DTRK_t[n];
     } else {
       p = new((void*) gvp) DTRK_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DTRK_t;
     } else {
       p = new((void*) gvp) DTRK_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DTRK_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_211_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DTRK_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DTRK_t(*(DTRK_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_DTRK_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DTRK_t G__TDTRK_t;
static int G__bankvarsDict_211_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DTRK_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DTRK_t*) (soff+(sizeof(DTRK_t)*i)))->~G__TDTRK_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DTRK_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DTRK_t*) (soff))->~G__TDTRK_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_211_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DTRK_t* dest = (DTRK_t*) G__getstructoffset();
   *dest = *(DTRK_t*) libp->para[0].ref;
   const DTRK_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* EC01_t */
// automatic default constructor
static int G__bankvarsDict_212_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EC01_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EC01_t[n];
     } else {
       p = new((void*) gvp) EC01_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EC01_t;
     } else {
       p = new((void*) gvp) EC01_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_EC01_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_212_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   EC01_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new EC01_t(*(EC01_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_EC01_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef EC01_t G__TEC01_t;
static int G__bankvarsDict_212_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (EC01_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((EC01_t*) (soff+(sizeof(EC01_t)*i)))->~G__TEC01_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (EC01_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((EC01_t*) (soff))->~G__TEC01_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_212_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EC01_t* dest = (EC01_t*) G__getstructoffset();
   *dest = *(EC01_t*) libp->para[0].ref;
   const EC01_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* EC1_t */
// automatic default constructor
static int G__bankvarsDict_213_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EC1_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EC1_t[n];
     } else {
       p = new((void*) gvp) EC1_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EC1_t;
     } else {
       p = new((void*) gvp) EC1_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_EC1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_213_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   EC1_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new EC1_t(*(EC1_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_EC1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef EC1_t G__TEC1_t;
static int G__bankvarsDict_213_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (EC1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((EC1_t*) (soff+(sizeof(EC1_t)*i)))->~G__TEC1_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (EC1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((EC1_t*) (soff))->~G__TEC1_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_213_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EC1_t* dest = (EC1_t*) G__getstructoffset();
   *dest = *(EC1_t*) libp->para[0].ref;
   const EC1_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* EC1P_t */
// automatic default constructor
static int G__bankvarsDict_214_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EC1P_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EC1P_t[n];
     } else {
       p = new((void*) gvp) EC1P_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EC1P_t;
     } else {
       p = new((void*) gvp) EC1P_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_EC1P_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_214_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   EC1P_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new EC1P_t(*(EC1P_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_EC1P_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef EC1P_t G__TEC1P_t;
static int G__bankvarsDict_214_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (EC1P_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((EC1P_t*) (soff+(sizeof(EC1P_t)*i)))->~G__TEC1P_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (EC1P_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((EC1P_t*) (soff))->~G__TEC1P_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_214_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EC1P_t* dest = (EC1P_t*) G__getstructoffset();
   *dest = *(EC1P_t*) libp->para[0].ref;
   const EC1P_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* EC1R_t */
// automatic default constructor
static int G__bankvarsDict_215_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EC1R_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EC1R_t[n];
     } else {
       p = new((void*) gvp) EC1R_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EC1R_t;
     } else {
       p = new((void*) gvp) EC1R_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_EC1R_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_215_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   EC1R_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new EC1R_t(*(EC1R_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_EC1R_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef EC1R_t G__TEC1R_t;
static int G__bankvarsDict_215_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (EC1R_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((EC1R_t*) (soff+(sizeof(EC1R_t)*i)))->~G__TEC1R_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (EC1R_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((EC1R_t*) (soff))->~G__TEC1R_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_215_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EC1R_t* dest = (EC1R_t*) G__getstructoffset();
   *dest = *(EC1R_t*) libp->para[0].ref;
   const EC1R_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECCA_t */
// automatic default constructor
static int G__bankvarsDict_216_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECCA_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECCA_t[n];
     } else {
       p = new((void*) gvp) ECCA_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECCA_t;
     } else {
       p = new((void*) gvp) ECCA_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECCA_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_216_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECCA_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECCA_t(*(ECCA_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECCA_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECCA_t G__TECCA_t;
static int G__bankvarsDict_216_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECCA_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECCA_t*) (soff+(sizeof(ECCA_t)*i)))->~G__TECCA_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECCA_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECCA_t*) (soff))->~G__TECCA_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_216_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECCA_t* dest = (ECCA_t*) G__getstructoffset();
   *dest = *(ECCA_t*) libp->para[0].ref;
   const ECCA_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECCL_t */
// automatic default constructor
static int G__bankvarsDict_217_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECCL_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECCL_t[n];
     } else {
       p = new((void*) gvp) ECCL_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECCL_t;
     } else {
       p = new((void*) gvp) ECCL_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECCL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_217_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECCL_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECCL_t(*(ECCL_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECCL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECCL_t G__TECCL_t;
static int G__bankvarsDict_217_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECCL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECCL_t*) (soff+(sizeof(ECCL_t)*i)))->~G__TECCL_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECCL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECCL_t*) (soff))->~G__TECCL_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_217_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECCL_t* dest = (ECCL_t*) G__getstructoffset();
   *dest = *(ECCL_t*) libp->para[0].ref;
   const ECCL_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECCT_t */
// automatic default constructor
static int G__bankvarsDict_218_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECCT_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECCT_t[n];
     } else {
       p = new((void*) gvp) ECCT_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECCT_t;
     } else {
       p = new((void*) gvp) ECCT_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECCT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_218_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECCT_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECCT_t(*(ECCT_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECCT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECCT_t G__TECCT_t;
static int G__bankvarsDict_218_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECCT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECCT_t*) (soff+(sizeof(ECCT_t)*i)))->~G__TECCT_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECCT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECCT_t*) (soff))->~G__TECCT_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_218_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECCT_t* dest = (ECCT_t*) G__getstructoffset();
   *dest = *(ECCT_t*) libp->para[0].ref;
   const ECCT_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* EC_t */
// automatic default constructor
static int G__bankvarsDict_219_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EC_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EC_t[n];
     } else {
       p = new((void*) gvp) EC_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EC_t;
     } else {
       p = new((void*) gvp) EC_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_EC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_219_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   EC_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new EC_t(*(EC_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_EC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef EC_t G__TEC_t;
static int G__bankvarsDict_219_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (EC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((EC_t*) (soff+(sizeof(EC_t)*i)))->~G__TEC_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (EC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((EC_t*) (soff))->~G__TEC_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_219_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EC_t* dest = (EC_t*) G__getstructoffset();
   *dest = *(EC_t*) libp->para[0].ref;
   const EC_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECDI_t */
// automatic default constructor
static int G__bankvarsDict_220_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECDI_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECDI_t[n];
     } else {
       p = new((void*) gvp) ECDI_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECDI_t;
     } else {
       p = new((void*) gvp) ECDI_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECDI_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_220_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECDI_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECDI_t(*(ECDI_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECDI_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECDI_t G__TECDI_t;
static int G__bankvarsDict_220_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECDI_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECDI_t*) (soff+(sizeof(ECDI_t)*i)))->~G__TECDI_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECDI_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECDI_t*) (soff))->~G__TECDI_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_220_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECDI_t* dest = (ECDI_t*) G__getstructoffset();
   *dest = *(ECDI_t*) libp->para[0].ref;
   const ECDI_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECG_t */
// automatic default constructor
static int G__bankvarsDict_221_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECG_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECG_t[n];
     } else {
       p = new((void*) gvp) ECG_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECG_t;
     } else {
       p = new((void*) gvp) ECG_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECG_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_221_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECG_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECG_t(*(ECG_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECG_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECG_t G__TECG_t;
static int G__bankvarsDict_221_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECG_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECG_t*) (soff+(sizeof(ECG_t)*i)))->~G__TECG_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECG_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECG_t*) (soff))->~G__TECG_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_221_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECG_t* dest = (ECG_t*) G__getstructoffset();
   *dest = *(ECG_t*) libp->para[0].ref;
   const ECG_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECHB_t */
// automatic default constructor
static int G__bankvarsDict_222_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECHB_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECHB_t[n];
     } else {
       p = new((void*) gvp) ECHB_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECHB_t;
     } else {
       p = new((void*) gvp) ECHB_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECHB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_222_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECHB_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECHB_t(*(ECHB_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECHB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECHB_t G__TECHB_t;
static int G__bankvarsDict_222_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECHB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECHB_t*) (soff+(sizeof(ECHB_t)*i)))->~G__TECHB_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECHB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECHB_t*) (soff))->~G__TECHB_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_222_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECHB_t* dest = (ECHB_t*) G__getstructoffset();
   *dest = *(ECHB_t*) libp->para[0].ref;
   const ECHB_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECH_t */
// automatic default constructor
static int G__bankvarsDict_223_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECH_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECH_t[n];
     } else {
       p = new((void*) gvp) ECH_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECH_t;
     } else {
       p = new((void*) gvp) ECH_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECH_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_223_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECH_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECH_t(*(ECH_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECH_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECH_t G__TECH_t;
static int G__bankvarsDict_223_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECH_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECH_t*) (soff+(sizeof(ECH_t)*i)))->~G__TECH_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECH_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECH_t*) (soff))->~G__TECH_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_223_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECH_t* dest = (ECH_t*) G__getstructoffset();
   *dest = *(ECH_t*) libp->para[0].ref;
   const ECH_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECMT_t */
// automatic default constructor
static int G__bankvarsDict_224_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECMT_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECMT_t[n];
     } else {
       p = new((void*) gvp) ECMT_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECMT_t;
     } else {
       p = new((void*) gvp) ECMT_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECMT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_224_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECMT_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECMT_t(*(ECMT_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECMT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECMT_t G__TECMT_t;
static int G__bankvarsDict_224_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECMT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECMT_t*) (soff+(sizeof(ECMT_t)*i)))->~G__TECMT_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECMT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECMT_t*) (soff))->~G__TECMT_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_224_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECMT_t* dest = (ECMT_t*) G__getstructoffset();
   *dest = *(ECMT_t*) libp->para[0].ref;
   const ECMT_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECP1_t */
// automatic default constructor
static int G__bankvarsDict_225_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECP1_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECP1_t[n];
     } else {
       p = new((void*) gvp) ECP1_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECP1_t;
     } else {
       p = new((void*) gvp) ECP1_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECP1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_225_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECP1_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECP1_t(*(ECP1_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECP1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECP1_t G__TECP1_t;
static int G__bankvarsDict_225_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECP1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECP1_t*) (soff+(sizeof(ECP1_t)*i)))->~G__TECP1_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECP1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECP1_t*) (soff))->~G__TECP1_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_225_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECP1_t* dest = (ECP1_t*) G__getstructoffset();
   *dest = *(ECP1_t*) libp->para[0].ref;
   const ECP1_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECPB_t */
// automatic default constructor
static int G__bankvarsDict_226_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECPB_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECPB_t[n];
     } else {
       p = new((void*) gvp) ECPB_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECPB_t;
     } else {
       p = new((void*) gvp) ECPB_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECPB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_226_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECPB_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECPB_t(*(ECPB_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECPB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECPB_t G__TECPB_t;
static int G__bankvarsDict_226_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECPB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECPB_t*) (soff+(sizeof(ECPB_t)*i)))->~G__TECPB_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECPB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECPB_t*) (soff))->~G__TECPB_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_226_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECPB_t* dest = (ECPB_t*) G__getstructoffset();
   *dest = *(ECPB_t*) libp->para[0].ref;
   const ECPB_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECPC_t */
// automatic default constructor
static int G__bankvarsDict_227_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECPC_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECPC_t[n];
     } else {
       p = new((void*) gvp) ECPC_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECPC_t;
     } else {
       p = new((void*) gvp) ECPC_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECPC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_227_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECPC_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECPC_t(*(ECPC_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECPC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECPC_t G__TECPC_t;
static int G__bankvarsDict_227_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECPC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECPC_t*) (soff+(sizeof(ECPC_t)*i)))->~G__TECPC_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECPC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECPC_t*) (soff))->~G__TECPC_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_227_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECPC_t* dest = (ECPC_t*) G__getstructoffset();
   *dest = *(ECPC_t*) libp->para[0].ref;
   const ECPC_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECP_t */
// automatic default constructor
static int G__bankvarsDict_228_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECP_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECP_t[n];
     } else {
       p = new((void*) gvp) ECP_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECP_t;
     } else {
       p = new((void*) gvp) ECP_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECP_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_228_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECP_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECP_t(*(ECP_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECP_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECP_t G__TECP_t;
static int G__bankvarsDict_228_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECP_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECP_t*) (soff+(sizeof(ECP_t)*i)))->~G__TECP_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECP_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECP_t*) (soff))->~G__TECP_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_228_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECP_t* dest = (ECP_t*) G__getstructoffset();
   *dest = *(ECP_t*) libp->para[0].ref;
   const ECP_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECPE_t */
// automatic default constructor
static int G__bankvarsDict_229_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECPE_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECPE_t[n];
     } else {
       p = new((void*) gvp) ECPE_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECPE_t;
     } else {
       p = new((void*) gvp) ECPE_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECPE_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_229_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECPE_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECPE_t(*(ECPE_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECPE_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECPE_t G__TECPE_t;
static int G__bankvarsDict_229_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECPE_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECPE_t*) (soff+(sizeof(ECPE_t)*i)))->~G__TECPE_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECPE_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECPE_t*) (soff))->~G__TECPE_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_229_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECPE_t* dest = (ECPE_t*) G__getstructoffset();
   *dest = *(ECPE_t*) libp->para[0].ref;
   const ECPE_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECPI_t */
// automatic default constructor
static int G__bankvarsDict_230_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECPI_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECPI_t[n];
     } else {
       p = new((void*) gvp) ECPI_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECPI_t;
     } else {
       p = new((void*) gvp) ECPI_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECPI_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_230_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECPI_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECPI_t(*(ECPI_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECPI_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECPI_t G__TECPI_t;
static int G__bankvarsDict_230_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECPI_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECPI_t*) (soff+(sizeof(ECPI_t)*i)))->~G__TECPI_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECPI_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECPI_t*) (soff))->~G__TECPI_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_230_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECPI_t* dest = (ECPI_t*) G__getstructoffset();
   *dest = *(ECPI_t*) libp->para[0].ref;
   const ECPI_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECPO_t */
// automatic default constructor
static int G__bankvarsDict_231_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECPO_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECPO_t[n];
     } else {
       p = new((void*) gvp) ECPO_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECPO_t;
     } else {
       p = new((void*) gvp) ECPO_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECPO_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_231_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECPO_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECPO_t(*(ECPO_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECPO_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECPO_t G__TECPO_t;
static int G__bankvarsDict_231_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECPO_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECPO_t*) (soff+(sizeof(ECPO_t)*i)))->~G__TECPO_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECPO_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECPO_t*) (soff))->~G__TECPO_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_231_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECPO_t* dest = (ECPO_t*) G__getstructoffset();
   *dest = *(ECPO_t*) libp->para[0].ref;
   const ECPO_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECRB_t */
// automatic default constructor
static int G__bankvarsDict_232_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECRB_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECRB_t[n];
     } else {
       p = new((void*) gvp) ECRB_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECRB_t;
     } else {
       p = new((void*) gvp) ECRB_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECRB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_232_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECRB_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECRB_t(*(ECRB_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECRB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECRB_t G__TECRB_t;
static int G__bankvarsDict_232_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECRB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECRB_t*) (soff+(sizeof(ECRB_t)*i)))->~G__TECRB_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECRB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECRB_t*) (soff))->~G__TECRB_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_232_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECRB_t* dest = (ECRB_t*) G__getstructoffset();
   *dest = *(ECRB_t*) libp->para[0].ref;
   const ECRB_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECS_t */
// automatic default constructor
static int G__bankvarsDict_233_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECS_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECS_t[n];
     } else {
       p = new((void*) gvp) ECS_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECS_t;
     } else {
       p = new((void*) gvp) ECS_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_233_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECS_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECS_t(*(ECS_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECS_t G__TECS_t;
static int G__bankvarsDict_233_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECS_t*) (soff+(sizeof(ECS_t)*i)))->~G__TECS_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECS_t*) (soff))->~G__TECS_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_233_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECS_t* dest = (ECS_t*) G__getstructoffset();
   *dest = *(ECS_t*) libp->para[0].ref;
   const ECS_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ECT_t */
// automatic default constructor
static int G__bankvarsDict_234_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECT_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECT_t[n];
     } else {
       p = new((void*) gvp) ECT_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ECT_t;
     } else {
       p = new((void*) gvp) ECT_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_234_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ECT_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ECT_t(*(ECT_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ECT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ECT_t G__TECT_t;
static int G__bankvarsDict_234_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ECT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ECT_t*) (soff+(sizeof(ECT_t)*i)))->~G__TECT_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ECT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ECT_t*) (soff))->~G__TECT_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_234_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ECT_t* dest = (ECT_t*) G__getstructoffset();
   *dest = *(ECT_t*) libp->para[0].ref;
   const ECT_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* EID0_t */
// automatic default constructor
static int G__bankvarsDict_235_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EID0_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EID0_t[n];
     } else {
       p = new((void*) gvp) EID0_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EID0_t;
     } else {
       p = new((void*) gvp) EID0_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_EID0_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_235_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   EID0_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new EID0_t(*(EID0_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_EID0_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef EID0_t G__TEID0_t;
static int G__bankvarsDict_235_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (EID0_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((EID0_t*) (soff+(sizeof(EID0_t)*i)))->~G__TEID0_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (EID0_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((EID0_t*) (soff))->~G__TEID0_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_235_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EID0_t* dest = (EID0_t*) G__getstructoffset();
   *dest = *(EID0_t*) libp->para[0].ref;
   const EID0_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* EPIC_t */
// automatic default constructor
static int G__bankvarsDict_236_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EPIC_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EPIC_t[n];
     } else {
       p = new((void*) gvp) EPIC_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EPIC_t;
     } else {
       p = new((void*) gvp) EPIC_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_EPIC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_236_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   EPIC_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new EPIC_t(*(EPIC_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_EPIC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef EPIC_t G__TEPIC_t;
static int G__bankvarsDict_236_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (EPIC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((EPIC_t*) (soff+(sizeof(EPIC_t)*i)))->~G__TEPIC_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (EPIC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((EPIC_t*) (soff))->~G__TEPIC_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_236_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EPIC_t* dest = (EPIC_t*) G__getstructoffset();
   *dest = *(EPIC_t*) libp->para[0].ref;
   const EPIC_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* EVNT_t */
// automatic default constructor
static int G__bankvarsDict_237_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EVNT_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EVNT_t[n];
     } else {
       p = new((void*) gvp) EVNT_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EVNT_t;
     } else {
       p = new((void*) gvp) EVNT_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_EVNT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_237_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   EVNT_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new EVNT_t(*(EVNT_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_EVNT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef EVNT_t G__TEVNT_t;
static int G__bankvarsDict_237_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (EVNT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((EVNT_t*) (soff+(sizeof(EVNT_t)*i)))->~G__TEVNT_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (EVNT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((EVNT_t*) (soff))->~G__TEVNT_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_237_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EVNT_t* dest = (EVNT_t*) G__getstructoffset();
   *dest = *(EVNT_t*) libp->para[0].ref;
   const EVNT_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* FBPM_t */
// automatic default constructor
static int G__bankvarsDict_238_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FBPM_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FBPM_t[n];
     } else {
       p = new((void*) gvp) FBPM_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FBPM_t;
     } else {
       p = new((void*) gvp) FBPM_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_FBPM_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_238_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   FBPM_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new FBPM_t(*(FBPM_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_FBPM_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef FBPM_t G__TFBPM_t;
static int G__bankvarsDict_238_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (FBPM_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((FBPM_t*) (soff+(sizeof(FBPM_t)*i)))->~G__TFBPM_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (FBPM_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((FBPM_t*) (soff))->~G__TFBPM_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_238_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FBPM_t* dest = (FBPM_t*) G__getstructoffset();
   *dest = *(FBPM_t*) libp->para[0].ref;
   const FBPM_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* G1SL_t */
// automatic default constructor
static int G__bankvarsDict_239_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   G1SL_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new G1SL_t[n];
     } else {
       p = new((void*) gvp) G1SL_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new G1SL_t;
     } else {
       p = new((void*) gvp) G1SL_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_G1SL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_239_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   G1SL_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new G1SL_t(*(G1SL_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_G1SL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef G1SL_t G__TG1SL_t;
static int G__bankvarsDict_239_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (G1SL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((G1SL_t*) (soff+(sizeof(G1SL_t)*i)))->~G__TG1SL_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (G1SL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((G1SL_t*) (soff))->~G__TG1SL_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_239_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   G1SL_t* dest = (G1SL_t*) G__getstructoffset();
   *dest = *(G1SL_t*) libp->para[0].ref;
   const G1SL_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* G2SL_t */
// automatic default constructor
static int G__bankvarsDict_240_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   G2SL_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new G2SL_t[n];
     } else {
       p = new((void*) gvp) G2SL_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new G2SL_t;
     } else {
       p = new((void*) gvp) G2SL_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_G2SL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_240_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   G2SL_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new G2SL_t(*(G2SL_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_G2SL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef G2SL_t G__TG2SL_t;
static int G__bankvarsDict_240_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (G2SL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((G2SL_t*) (soff+(sizeof(G2SL_t)*i)))->~G__TG2SL_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (G2SL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((G2SL_t*) (soff))->~G__TG2SL_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_240_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   G2SL_t* dest = (G2SL_t*) G__getstructoffset();
   *dest = *(G2SL_t*) libp->para[0].ref;
   const G2SL_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* G3SL_t */
// automatic default constructor
static int G__bankvarsDict_241_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   G3SL_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new G3SL_t[n];
     } else {
       p = new((void*) gvp) G3SL_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new G3SL_t;
     } else {
       p = new((void*) gvp) G3SL_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_G3SL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_241_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   G3SL_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new G3SL_t(*(G3SL_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_G3SL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef G3SL_t G__TG3SL_t;
static int G__bankvarsDict_241_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (G3SL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((G3SL_t*) (soff+(sizeof(G3SL_t)*i)))->~G__TG3SL_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (G3SL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((G3SL_t*) (soff))->~G__TG3SL_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_241_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   G3SL_t* dest = (G3SL_t*) G__getstructoffset();
   *dest = *(G3SL_t*) libp->para[0].ref;
   const G3SL_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* G4SL_t */
// automatic default constructor
static int G__bankvarsDict_242_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   G4SL_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new G4SL_t[n];
     } else {
       p = new((void*) gvp) G4SL_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new G4SL_t;
     } else {
       p = new((void*) gvp) G4SL_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_G4SL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_242_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   G4SL_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new G4SL_t(*(G4SL_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_G4SL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef G4SL_t G__TG4SL_t;
static int G__bankvarsDict_242_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (G4SL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((G4SL_t*) (soff+(sizeof(G4SL_t)*i)))->~G__TG4SL_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (G4SL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((G4SL_t*) (soff))->~G__TG4SL_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_242_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   G4SL_t* dest = (G4SL_t*) G__getstructoffset();
   *dest = *(G4SL_t*) libp->para[0].ref;
   const G4SL_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* GPAR_t */
// automatic default constructor
static int G__bankvarsDict_243_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GPAR_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GPAR_t[n];
     } else {
       p = new((void*) gvp) GPAR_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GPAR_t;
     } else {
       p = new((void*) gvp) GPAR_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_GPAR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_243_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   GPAR_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new GPAR_t(*(GPAR_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_GPAR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef GPAR_t G__TGPAR_t;
static int G__bankvarsDict_243_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (GPAR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((GPAR_t*) (soff+(sizeof(GPAR_t)*i)))->~G__TGPAR_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (GPAR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((GPAR_t*) (soff))->~G__TGPAR_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_243_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GPAR_t* dest = (GPAR_t*) G__getstructoffset();
   *dest = *(GPAR_t*) libp->para[0].ref;
   const GPAR_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* GPID_t */
// automatic default constructor
static int G__bankvarsDict_244_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GPID_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GPID_t[n];
     } else {
       p = new((void*) gvp) GPID_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GPID_t;
     } else {
       p = new((void*) gvp) GPID_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_GPID_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_244_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   GPID_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new GPID_t(*(GPID_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_GPID_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef GPID_t G__TGPID_t;
static int G__bankvarsDict_244_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (GPID_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((GPID_t*) (soff+(sizeof(GPID_t)*i)))->~G__TGPID_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (GPID_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((GPID_t*) (soff))->~G__TGPID_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_244_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GPID_t* dest = (GPID_t*) G__getstructoffset();
   *dest = *(GPID_t*) libp->para[0].ref;
   const GPID_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* GP_X_t */
// automatic default constructor
static int G__bankvarsDict_245_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GP_X_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GP_X_t[n];
     } else {
       p = new((void*) gvp) GP_X_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GP_X_t;
     } else {
       p = new((void*) gvp) GP_X_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_GP_X_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_245_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   GP_X_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new GP_X_t(*(GP_X_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_GP_X_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef GP_X_t G__TGP_X_t;
static int G__bankvarsDict_245_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (GP_X_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((GP_X_t*) (soff+(sizeof(GP_X_t)*i)))->~G__TGP_X_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (GP_X_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((GP_X_t*) (soff))->~G__TGP_X_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_245_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GP_X_t* dest = (GP_X_t*) G__getstructoffset();
   *dest = *(GP_X_t*) libp->para[0].ref;
   const GP_X_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* GP_Y_t */
// automatic default constructor
static int G__bankvarsDict_246_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GP_Y_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GP_Y_t[n];
     } else {
       p = new((void*) gvp) GP_Y_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GP_Y_t;
     } else {
       p = new((void*) gvp) GP_Y_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_GP_Y_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_246_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   GP_Y_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new GP_Y_t(*(GP_Y_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_GP_Y_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef GP_Y_t G__TGP_Y_t;
static int G__bankvarsDict_246_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (GP_Y_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((GP_Y_t*) (soff+(sizeof(GP_Y_t)*i)))->~G__TGP_Y_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (GP_Y_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((GP_Y_t*) (soff))->~G__TGP_Y_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_246_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GP_Y_t* dest = (GP_Y_t*) G__getstructoffset();
   *dest = *(GP_Y_t*) libp->para[0].ref;
   const GP_Y_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* HBER_t */
// automatic default constructor
static int G__bankvarsDict_247_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HBER_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HBER_t[n];
     } else {
       p = new((void*) gvp) HBER_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HBER_t;
     } else {
       p = new((void*) gvp) HBER_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HBER_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_247_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   HBER_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new HBER_t(*(HBER_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HBER_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef HBER_t G__THBER_t;
static int G__bankvarsDict_247_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (HBER_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((HBER_t*) (soff+(sizeof(HBER_t)*i)))->~G__THBER_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (HBER_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((HBER_t*) (soff))->~G__THBER_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_247_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HBER_t* dest = (HBER_t*) G__getstructoffset();
   *dest = *(HBER_t*) libp->para[0].ref;
   const HBER_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* HBID_t */
// automatic default constructor
static int G__bankvarsDict_248_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HBID_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HBID_t[n];
     } else {
       p = new((void*) gvp) HBID_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HBID_t;
     } else {
       p = new((void*) gvp) HBID_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HBID_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_248_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   HBID_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new HBID_t(*(HBID_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HBID_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef HBID_t G__THBID_t;
static int G__bankvarsDict_248_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (HBID_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((HBID_t*) (soff+(sizeof(HBID_t)*i)))->~G__THBID_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (HBID_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((HBID_t*) (soff))->~G__THBID_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_248_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HBID_t* dest = (HBID_t*) G__getstructoffset();
   *dest = *(HBID_t*) libp->para[0].ref;
   const HBID_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* HBLA_t */
// automatic default constructor
static int G__bankvarsDict_249_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HBLA_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HBLA_t[n];
     } else {
       p = new((void*) gvp) HBLA_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HBLA_t;
     } else {
       p = new((void*) gvp) HBLA_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HBLA_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_249_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   HBLA_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new HBLA_t(*(HBLA_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HBLA_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef HBLA_t G__THBLA_t;
static int G__bankvarsDict_249_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (HBLA_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((HBLA_t*) (soff+(sizeof(HBLA_t)*i)))->~G__THBLA_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (HBLA_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((HBLA_t*) (soff))->~G__THBLA_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_249_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HBLA_t* dest = (HBLA_t*) G__getstructoffset();
   *dest = *(HBLA_t*) libp->para[0].ref;
   const HBLA_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* HBTB_t */
// automatic default constructor
static int G__bankvarsDict_250_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HBTB_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HBTB_t[n];
     } else {
       p = new((void*) gvp) HBTB_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HBTB_t;
     } else {
       p = new((void*) gvp) HBTB_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HBTB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_250_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   HBTB_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new HBTB_t(*(HBTB_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HBTB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef HBTB_t G__THBTB_t;
static int G__bankvarsDict_250_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (HBTB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((HBTB_t*) (soff+(sizeof(HBTB_t)*i)))->~G__THBTB_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (HBTB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((HBTB_t*) (soff))->~G__THBTB_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_250_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HBTB_t* dest = (HBTB_t*) G__getstructoffset();
   *dest = *(HBTB_t*) libp->para[0].ref;
   const HBTB_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* HBTR_t */
// automatic default constructor
static int G__bankvarsDict_251_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HBTR_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HBTR_t[n];
     } else {
       p = new((void*) gvp) HBTR_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HBTR_t;
     } else {
       p = new((void*) gvp) HBTR_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HBTR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_251_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   HBTR_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new HBTR_t(*(HBTR_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HBTR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef HBTR_t G__THBTR_t;
static int G__bankvarsDict_251_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (HBTR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((HBTR_t*) (soff+(sizeof(HBTR_t)*i)))->~G__THBTR_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (HBTR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((HBTR_t*) (soff))->~G__THBTR_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_251_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HBTR_t* dest = (HBTR_t*) G__getstructoffset();
   *dest = *(HBTR_t*) libp->para[0].ref;
   const HBTR_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* HCAL_t */
// automatic default constructor
static int G__bankvarsDict_252_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HCAL_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HCAL_t[n];
     } else {
       p = new((void*) gvp) HCAL_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HCAL_t;
     } else {
       p = new((void*) gvp) HCAL_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HCAL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_252_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   HCAL_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new HCAL_t(*(HCAL_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HCAL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef HCAL_t G__THCAL_t;
static int G__bankvarsDict_252_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (HCAL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((HCAL_t*) (soff+(sizeof(HCAL_t)*i)))->~G__THCAL_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (HCAL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((HCAL_t*) (soff))->~G__THCAL_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_252_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HCAL_t* dest = (HCAL_t*) G__getstructoffset();
   *dest = *(HCAL_t*) libp->para[0].ref;
   const HCAL_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* HDPL_t */
// automatic default constructor
static int G__bankvarsDict_253_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HDPL_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HDPL_t[n];
     } else {
       p = new((void*) gvp) HDPL_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HDPL_t;
     } else {
       p = new((void*) gvp) HDPL_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HDPL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_253_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   HDPL_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new HDPL_t(*(HDPL_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HDPL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef HDPL_t G__THDPL_t;
static int G__bankvarsDict_253_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (HDPL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((HDPL_t*) (soff+(sizeof(HDPL_t)*i)))->~G__THDPL_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (HDPL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((HDPL_t*) (soff))->~G__THDPL_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_253_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HDPL_t* dest = (HDPL_t*) G__getstructoffset();
   *dest = *(HDPL_t*) libp->para[0].ref;
   const HDPL_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* HEAD_t */
// automatic default constructor
static int G__bankvarsDict_254_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HEAD_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HEAD_t[n];
     } else {
       p = new((void*) gvp) HEAD_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HEAD_t;
     } else {
       p = new((void*) gvp) HEAD_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HEAD_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_254_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   HEAD_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new HEAD_t(*(HEAD_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HEAD_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef HEAD_t G__THEAD_t;
static int G__bankvarsDict_254_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (HEAD_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((HEAD_t*) (soff+(sizeof(HEAD_t)*i)))->~G__THEAD_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (HEAD_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((HEAD_t*) (soff))->~G__THEAD_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_254_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HEAD_t* dest = (HEAD_t*) G__getstructoffset();
   *dest = *(HEAD_t*) libp->para[0].ref;
   const HEAD_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* HEVT_t */
// automatic default constructor
static int G__bankvarsDict_255_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HEVT_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HEVT_t[n];
     } else {
       p = new((void*) gvp) HEVT_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HEVT_t;
     } else {
       p = new((void*) gvp) HEVT_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HEVT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_255_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   HEVT_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new HEVT_t(*(HEVT_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HEVT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef HEVT_t G__THEVT_t;
static int G__bankvarsDict_255_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (HEVT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((HEVT_t*) (soff+(sizeof(HEVT_t)*i)))->~G__THEVT_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (HEVT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((HEVT_t*) (soff))->~G__THEVT_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_255_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HEVT_t* dest = (HEVT_t*) G__getstructoffset();
   *dest = *(HEVT_t*) libp->para[0].ref;
   const HEVT_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* HLS_t */
// automatic default constructor
static int G__bankvarsDict_256_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HLS_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HLS_t[n];
     } else {
       p = new((void*) gvp) HLS_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new HLS_t;
     } else {
       p = new((void*) gvp) HLS_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HLS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_256_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   HLS_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new HLS_t(*(HLS_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_HLS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef HLS_t G__THLS_t;
static int G__bankvarsDict_256_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (HLS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((HLS_t*) (soff+(sizeof(HLS_t)*i)))->~G__THLS_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (HLS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((HLS_t*) (soff))->~G__THLS_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_256_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   HLS_t* dest = (HLS_t*) G__getstructoffset();
   *dest = *(HLS_t*) libp->para[0].ref;
   const HLS_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* IC_t */
// automatic default constructor
static int G__bankvarsDict_257_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   IC_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new IC_t[n];
     } else {
       p = new((void*) gvp) IC_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new IC_t;
     } else {
       p = new((void*) gvp) IC_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_IC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_257_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   IC_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new IC_t(*(IC_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_IC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef IC_t G__TIC_t;
static int G__bankvarsDict_257_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (IC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((IC_t*) (soff+(sizeof(IC_t)*i)))->~G__TIC_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (IC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((IC_t*) (soff))->~G__TIC_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_257_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   IC_t* dest = (IC_t*) G__getstructoffset();
   *dest = *(IC_t*) libp->para[0].ref;
   const IC_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ICHB_t */
// automatic default constructor
static int G__bankvarsDict_258_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ICHB_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ICHB_t[n];
     } else {
       p = new((void*) gvp) ICHB_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ICHB_t;
     } else {
       p = new((void*) gvp) ICHB_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ICHB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_258_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ICHB_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ICHB_t(*(ICHB_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ICHB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ICHB_t G__TICHB_t;
static int G__bankvarsDict_258_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ICHB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ICHB_t*) (soff+(sizeof(ICHB_t)*i)))->~G__TICHB_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ICHB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ICHB_t*) (soff))->~G__TICHB_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_258_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ICHB_t* dest = (ICHB_t*) G__getstructoffset();
   *dest = *(ICHB_t*) libp->para[0].ref;
   const ICHB_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* KFIT_t */
// automatic default constructor
static int G__bankvarsDict_259_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   KFIT_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new KFIT_t[n];
     } else {
       p = new((void*) gvp) KFIT_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new KFIT_t;
     } else {
       p = new((void*) gvp) KFIT_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_KFIT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_259_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   KFIT_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new KFIT_t(*(KFIT_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_KFIT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef KFIT_t G__TKFIT_t;
static int G__bankvarsDict_259_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (KFIT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((KFIT_t*) (soff+(sizeof(KFIT_t)*i)))->~G__TKFIT_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (KFIT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((KFIT_t*) (soff))->~G__TKFIT_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_259_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   KFIT_t* dest = (KFIT_t*) G__getstructoffset();
   *dest = *(KFIT_t*) libp->para[0].ref;
   const KFIT_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* L1PG_t */
// automatic default constructor
static int G__bankvarsDict_260_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   L1PG_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new L1PG_t[n];
     } else {
       p = new((void*) gvp) L1PG_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new L1PG_t;
     } else {
       p = new((void*) gvp) L1PG_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_L1PG_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_260_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   L1PG_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new L1PG_t(*(L1PG_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_L1PG_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef L1PG_t G__TL1PG_t;
static int G__bankvarsDict_260_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (L1PG_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((L1PG_t*) (soff+(sizeof(L1PG_t)*i)))->~G__TL1PG_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (L1PG_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((L1PG_t*) (soff))->~G__TL1PG_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_260_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   L1PG_t* dest = (L1PG_t*) G__getstructoffset();
   *dest = *(L1PG_t*) libp->para[0].ref;
   const L1PG_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* L2H_t */
// automatic default constructor
static int G__bankvarsDict_261_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   L2H_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new L2H_t[n];
     } else {
       p = new((void*) gvp) L2H_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new L2H_t;
     } else {
       p = new((void*) gvp) L2H_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_L2H_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_261_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   L2H_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new L2H_t(*(L2H_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_L2H_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef L2H_t G__TL2H_t;
static int G__bankvarsDict_261_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (L2H_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((L2H_t*) (soff+(sizeof(L2H_t)*i)))->~G__TL2H_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (L2H_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((L2H_t*) (soff))->~G__TL2H_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_261_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   L2H_t* dest = (L2H_t*) G__getstructoffset();
   *dest = *(L2H_t*) libp->para[0].ref;
   const L2H_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* L2S_t */
// automatic default constructor
static int G__bankvarsDict_262_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   L2S_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new L2S_t[n];
     } else {
       p = new((void*) gvp) L2S_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new L2S_t;
     } else {
       p = new((void*) gvp) L2S_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_L2S_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_262_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   L2S_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new L2S_t(*(L2S_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_L2S_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef L2S_t G__TL2S_t;
static int G__bankvarsDict_262_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (L2S_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((L2S_t*) (soff+(sizeof(L2S_t)*i)))->~G__TL2S_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (L2S_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((L2S_t*) (soff))->~G__TL2S_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_262_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   L2S_t* dest = (L2S_t*) G__getstructoffset();
   *dest = *(L2S_t*) libp->para[0].ref;
   const L2S_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* LASR_t */
// automatic default constructor
static int G__bankvarsDict_263_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   LASR_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new LASR_t[n];
     } else {
       p = new((void*) gvp) LASR_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new LASR_t;
     } else {
       p = new((void*) gvp) LASR_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_LASR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_263_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   LASR_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new LASR_t(*(LASR_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_LASR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef LASR_t G__TLASR_t;
static int G__bankvarsDict_263_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (LASR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((LASR_t*) (soff+(sizeof(LASR_t)*i)))->~G__TLASR_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (LASR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((LASR_t*) (soff))->~G__TLASR_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_263_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   LASR_t* dest = (LASR_t*) G__getstructoffset();
   *dest = *(LASR_t*) libp->para[0].ref;
   const LASR_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* LCDI_t */
// automatic default constructor
static int G__bankvarsDict_264_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   LCDI_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new LCDI_t[n];
     } else {
       p = new((void*) gvp) LCDI_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new LCDI_t;
     } else {
       p = new((void*) gvp) LCDI_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_LCDI_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_264_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   LCDI_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new LCDI_t(*(LCDI_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_LCDI_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef LCDI_t G__TLCDI_t;
static int G__bankvarsDict_264_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (LCDI_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((LCDI_t*) (soff+(sizeof(LCDI_t)*i)))->~G__TLCDI_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (LCDI_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((LCDI_t*) (soff))->~G__TLCDI_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_264_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   LCDI_t* dest = (LCDI_t*) G__getstructoffset();
   *dest = *(LCDI_t*) libp->para[0].ref;
   const LCDI_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* LCPB_t */
// automatic default constructor
static int G__bankvarsDict_265_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   LCPB_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new LCPB_t[n];
     } else {
       p = new((void*) gvp) LCPB_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new LCPB_t;
     } else {
       p = new((void*) gvp) LCPB_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_LCPB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_265_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   LCPB_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new LCPB_t(*(LCPB_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_LCPB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef LCPB_t G__TLCPB_t;
static int G__bankvarsDict_265_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (LCPB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((LCPB_t*) (soff+(sizeof(LCPB_t)*i)))->~G__TLCPB_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (LCPB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((LCPB_t*) (soff))->~G__TLCPB_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_265_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   LCPB_t* dest = (LCPB_t*) G__getstructoffset();
   *dest = *(LCPB_t*) libp->para[0].ref;
   const LCPB_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* LOWQ_t */
// automatic default constructor
static int G__bankvarsDict_266_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   LOWQ_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new LOWQ_t[n];
     } else {
       p = new((void*) gvp) LOWQ_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new LOWQ_t;
     } else {
       p = new((void*) gvp) LOWQ_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_LOWQ_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_266_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   LOWQ_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new LOWQ_t(*(LOWQ_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_LOWQ_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef LOWQ_t G__TLOWQ_t;
static int G__bankvarsDict_266_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (LOWQ_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((LOWQ_t*) (soff+(sizeof(LOWQ_t)*i)))->~G__TLOWQ_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (LOWQ_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((LOWQ_t*) (soff))->~G__TLOWQ_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_266_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   LOWQ_t* dest = (LOWQ_t*) G__getstructoffset();
   *dest = *(LOWQ_t*) libp->para[0].ref;
   const LOWQ_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* MCEV_t */
// automatic default constructor
static int G__bankvarsDict_267_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MCEV_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new MCEV_t[n];
     } else {
       p = new((void*) gvp) MCEV_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new MCEV_t;
     } else {
       p = new((void*) gvp) MCEV_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_MCEV_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_267_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   MCEV_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new MCEV_t(*(MCEV_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_MCEV_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef MCEV_t G__TMCEV_t;
static int G__bankvarsDict_267_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (MCEV_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((MCEV_t*) (soff+(sizeof(MCEV_t)*i)))->~G__TMCEV_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (MCEV_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((MCEV_t*) (soff))->~G__TMCEV_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_267_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MCEV_t* dest = (MCEV_t*) G__getstructoffset();
   *dest = *(MCEV_t*) libp->para[0].ref;
   const MCEV_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* MCHD_t */
// automatic default constructor
static int G__bankvarsDict_268_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MCHD_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new MCHD_t[n];
     } else {
       p = new((void*) gvp) MCHD_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new MCHD_t;
     } else {
       p = new((void*) gvp) MCHD_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_MCHD_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_268_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   MCHD_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new MCHD_t(*(MCHD_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_MCHD_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef MCHD_t G__TMCHD_t;
static int G__bankvarsDict_268_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (MCHD_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((MCHD_t*) (soff+(sizeof(MCHD_t)*i)))->~G__TMCHD_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (MCHD_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((MCHD_t*) (soff))->~G__TMCHD_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_268_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MCHD_t* dest = (MCHD_t*) G__getstructoffset();
   *dest = *(MCHD_t*) libp->para[0].ref;
   const MCHD_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* MCTK_t */
// automatic default constructor
static int G__bankvarsDict_269_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MCTK_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new MCTK_t[n];
     } else {
       p = new((void*) gvp) MCTK_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new MCTK_t;
     } else {
       p = new((void*) gvp) MCTK_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_MCTK_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_269_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   MCTK_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new MCTK_t(*(MCTK_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_MCTK_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef MCTK_t G__TMCTK_t;
static int G__bankvarsDict_269_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (MCTK_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((MCTK_t*) (soff+(sizeof(MCTK_t)*i)))->~G__TMCTK_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (MCTK_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((MCTK_t*) (soff))->~G__TMCTK_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_269_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MCTK_t* dest = (MCTK_t*) G__getstructoffset();
   *dest = *(MCTK_t*) libp->para[0].ref;
   const MCTK_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* MCVX_t */
// automatic default constructor
static int G__bankvarsDict_270_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MCVX_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new MCVX_t[n];
     } else {
       p = new((void*) gvp) MCVX_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new MCVX_t;
     } else {
       p = new((void*) gvp) MCVX_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_MCVX_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_270_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   MCVX_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new MCVX_t(*(MCVX_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_MCVX_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef MCVX_t G__TMCVX_t;
static int G__bankvarsDict_270_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (MCVX_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((MCVX_t*) (soff+(sizeof(MCVX_t)*i)))->~G__TMCVX_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (MCVX_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((MCVX_t*) (soff))->~G__TMCVX_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_270_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MCVX_t* dest = (MCVX_t*) G__getstructoffset();
   *dest = *(MCVX_t*) libp->para[0].ref;
   const MCVX_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* MS1_t */
// automatic default constructor
static int G__bankvarsDict_271_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MS1_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new MS1_t[n];
     } else {
       p = new((void*) gvp) MS1_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new MS1_t;
     } else {
       p = new((void*) gvp) MS1_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_MS1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_271_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   MS1_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new MS1_t(*(MS1_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_MS1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef MS1_t G__TMS1_t;
static int G__bankvarsDict_271_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (MS1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((MS1_t*) (soff+(sizeof(MS1_t)*i)))->~G__TMS1_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (MS1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((MS1_t*) (soff))->~G__TMS1_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_271_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MS1_t* dest = (MS1_t*) G__getstructoffset();
   *dest = *(MS1_t*) libp->para[0].ref;
   const MS1_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* MTRK_t */
// automatic default constructor
static int G__bankvarsDict_272_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MTRK_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new MTRK_t[n];
     } else {
       p = new((void*) gvp) MTRK_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new MTRK_t;
     } else {
       p = new((void*) gvp) MTRK_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_MTRK_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_272_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   MTRK_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new MTRK_t(*(MTRK_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_MTRK_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef MTRK_t G__TMTRK_t;
static int G__bankvarsDict_272_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (MTRK_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((MTRK_t*) (soff+(sizeof(MTRK_t)*i)))->~G__TMTRK_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (MTRK_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((MTRK_t*) (soff))->~G__TMTRK_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_272_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MTRK_t* dest = (MTRK_t*) G__getstructoffset();
   *dest = *(MTRK_t*) libp->para[0].ref;
   const MTRK_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* MVRT_t */
// automatic default constructor
static int G__bankvarsDict_273_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MVRT_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new MVRT_t[n];
     } else {
       p = new((void*) gvp) MVRT_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new MVRT_t;
     } else {
       p = new((void*) gvp) MVRT_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_MVRT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_273_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   MVRT_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new MVRT_t(*(MVRT_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_MVRT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef MVRT_t G__TMVRT_t;
static int G__bankvarsDict_273_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (MVRT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((MVRT_t*) (soff+(sizeof(MVRT_t)*i)))->~G__TMVRT_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (MVRT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((MVRT_t*) (soff))->~G__TMVRT_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_273_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MVRT_t* dest = (MVRT_t*) G__getstructoffset();
   *dest = *(MVRT_t*) libp->para[0].ref;
   const MVRT_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PART_t */
// automatic default constructor
static int G__bankvarsDict_274_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PART_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PART_t[n];
     } else {
       p = new((void*) gvp) PART_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PART_t;
     } else {
       p = new((void*) gvp) PART_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PART_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_274_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PART_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PART_t(*(PART_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PART_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PART_t G__TPART_t;
static int G__bankvarsDict_274_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PART_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PART_t*) (soff+(sizeof(PART_t)*i)))->~G__TPART_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PART_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PART_t*) (soff))->~G__TPART_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_274_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PART_t* dest = (PART_t*) G__getstructoffset();
   *dest = *(PART_t*) libp->para[0].ref;
   const PART_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PCO_t */
// automatic default constructor
static int G__bankvarsDict_275_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PCO_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PCO_t[n];
     } else {
       p = new((void*) gvp) PCO_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PCO_t;
     } else {
       p = new((void*) gvp) PCO_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PCO_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_275_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PCO_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PCO_t(*(PCO_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PCO_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PCO_t G__TPCO_t;
static int G__bankvarsDict_275_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PCO_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PCO_t*) (soff+(sizeof(PCO_t)*i)))->~G__TPCO_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PCO_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PCO_t*) (soff))->~G__TPCO_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_275_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PCO_t* dest = (PCO_t*) G__getstructoffset();
   *dest = *(PCO_t*) libp->para[0].ref;
   const PCO_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PHTM_t */
// automatic default constructor
static int G__bankvarsDict_276_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PHTM_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PHTM_t[n];
     } else {
       p = new((void*) gvp) PHTM_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PHTM_t;
     } else {
       p = new((void*) gvp) PHTM_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PHTM_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_276_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PHTM_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PHTM_t(*(PHTM_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PHTM_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PHTM_t G__TPHTM_t;
static int G__bankvarsDict_276_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PHTM_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PHTM_t*) (soff+(sizeof(PHTM_t)*i)))->~G__TPHTM_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PHTM_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PHTM_t*) (soff))->~G__TPHTM_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_276_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PHTM_t* dest = (PHTM_t*) G__getstructoffset();
   *dest = *(PHTM_t*) libp->para[0].ref;
   const PHTM_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PID1_t */
// automatic default constructor
static int G__bankvarsDict_277_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PID1_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PID1_t[n];
     } else {
       p = new((void*) gvp) PID1_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PID1_t;
     } else {
       p = new((void*) gvp) PID1_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PID1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_277_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PID1_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PID1_t(*(PID1_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PID1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PID1_t G__TPID1_t;
static int G__bankvarsDict_277_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PID1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PID1_t*) (soff+(sizeof(PID1_t)*i)))->~G__TPID1_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PID1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PID1_t*) (soff))->~G__TPID1_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_277_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PID1_t* dest = (PID1_t*) G__getstructoffset();
   *dest = *(PID1_t*) libp->para[0].ref;
   const PID1_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PID2_t */
// automatic default constructor
static int G__bankvarsDict_278_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PID2_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PID2_t[n];
     } else {
       p = new((void*) gvp) PID2_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PID2_t;
     } else {
       p = new((void*) gvp) PID2_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PID2_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_278_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PID2_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PID2_t(*(PID2_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PID2_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PID2_t G__TPID2_t;
static int G__bankvarsDict_278_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PID2_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PID2_t*) (soff+(sizeof(PID2_t)*i)))->~G__TPID2_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PID2_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PID2_t*) (soff))->~G__TPID2_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_278_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PID2_t* dest = (PID2_t*) G__getstructoffset();
   *dest = *(PID2_t*) libp->para[0].ref;
   const PID2_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PID3_t */
// automatic default constructor
static int G__bankvarsDict_279_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PID3_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PID3_t[n];
     } else {
       p = new((void*) gvp) PID3_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PID3_t;
     } else {
       p = new((void*) gvp) PID3_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PID3_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_279_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PID3_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PID3_t(*(PID3_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PID3_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PID3_t G__TPID3_t;
static int G__bankvarsDict_279_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PID3_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PID3_t*) (soff+(sizeof(PID3_t)*i)))->~G__TPID3_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PID3_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PID3_t*) (soff))->~G__TPID3_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_279_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PID3_t* dest = (PID3_t*) G__getstructoffset();
   *dest = *(PID3_t*) libp->para[0].ref;
   const PID3_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PID4_t */
// automatic default constructor
static int G__bankvarsDict_280_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PID4_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PID4_t[n];
     } else {
       p = new((void*) gvp) PID4_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PID4_t;
     } else {
       p = new((void*) gvp) PID4_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PID4_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_280_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PID4_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PID4_t(*(PID4_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PID4_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PID4_t G__TPID4_t;
static int G__bankvarsDict_280_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PID4_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PID4_t*) (soff+(sizeof(PID4_t)*i)))->~G__TPID4_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PID4_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PID4_t*) (soff))->~G__TPID4_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_280_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PID4_t* dest = (PID4_t*) G__getstructoffset();
   *dest = *(PID4_t*) libp->para[0].ref;
   const PID4_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PID5_t */
// automatic default constructor
static int G__bankvarsDict_281_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PID5_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PID5_t[n];
     } else {
       p = new((void*) gvp) PID5_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PID5_t;
     } else {
       p = new((void*) gvp) PID5_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PID5_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_281_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PID5_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PID5_t(*(PID5_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PID5_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PID5_t G__TPID5_t;
static int G__bankvarsDict_281_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PID5_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PID5_t*) (soff+(sizeof(PID5_t)*i)))->~G__TPID5_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PID5_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PID5_t*) (soff))->~G__TPID5_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_281_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PID5_t* dest = (PID5_t*) G__getstructoffset();
   *dest = *(PID5_t*) libp->para[0].ref;
   const PID5_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PID6_t */
// automatic default constructor
static int G__bankvarsDict_282_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PID6_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PID6_t[n];
     } else {
       p = new((void*) gvp) PID6_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PID6_t;
     } else {
       p = new((void*) gvp) PID6_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PID6_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_282_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PID6_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PID6_t(*(PID6_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PID6_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PID6_t G__TPID6_t;
static int G__bankvarsDict_282_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PID6_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PID6_t*) (soff+(sizeof(PID6_t)*i)))->~G__TPID6_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PID6_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PID6_t*) (soff))->~G__TPID6_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_282_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PID6_t* dest = (PID6_t*) G__getstructoffset();
   *dest = *(PID6_t*) libp->para[0].ref;
   const PID6_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PIDT_t */
// automatic default constructor
static int G__bankvarsDict_283_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PIDT_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PIDT_t[n];
     } else {
       p = new((void*) gvp) PIDT_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PIDT_t;
     } else {
       p = new((void*) gvp) PIDT_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PIDT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_283_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PIDT_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PIDT_t(*(PIDT_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PIDT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PIDT_t G__TPIDT_t;
static int G__bankvarsDict_283_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PIDT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PIDT_t*) (soff+(sizeof(PIDT_t)*i)))->~G__TPIDT_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PIDT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PIDT_t*) (soff))->~G__TPIDT_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_283_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PIDT_t* dest = (PIDT_t*) G__getstructoffset();
   *dest = *(PIDT_t*) libp->para[0].ref;
   const PIDT_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PRTM_t */
// automatic default constructor
static int G__bankvarsDict_284_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PRTM_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PRTM_t[n];
     } else {
       p = new((void*) gvp) PRTM_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PRTM_t;
     } else {
       p = new((void*) gvp) PRTM_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PRTM_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_284_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PRTM_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PRTM_t(*(PRTM_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PRTM_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PRTM_t G__TPRTM_t;
static int G__bankvarsDict_284_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PRTM_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PRTM_t*) (soff+(sizeof(PRTM_t)*i)))->~G__TPRTM_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PRTM_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PRTM_t*) (soff))->~G__TPRTM_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_284_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PRTM_t* dest = (PRTM_t*) G__getstructoffset();
   *dest = *(PRTM_t*) libp->para[0].ref;
   const PRTM_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PSO_t */
// automatic default constructor
static int G__bankvarsDict_285_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PSO_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PSO_t[n];
     } else {
       p = new((void*) gvp) PSO_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PSO_t;
     } else {
       p = new((void*) gvp) PSO_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PSO_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_285_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PSO_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PSO_t(*(PSO_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PSO_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PSO_t G__TPSO_t;
static int G__bankvarsDict_285_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PSO_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PSO_t*) (soff+(sizeof(PSO_t)*i)))->~G__TPSO_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PSO_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PSO_t*) (soff))->~G__TPSO_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_285_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PSO_t* dest = (PSO_t*) G__getstructoffset();
   *dest = *(PSO_t*) libp->para[0].ref;
   const PSO_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PTDB_t */
// automatic default constructor
static int G__bankvarsDict_286_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PTDB_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PTDB_t[n];
     } else {
       p = new((void*) gvp) PTDB_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PTDB_t;
     } else {
       p = new((void*) gvp) PTDB_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PTDB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_286_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PTDB_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PTDB_t(*(PTDB_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_PTDB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PTDB_t G__TPTDB_t;
static int G__bankvarsDict_286_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PTDB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PTDB_t*) (soff+(sizeof(PTDB_t)*i)))->~G__TPTDB_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PTDB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PTDB_t*) (soff))->~G__TPTDB_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_286_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PTDB_t* dest = (PTDB_t*) G__getstructoffset();
   *dest = *(PTDB_t*) libp->para[0].ref;
   const PTDB_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* RCST_t */
// automatic default constructor
static int G__bankvarsDict_287_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RCST_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RCST_t[n];
     } else {
       p = new((void*) gvp) RCST_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RCST_t;
     } else {
       p = new((void*) gvp) RCST_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RCST_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_287_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   RCST_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new RCST_t(*(RCST_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RCST_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef RCST_t G__TRCST_t;
static int G__bankvarsDict_287_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (RCST_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((RCST_t*) (soff+(sizeof(RCST_t)*i)))->~G__TRCST_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (RCST_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((RCST_t*) (soff))->~G__TRCST_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_287_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RCST_t* dest = (RCST_t*) G__getstructoffset();
   *dest = *(RCST_t*) libp->para[0].ref;
   const RCST_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* REF_t */
// automatic default constructor
static int G__bankvarsDict_288_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   REF_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new REF_t[n];
     } else {
       p = new((void*) gvp) REF_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new REF_t;
     } else {
       p = new((void*) gvp) REF_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_REF_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_288_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   REF_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new REF_t(*(REF_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_REF_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef REF_t G__TREF_t;
static int G__bankvarsDict_288_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (REF_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((REF_t*) (soff+(sizeof(REF_t)*i)))->~G__TREF_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (REF_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((REF_t*) (soff))->~G__TREF_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_288_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   REF_t* dest = (REF_t*) G__getstructoffset();
   *dest = *(REF_t*) libp->para[0].ref;
   const REF_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* RF_t */
// automatic default constructor
static int G__bankvarsDict_289_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RF_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RF_t[n];
     } else {
       p = new((void*) gvp) RF_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RF_t;
     } else {
       p = new((void*) gvp) RF_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RF_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_289_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   RF_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new RF_t(*(RF_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RF_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef RF_t G__TRF_t;
static int G__bankvarsDict_289_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (RF_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((RF_t*) (soff+(sizeof(RF_t)*i)))->~G__TRF_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (RF_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((RF_t*) (soff))->~G__TRF_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_289_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RF_t* dest = (RF_t*) G__getstructoffset();
   *dest = *(RF_t*) libp->para[0].ref;
   const RF_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* RFT_t */
// automatic default constructor
static int G__bankvarsDict_290_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RFT_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RFT_t[n];
     } else {
       p = new((void*) gvp) RFT_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RFT_t;
     } else {
       p = new((void*) gvp) RFT_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RFT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_290_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   RFT_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new RFT_t(*(RFT_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RFT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef RFT_t G__TRFT_t;
static int G__bankvarsDict_290_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (RFT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((RFT_t*) (soff+(sizeof(RFT_t)*i)))->~G__TRFT_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (RFT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((RFT_t*) (soff))->~G__TRFT_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_290_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RFT_t* dest = (RFT_t*) G__getstructoffset();
   *dest = *(RFT_t*) libp->para[0].ref;
   const RFT_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* RGLK_t */
// automatic default constructor
static int G__bankvarsDict_291_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RGLK_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RGLK_t[n];
     } else {
       p = new((void*) gvp) RGLK_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RGLK_t;
     } else {
       p = new((void*) gvp) RGLK_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RGLK_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_291_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   RGLK_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new RGLK_t(*(RGLK_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RGLK_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef RGLK_t G__TRGLK_t;
static int G__bankvarsDict_291_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (RGLK_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((RGLK_t*) (soff+(sizeof(RGLK_t)*i)))->~G__TRGLK_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (RGLK_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((RGLK_t*) (soff))->~G__TRGLK_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_291_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RGLK_t* dest = (RGLK_t*) G__getstructoffset();
   *dest = *(RGLK_t*) libp->para[0].ref;
   const RGLK_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* RNLG_t */
// automatic default constructor
static int G__bankvarsDict_292_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RNLG_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RNLG_t[n];
     } else {
       p = new((void*) gvp) RNLG_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RNLG_t;
     } else {
       p = new((void*) gvp) RNLG_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RNLG_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_292_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   RNLG_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new RNLG_t(*(RNLG_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RNLG_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef RNLG_t G__TRNLG_t;
static int G__bankvarsDict_292_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (RNLG_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((RNLG_t*) (soff+(sizeof(RNLG_t)*i)))->~G__TRNLG_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (RNLG_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((RNLG_t*) (soff))->~G__TRNLG_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_292_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RNLG_t* dest = (RNLG_t*) G__getstructoffset();
   *dest = *(RNLG_t*) libp->para[0].ref;
   const RNLG_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* RNPE_t */
// automatic default constructor
static int G__bankvarsDict_293_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RNPE_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RNPE_t[n];
     } else {
       p = new((void*) gvp) RNPE_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RNPE_t;
     } else {
       p = new((void*) gvp) RNPE_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RNPE_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_293_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   RNPE_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new RNPE_t(*(RNPE_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RNPE_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef RNPE_t G__TRNPE_t;
static int G__bankvarsDict_293_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (RNPE_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((RNPE_t*) (soff+(sizeof(RNPE_t)*i)))->~G__TRNPE_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (RNPE_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((RNPE_t*) (soff))->~G__TRNPE_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_293_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RNPE_t* dest = (RNPE_t*) G__getstructoffset();
   *dest = *(RNPE_t*) libp->para[0].ref;
   const RNPE_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* RTSL_t */
// automatic default constructor
static int G__bankvarsDict_294_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RTSL_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RTSL_t[n];
     } else {
       p = new((void*) gvp) RTSL_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RTSL_t;
     } else {
       p = new((void*) gvp) RTSL_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RTSL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_294_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   RTSL_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new RTSL_t(*(RTSL_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RTSL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef RTSL_t G__TRTSL_t;
static int G__bankvarsDict_294_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (RTSL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((RTSL_t*) (soff+(sizeof(RTSL_t)*i)))->~G__TRTSL_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (RTSL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((RTSL_t*) (soff))->~G__TRTSL_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_294_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RTSL_t* dest = (RTSL_t*) G__getstructoffset();
   *dest = *(RTSL_t*) libp->para[0].ref;
   const RTSL_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* RUNC_t */
// automatic default constructor
static int G__bankvarsDict_295_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RUNC_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RUNC_t[n];
     } else {
       p = new((void*) gvp) RUNC_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RUNC_t;
     } else {
       p = new((void*) gvp) RUNC_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RUNC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_295_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   RUNC_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new RUNC_t(*(RUNC_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RUNC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef RUNC_t G__TRUNC_t;
static int G__bankvarsDict_295_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (RUNC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((RUNC_t*) (soff+(sizeof(RUNC_t)*i)))->~G__TRUNC_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (RUNC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((RUNC_t*) (soff))->~G__TRUNC_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_295_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RUNC_t* dest = (RUNC_t*) G__getstructoffset();
   *dest = *(RUNC_t*) libp->para[0].ref;
   const RUNC_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* S1ST_t */
// automatic default constructor
static int G__bankvarsDict_296_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S1ST_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new S1ST_t[n];
     } else {
       p = new((void*) gvp) S1ST_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new S1ST_t;
     } else {
       p = new((void*) gvp) S1ST_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_S1ST_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_296_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   S1ST_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new S1ST_t(*(S1ST_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_S1ST_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef S1ST_t G__TS1ST_t;
static int G__bankvarsDict_296_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (S1ST_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((S1ST_t*) (soff+(sizeof(S1ST_t)*i)))->~G__TS1ST_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (S1ST_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((S1ST_t*) (soff))->~G__TS1ST_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_296_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S1ST_t* dest = (S1ST_t*) G__getstructoffset();
   *dest = *(S1ST_t*) libp->para[0].ref;
   const S1ST_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SC1_t */
// automatic default constructor
static int G__bankvarsDict_297_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SC1_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SC1_t[n];
     } else {
       p = new((void*) gvp) SC1_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SC1_t;
     } else {
       p = new((void*) gvp) SC1_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SC1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_297_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SC1_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SC1_t(*(SC1_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SC1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SC1_t G__TSC1_t;
static int G__bankvarsDict_297_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SC1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SC1_t*) (soff+(sizeof(SC1_t)*i)))->~G__TSC1_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SC1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SC1_t*) (soff))->~G__TSC1_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_297_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SC1_t* dest = (SC1_t*) G__getstructoffset();
   *dest = *(SC1_t*) libp->para[0].ref;
   const SC1_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SCC_t */
// automatic default constructor
static int G__bankvarsDict_298_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCC_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCC_t[n];
     } else {
       p = new((void*) gvp) SCC_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCC_t;
     } else {
       p = new((void*) gvp) SCC_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_298_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SCC_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SCC_t(*(SCC_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SCC_t G__TSCC_t;
static int G__bankvarsDict_298_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SCC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SCC_t*) (soff+(sizeof(SCC_t)*i)))->~G__TSCC_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SCC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SCC_t*) (soff))->~G__TSCC_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_298_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCC_t* dest = (SCC_t*) G__getstructoffset();
   *dest = *(SCC_t*) libp->para[0].ref;
   const SCC_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SC_t */
// automatic default constructor
static int G__bankvarsDict_299_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SC_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SC_t[n];
     } else {
       p = new((void*) gvp) SC_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SC_t;
     } else {
       p = new((void*) gvp) SC_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_299_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SC_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SC_t(*(SC_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SC_t G__TSC_t;
static int G__bankvarsDict_299_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SC_t*) (soff+(sizeof(SC_t)*i)))->~G__TSC_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SC_t*) (soff))->~G__TSC_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_299_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SC_t* dest = (SC_t*) G__getstructoffset();
   *dest = *(SC_t*) libp->para[0].ref;
   const SC_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SCDI_t */
// automatic default constructor
static int G__bankvarsDict_300_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCDI_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCDI_t[n];
     } else {
       p = new((void*) gvp) SCDI_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCDI_t;
     } else {
       p = new((void*) gvp) SCDI_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCDI_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_300_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SCDI_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SCDI_t(*(SCDI_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCDI_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SCDI_t G__TSCDI_t;
static int G__bankvarsDict_300_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SCDI_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SCDI_t*) (soff+(sizeof(SCDI_t)*i)))->~G__TSCDI_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SCDI_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SCDI_t*) (soff))->~G__TSCDI_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_300_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCDI_t* dest = (SCDI_t*) G__getstructoffset();
   *dest = *(SCDI_t*) libp->para[0].ref;
   const SCDI_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SCGD_t */
// automatic default constructor
static int G__bankvarsDict_301_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCGD_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCGD_t[n];
     } else {
       p = new((void*) gvp) SCGD_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCGD_t;
     } else {
       p = new((void*) gvp) SCGD_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCGD_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_301_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SCGD_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SCGD_t(*(SCGD_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCGD_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SCGD_t G__TSCGD_t;
static int G__bankvarsDict_301_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SCGD_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SCGD_t*) (soff+(sizeof(SCGD_t)*i)))->~G__TSCGD_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SCGD_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SCGD_t*) (soff))->~G__TSCGD_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_301_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCGD_t* dest = (SCGD_t*) G__getstructoffset();
   *dest = *(SCGD_t*) libp->para[0].ref;
   const SCGD_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SCG_t */
// automatic default constructor
static int G__bankvarsDict_302_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCG_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCG_t[n];
     } else {
       p = new((void*) gvp) SCG_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCG_t;
     } else {
       p = new((void*) gvp) SCG_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCG_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_302_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SCG_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SCG_t(*(SCG_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCG_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SCG_t G__TSCG_t;
static int G__bankvarsDict_302_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SCG_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SCG_t*) (soff+(sizeof(SCG_t)*i)))->~G__TSCG_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SCG_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SCG_t*) (soff))->~G__TSCG_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_302_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCG_t* dest = (SCG_t*) G__getstructoffset();
   *dest = *(SCG_t*) libp->para[0].ref;
   const SCG_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SCH_t */
// automatic default constructor
static int G__bankvarsDict_303_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCH_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCH_t[n];
     } else {
       p = new((void*) gvp) SCH_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCH_t;
     } else {
       p = new((void*) gvp) SCH_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCH_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_303_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SCH_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SCH_t(*(SCH_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCH_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SCH_t G__TSCH_t;
static int G__bankvarsDict_303_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SCH_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SCH_t*) (soff+(sizeof(SCH_t)*i)))->~G__TSCH_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SCH_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SCH_t*) (soff))->~G__TSCH_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_303_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCH_t* dest = (SCH_t*) G__getstructoffset();
   *dest = *(SCH_t*) libp->para[0].ref;
   const SCH_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SCMD_t */
// automatic default constructor
static int G__bankvarsDict_304_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCMD_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCMD_t[n];
     } else {
       p = new((void*) gvp) SCMD_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCMD_t;
     } else {
       p = new((void*) gvp) SCMD_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCMD_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_304_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SCMD_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SCMD_t(*(SCMD_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCMD_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SCMD_t G__TSCMD_t;
static int G__bankvarsDict_304_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SCMD_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SCMD_t*) (soff+(sizeof(SCMD_t)*i)))->~G__TSCMD_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SCMD_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SCMD_t*) (soff))->~G__TSCMD_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_304_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCMD_t* dest = (SCMD_t*) G__getstructoffset();
   *dest = *(SCMD_t*) libp->para[0].ref;
   const SCMD_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SCMT_t */
// automatic default constructor
static int G__bankvarsDict_305_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCMT_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCMT_t[n];
     } else {
       p = new((void*) gvp) SCMT_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCMT_t;
     } else {
       p = new((void*) gvp) SCMT_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCMT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_305_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SCMT_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SCMT_t(*(SCMT_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCMT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SCMT_t G__TSCMT_t;
static int G__bankvarsDict_305_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SCMT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SCMT_t*) (soff+(sizeof(SCMT_t)*i)))->~G__TSCMT_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SCMT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SCMT_t*) (soff))->~G__TSCMT_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_305_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCMT_t* dest = (SCMT_t*) G__getstructoffset();
   *dest = *(SCMT_t*) libp->para[0].ref;
   const SCMT_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SCMW_t */
// automatic default constructor
static int G__bankvarsDict_306_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCMW_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCMW_t[n];
     } else {
       p = new((void*) gvp) SCMW_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCMW_t;
     } else {
       p = new((void*) gvp) SCMW_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCMW_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_306_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SCMW_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SCMW_t(*(SCMW_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCMW_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SCMW_t G__TSCMW_t;
static int G__bankvarsDict_306_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SCMW_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SCMW_t*) (soff+(sizeof(SCMW_t)*i)))->~G__TSCMW_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SCMW_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SCMW_t*) (soff))->~G__TSCMW_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_306_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCMW_t* dest = (SCMW_t*) G__getstructoffset();
   *dest = *(SCMW_t*) libp->para[0].ref;
   const SCMW_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SCPB_t */
// automatic default constructor
static int G__bankvarsDict_307_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCPB_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCPB_t[n];
     } else {
       p = new((void*) gvp) SCPB_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCPB_t;
     } else {
       p = new((void*) gvp) SCPB_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCPB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_307_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SCPB_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SCPB_t(*(SCPB_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCPB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SCPB_t G__TSCPB_t;
static int G__bankvarsDict_307_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SCPB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SCPB_t*) (soff+(sizeof(SCPB_t)*i)))->~G__TSCPB_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SCPB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SCPB_t*) (soff))->~G__TSCPB_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_307_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCPB_t* dest = (SCPB_t*) G__getstructoffset();
   *dest = *(SCPB_t*) libp->para[0].ref;
   const SCPB_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SCP_t */
// automatic default constructor
static int G__bankvarsDict_308_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCP_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCP_t[n];
     } else {
       p = new((void*) gvp) SCP_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCP_t;
     } else {
       p = new((void*) gvp) SCP_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCP_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_308_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SCP_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SCP_t(*(SCP_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCP_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SCP_t G__TSCP_t;
static int G__bankvarsDict_308_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SCP_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SCP_t*) (soff+(sizeof(SCP_t)*i)))->~G__TSCP_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SCP_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SCP_t*) (soff))->~G__TSCP_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_308_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCP_t* dest = (SCP_t*) G__getstructoffset();
   *dest = *(SCP_t*) libp->para[0].ref;
   const SCP_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SCPE_t */
// automatic default constructor
static int G__bankvarsDict_309_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCPE_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCPE_t[n];
     } else {
       p = new((void*) gvp) SCPE_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCPE_t;
     } else {
       p = new((void*) gvp) SCPE_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCPE_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_309_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SCPE_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SCPE_t(*(SCPE_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCPE_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SCPE_t G__TSCPE_t;
static int G__bankvarsDict_309_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SCPE_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SCPE_t*) (soff+(sizeof(SCPE_t)*i)))->~G__TSCPE_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SCPE_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SCPE_t*) (soff))->~G__TSCPE_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_309_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCPE_t* dest = (SCPE_t*) G__getstructoffset();
   *dest = *(SCPE_t*) libp->para[0].ref;
   const SCPE_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SCPS_t */
// automatic default constructor
static int G__bankvarsDict_310_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCPS_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCPS_t[n];
     } else {
       p = new((void*) gvp) SCPS_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCPS_t;
     } else {
       p = new((void*) gvp) SCPS_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCPS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_310_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SCPS_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SCPS_t(*(SCPS_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCPS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SCPS_t G__TSCPS_t;
static int G__bankvarsDict_310_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SCPS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SCPS_t*) (soff+(sizeof(SCPS_t)*i)))->~G__TSCPS_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SCPS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SCPS_t*) (soff))->~G__TSCPS_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_310_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCPS_t* dest = (SCPS_t*) G__getstructoffset();
   *dest = *(SCPS_t*) libp->para[0].ref;
   const SCPS_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SCRC_t */
// automatic default constructor
static int G__bankvarsDict_311_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCRC_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCRC_t[n];
     } else {
       p = new((void*) gvp) SCRC_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCRC_t;
     } else {
       p = new((void*) gvp) SCRC_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCRC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_311_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SCRC_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SCRC_t(*(SCRC_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCRC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SCRC_t G__TSCRC_t;
static int G__bankvarsDict_311_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SCRC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SCRC_t*) (soff+(sizeof(SCRC_t)*i)))->~G__TSCRC_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SCRC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SCRC_t*) (soff))->~G__TSCRC_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_311_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCRC_t* dest = (SCRC_t*) G__getstructoffset();
   *dest = *(SCRC_t*) libp->para[0].ref;
   const SCRC_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SCR_t */
// automatic default constructor
static int G__bankvarsDict_312_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCR_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCR_t[n];
     } else {
       p = new((void*) gvp) SCR_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCR_t;
     } else {
       p = new((void*) gvp) SCR_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_312_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SCR_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SCR_t(*(SCR_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SCR_t G__TSCR_t;
static int G__bankvarsDict_312_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SCR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SCR_t*) (soff+(sizeof(SCR_t)*i)))->~G__TSCR_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SCR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SCR_t*) (soff))->~G__TSCR_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_312_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCR_t* dest = (SCR_t*) G__getstructoffset();
   *dest = *(SCR_t*) libp->para[0].ref;
   const SCR_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SCS_t */
// automatic default constructor
static int G__bankvarsDict_313_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCS_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCS_t[n];
     } else {
       p = new((void*) gvp) SCS_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCS_t;
     } else {
       p = new((void*) gvp) SCS_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_313_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SCS_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SCS_t(*(SCS_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SCS_t G__TSCS_t;
static int G__bankvarsDict_313_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SCS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SCS_t*) (soff+(sizeof(SCS_t)*i)))->~G__TSCS_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SCS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SCS_t*) (soff))->~G__TSCS_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_313_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCS_t* dest = (SCS_t*) G__getstructoffset();
   *dest = *(SCS_t*) libp->para[0].ref;
   const SCS_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SCT_t */
// automatic default constructor
static int G__bankvarsDict_314_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCT_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCT_t[n];
     } else {
       p = new((void*) gvp) SCT_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SCT_t;
     } else {
       p = new((void*) gvp) SCT_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_314_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SCT_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SCT_t(*(SCT_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SCT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SCT_t G__TSCT_t;
static int G__bankvarsDict_314_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SCT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SCT_t*) (soff+(sizeof(SCT_t)*i)))->~G__TSCT_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SCT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SCT_t*) (soff))->~G__TSCT_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_314_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SCT_t* dest = (SCT_t*) G__getstructoffset();
   *dest = *(SCT_t*) libp->para[0].ref;
   const SCT_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SGMP_t */
// automatic default constructor
static int G__bankvarsDict_315_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SGMP_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SGMP_t[n];
     } else {
       p = new((void*) gvp) SGMP_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SGMP_t;
     } else {
       p = new((void*) gvp) SGMP_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SGMP_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_315_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SGMP_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SGMP_t(*(SGMP_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SGMP_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SGMP_t G__TSGMP_t;
static int G__bankvarsDict_315_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SGMP_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SGMP_t*) (soff+(sizeof(SGMP_t)*i)))->~G__TSGMP_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SGMP_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SGMP_t*) (soff))->~G__TSGMP_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_315_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SGMP_t* dest = (SGMP_t*) G__getstructoffset();
   *dest = *(SGMP_t*) libp->para[0].ref;
   const SGMP_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SPAR_t */
// automatic default constructor
static int G__bankvarsDict_316_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SPAR_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SPAR_t[n];
     } else {
       p = new((void*) gvp) SPAR_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SPAR_t;
     } else {
       p = new((void*) gvp) SPAR_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SPAR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_316_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SPAR_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SPAR_t(*(SPAR_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SPAR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SPAR_t G__TSPAR_t;
static int G__bankvarsDict_316_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SPAR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SPAR_t*) (soff+(sizeof(SPAR_t)*i)))->~G__TSPAR_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SPAR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SPAR_t*) (soff))->~G__TSPAR_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_316_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SPAR_t* dest = (SPAR_t*) G__getstructoffset();
   *dest = *(SPAR_t*) libp->para[0].ref;
   const SPAR_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SPIN_t */
// automatic default constructor
static int G__bankvarsDict_317_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SPIN_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SPIN_t[n];
     } else {
       p = new((void*) gvp) SPIN_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SPIN_t;
     } else {
       p = new((void*) gvp) SPIN_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SPIN_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_317_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SPIN_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SPIN_t(*(SPIN_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SPIN_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SPIN_t G__TSPIN_t;
static int G__bankvarsDict_317_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SPIN_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SPIN_t*) (soff+(sizeof(SPIN_t)*i)))->~G__TSPIN_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SPIN_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SPIN_t*) (soff))->~G__TSPIN_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_317_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SPIN_t* dest = (SPIN_t*) G__getstructoffset();
   *dest = *(SPIN_t*) libp->para[0].ref;
   const SPIN_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ST1_t */
// automatic default constructor
static int G__bankvarsDict_318_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ST1_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ST1_t[n];
     } else {
       p = new((void*) gvp) ST1_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ST1_t;
     } else {
       p = new((void*) gvp) ST1_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ST1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_318_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ST1_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ST1_t(*(ST1_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ST1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ST1_t G__TST1_t;
static int G__bankvarsDict_318_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ST1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ST1_t*) (soff+(sizeof(ST1_t)*i)))->~G__TST1_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ST1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ST1_t*) (soff))->~G__TST1_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_318_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ST1_t* dest = (ST1_t*) G__getstructoffset();
   *dest = *(ST1_t*) libp->para[0].ref;
   const ST1_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ST_t */
// automatic default constructor
static int G__bankvarsDict_319_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ST_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ST_t[n];
     } else {
       p = new((void*) gvp) ST_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ST_t;
     } else {
       p = new((void*) gvp) ST_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ST_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_319_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ST_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ST_t(*(ST_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_ST_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ST_t G__TST_t;
static int G__bankvarsDict_319_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ST_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ST_t*) (soff+(sizeof(ST_t)*i)))->~G__TST_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ST_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ST_t*) (soff))->~G__TST_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_319_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ST_t* dest = (ST_t*) G__getstructoffset();
   *dest = *(ST_t*) libp->para[0].ref;
   const ST_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* STG_t */
// automatic default constructor
static int G__bankvarsDict_320_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STG_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STG_t[n];
     } else {
       p = new((void*) gvp) STG_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STG_t;
     } else {
       p = new((void*) gvp) STG_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STG_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_320_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   STG_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new STG_t(*(STG_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STG_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef STG_t G__TSTG_t;
static int G__bankvarsDict_320_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (STG_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((STG_t*) (soff+(sizeof(STG_t)*i)))->~G__TSTG_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (STG_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((STG_t*) (soff))->~G__TSTG_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_320_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STG_t* dest = (STG_t*) G__getstructoffset();
   *dest = *(STG_t*) libp->para[0].ref;
   const STG_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* STH_t */
// automatic default constructor
static int G__bankvarsDict_321_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STH_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STH_t[n];
     } else {
       p = new((void*) gvp) STH_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STH_t;
     } else {
       p = new((void*) gvp) STH_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STH_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_321_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   STH_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new STH_t(*(STH_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STH_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef STH_t G__TSTH_t;
static int G__bankvarsDict_321_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (STH_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((STH_t*) (soff+(sizeof(STH_t)*i)))->~G__TSTH_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (STH_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((STH_t*) (soff))->~G__TSTH_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_321_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STH_t* dest = (STH_t*) G__getstructoffset();
   *dest = *(STH_t*) libp->para[0].ref;
   const STH_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* STN0_t */
// automatic default constructor
static int G__bankvarsDict_322_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STN0_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STN0_t[n];
     } else {
       p = new((void*) gvp) STN0_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STN0_t;
     } else {
       p = new((void*) gvp) STN0_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STN0_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_322_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   STN0_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new STN0_t(*(STN0_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STN0_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef STN0_t G__TSTN0_t;
static int G__bankvarsDict_322_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (STN0_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((STN0_t*) (soff+(sizeof(STN0_t)*i)))->~G__TSTN0_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (STN0_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((STN0_t*) (soff))->~G__TSTN0_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_322_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STN0_t* dest = (STN0_t*) G__getstructoffset();
   *dest = *(STN0_t*) libp->para[0].ref;
   const STN0_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* STN1_t */
// automatic default constructor
static int G__bankvarsDict_323_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STN1_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STN1_t[n];
     } else {
       p = new((void*) gvp) STN1_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STN1_t;
     } else {
       p = new((void*) gvp) STN1_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STN1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_323_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   STN1_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new STN1_t(*(STN1_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STN1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef STN1_t G__TSTN1_t;
static int G__bankvarsDict_323_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (STN1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((STN1_t*) (soff+(sizeof(STN1_t)*i)))->~G__TSTN1_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (STN1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((STN1_t*) (soff))->~G__TSTN1_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_323_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STN1_t* dest = (STN1_t*) G__getstructoffset();
   *dest = *(STN1_t*) libp->para[0].ref;
   const STN1_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* STPB_t */
// automatic default constructor
static int G__bankvarsDict_324_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STPB_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STPB_t[n];
     } else {
       p = new((void*) gvp) STPB_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STPB_t;
     } else {
       p = new((void*) gvp) STPB_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STPB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_324_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   STPB_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new STPB_t(*(STPB_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STPB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef STPB_t G__TSTPB_t;
static int G__bankvarsDict_324_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (STPB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((STPB_t*) (soff+(sizeof(STPB_t)*i)))->~G__TSTPB_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (STPB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((STPB_t*) (soff))->~G__TSTPB_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_324_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STPB_t* dest = (STPB_t*) G__getstructoffset();
   *dest = *(STPB_t*) libp->para[0].ref;
   const STPB_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* STPE_t */
// automatic default constructor
static int G__bankvarsDict_325_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STPE_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STPE_t[n];
     } else {
       p = new((void*) gvp) STPE_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STPE_t;
     } else {
       p = new((void*) gvp) STPE_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STPE_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_325_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   STPE_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new STPE_t(*(STPE_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STPE_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef STPE_t G__TSTPE_t;
static int G__bankvarsDict_325_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (STPE_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((STPE_t*) (soff+(sizeof(STPE_t)*i)))->~G__TSTPE_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (STPE_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((STPE_t*) (soff))->~G__TSTPE_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_325_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STPE_t* dest = (STPE_t*) G__getstructoffset();
   *dest = *(STPE_t*) libp->para[0].ref;
   const STPE_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* STR_t */
// automatic default constructor
static int G__bankvarsDict_326_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STR_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STR_t[n];
     } else {
       p = new((void*) gvp) STR_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STR_t;
     } else {
       p = new((void*) gvp) STR_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_326_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   STR_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new STR_t(*(STR_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef STR_t G__TSTR_t;
static int G__bankvarsDict_326_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (STR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((STR_t*) (soff+(sizeof(STR_t)*i)))->~G__TSTR_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (STR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((STR_t*) (soff))->~G__TSTR_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_326_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STR_t* dest = (STR_t*) G__getstructoffset();
   *dest = *(STR_t*) libp->para[0].ref;
   const STR_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* STS_t */
// automatic default constructor
static int G__bankvarsDict_327_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STS_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STS_t[n];
     } else {
       p = new((void*) gvp) STS_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STS_t;
     } else {
       p = new((void*) gvp) STS_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_327_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   STS_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new STS_t(*(STS_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef STS_t G__TSTS_t;
static int G__bankvarsDict_327_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (STS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((STS_t*) (soff+(sizeof(STS_t)*i)))->~G__TSTS_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (STS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((STS_t*) (soff))->~G__TSTS_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_327_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STS_t* dest = (STS_t*) G__getstructoffset();
   *dest = *(STS_t*) libp->para[0].ref;
   const STS_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* STSN_t */
// automatic default constructor
static int G__bankvarsDict_328_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STSN_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STSN_t[n];
     } else {
       p = new((void*) gvp) STSN_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STSN_t;
     } else {
       p = new((void*) gvp) STSN_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STSN_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_328_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   STSN_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new STSN_t(*(STSN_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STSN_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef STSN_t G__TSTSN_t;
static int G__bankvarsDict_328_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (STSN_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((STSN_t*) (soff+(sizeof(STSN_t)*i)))->~G__TSTSN_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (STSN_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((STSN_t*) (soff))->~G__TSTSN_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_328_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STSN_t* dest = (STSN_t*) G__getstructoffset();
   *dest = *(STSN_t*) libp->para[0].ref;
   const STSN_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SYNC_t */
// automatic default constructor
static int G__bankvarsDict_329_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SYNC_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SYNC_t[n];
     } else {
       p = new((void*) gvp) SYNC_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SYNC_t;
     } else {
       p = new((void*) gvp) SYNC_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SYNC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_329_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SYNC_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SYNC_t(*(SYNC_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_SYNC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SYNC_t G__TSYNC_t;
static int G__bankvarsDict_329_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SYNC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SYNC_t*) (soff+(sizeof(SYNC_t)*i)))->~G__TSYNC_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SYNC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SYNC_t*) (soff))->~G__TSYNC_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_329_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SYNC_t* dest = (SYNC_t*) G__getstructoffset();
   *dest = *(SYNC_t*) libp->para[0].ref;
   const SYNC_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TACO_t */
// automatic default constructor
static int G__bankvarsDict_330_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TACO_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TACO_t[n];
     } else {
       p = new((void*) gvp) TACO_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TACO_t;
     } else {
       p = new((void*) gvp) TACO_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TACO_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_330_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TACO_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TACO_t(*(TACO_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TACO_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TACO_t G__TTACO_t;
static int G__bankvarsDict_330_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TACO_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TACO_t*) (soff+(sizeof(TACO_t)*i)))->~G__TTACO_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TACO_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TACO_t*) (soff))->~G__TTACO_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_330_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TACO_t* dest = (TACO_t*) G__getstructoffset();
   *dest = *(TACO_t*) libp->para[0].ref;
   const TACO_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TAGE_t */
// automatic default constructor
static int G__bankvarsDict_331_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TAGE_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TAGE_t[n];
     } else {
       p = new((void*) gvp) TAGE_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TAGE_t;
     } else {
       p = new((void*) gvp) TAGE_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TAGE_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_331_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TAGE_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TAGE_t(*(TAGE_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TAGE_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TAGE_t G__TTAGE_t;
static int G__bankvarsDict_331_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TAGE_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TAGE_t*) (soff+(sizeof(TAGE_t)*i)))->~G__TTAGE_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TAGE_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TAGE_t*) (soff))->~G__TTAGE_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_331_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TAGE_t* dest = (TAGE_t*) G__getstructoffset();
   *dest = *(TAGE_t*) libp->para[0].ref;
   const TAGE_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TAGI_t */
// automatic default constructor
static int G__bankvarsDict_332_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TAGI_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TAGI_t[n];
     } else {
       p = new((void*) gvp) TAGI_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TAGI_t;
     } else {
       p = new((void*) gvp) TAGI_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TAGI_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_332_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TAGI_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TAGI_t(*(TAGI_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TAGI_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TAGI_t G__TTAGI_t;
static int G__bankvarsDict_332_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TAGI_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TAGI_t*) (soff+(sizeof(TAGI_t)*i)))->~G__TTAGI_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TAGI_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TAGI_t*) (soff))->~G__TTAGI_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_332_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TAGI_t* dest = (TAGI_t*) G__getstructoffset();
   *dest = *(TAGI_t*) libp->para[0].ref;
   const TAGI_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TAGM_t */
// automatic default constructor
static int G__bankvarsDict_333_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TAGM_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TAGM_t[n];
     } else {
       p = new((void*) gvp) TAGM_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TAGM_t;
     } else {
       p = new((void*) gvp) TAGM_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TAGM_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_333_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TAGM_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TAGM_t(*(TAGM_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TAGM_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TAGM_t G__TTAGM_t;
static int G__bankvarsDict_333_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TAGM_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TAGM_t*) (soff+(sizeof(TAGM_t)*i)))->~G__TTAGM_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TAGM_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TAGM_t*) (soff))->~G__TTAGM_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_333_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TAGM_t* dest = (TAGM_t*) G__getstructoffset();
   *dest = *(TAGM_t*) libp->para[0].ref;
   const TAGM_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TAGR_t */
// automatic default constructor
static int G__bankvarsDict_334_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TAGR_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TAGR_t[n];
     } else {
       p = new((void*) gvp) TAGR_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TAGR_t;
     } else {
       p = new((void*) gvp) TAGR_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TAGR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_334_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TAGR_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TAGR_t(*(TAGR_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TAGR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TAGR_t G__TTAGR_t;
static int G__bankvarsDict_334_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TAGR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TAGR_t*) (soff+(sizeof(TAGR_t)*i)))->~G__TTAGR_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TAGR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TAGR_t*) (soff))->~G__TTAGR_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_334_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TAGR_t* dest = (TAGR_t*) G__getstructoffset();
   *dest = *(TAGR_t*) libp->para[0].ref;
   const TAGR_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TAGT_t */
// automatic default constructor
static int G__bankvarsDict_335_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TAGT_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TAGT_t[n];
     } else {
       p = new((void*) gvp) TAGT_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TAGT_t;
     } else {
       p = new((void*) gvp) TAGT_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TAGT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_335_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TAGT_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TAGT_t(*(TAGT_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TAGT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TAGT_t G__TTAGT_t;
static int G__bankvarsDict_335_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TAGT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TAGT_t*) (soff+(sizeof(TAGT_t)*i)))->~G__TTAGT_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TAGT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TAGT_t*) (soff))->~G__TTAGT_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_335_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TAGT_t* dest = (TAGT_t*) G__getstructoffset();
   *dest = *(TAGT_t*) libp->para[0].ref;
   const TAGT_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TATL_t */
// automatic default constructor
static int G__bankvarsDict_336_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TATL_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TATL_t[n];
     } else {
       p = new((void*) gvp) TATL_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TATL_t;
     } else {
       p = new((void*) gvp) TATL_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TATL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_336_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TATL_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TATL_t(*(TATL_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TATL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TATL_t G__TTATL_t;
static int G__bankvarsDict_336_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TATL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TATL_t*) (soff+(sizeof(TATL_t)*i)))->~G__TTATL_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TATL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TATL_t*) (soff))->~G__TTATL_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_336_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TATL_t* dest = (TATL_t*) G__getstructoffset();
   *dest = *(TATL_t*) libp->para[0].ref;
   const TATL_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TATR_t */
// automatic default constructor
static int G__bankvarsDict_337_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TATR_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TATR_t[n];
     } else {
       p = new((void*) gvp) TATR_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TATR_t;
     } else {
       p = new((void*) gvp) TATR_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TATR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_337_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TATR_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TATR_t(*(TATR_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TATR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TATR_t G__TTATR_t;
static int G__bankvarsDict_337_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TATR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TATR_t*) (soff+(sizeof(TATR_t)*i)))->~G__TTATR_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TATR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TATR_t*) (soff))->~G__TTATR_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_337_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TATR_t* dest = (TATR_t*) G__getstructoffset();
   *dest = *(TATR_t*) libp->para[0].ref;
   const TATR_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TBER_t */
// automatic default constructor
static int G__bankvarsDict_338_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TBER_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TBER_t[n];
     } else {
       p = new((void*) gvp) TBER_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TBER_t;
     } else {
       p = new((void*) gvp) TBER_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TBER_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_338_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TBER_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TBER_t(*(TBER_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TBER_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TBER_t G__TTBER_t;
static int G__bankvarsDict_338_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TBER_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TBER_t*) (soff+(sizeof(TBER_t)*i)))->~G__TTBER_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TBER_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TBER_t*) (soff))->~G__TTBER_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_338_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TBER_t* dest = (TBER_t*) G__getstructoffset();
   *dest = *(TBER_t*) libp->para[0].ref;
   const TBER_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TBID_t */
// automatic default constructor
static int G__bankvarsDict_339_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TBID_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TBID_t[n];
     } else {
       p = new((void*) gvp) TBID_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TBID_t;
     } else {
       p = new((void*) gvp) TBID_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TBID_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_339_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TBID_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TBID_t(*(TBID_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TBID_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TBID_t G__TTBID_t;
static int G__bankvarsDict_339_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TBID_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TBID_t*) (soff+(sizeof(TBID_t)*i)))->~G__TTBID_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TBID_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TBID_t*) (soff))->~G__TTBID_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_339_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TBID_t* dest = (TBID_t*) G__getstructoffset();
   *dest = *(TBID_t*) libp->para[0].ref;
   const TBID_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TBLA_t */
// automatic default constructor
static int G__bankvarsDict_340_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TBLA_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TBLA_t[n];
     } else {
       p = new((void*) gvp) TBLA_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TBLA_t;
     } else {
       p = new((void*) gvp) TBLA_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TBLA_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_340_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TBLA_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TBLA_t(*(TBLA_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TBLA_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TBLA_t G__TTBLA_t;
static int G__bankvarsDict_340_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TBLA_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TBLA_t*) (soff+(sizeof(TBLA_t)*i)))->~G__TTBLA_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TBLA_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TBLA_t*) (soff))->~G__TTBLA_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_340_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TBLA_t* dest = (TBLA_t*) G__getstructoffset();
   *dest = *(TBLA_t*) libp->para[0].ref;
   const TBLA_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TBTR_t */
// automatic default constructor
static int G__bankvarsDict_341_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TBTR_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TBTR_t[n];
     } else {
       p = new((void*) gvp) TBTR_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TBTR_t;
     } else {
       p = new((void*) gvp) TBTR_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TBTR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_341_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TBTR_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TBTR_t(*(TBTR_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TBTR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TBTR_t G__TTBTR_t;
static int G__bankvarsDict_341_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TBTR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TBTR_t*) (soff+(sizeof(TBTR_t)*i)))->~G__TTBTR_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TBTR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TBTR_t*) (soff))->~G__TTBTR_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_341_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TBTR_t* dest = (TBTR_t*) G__getstructoffset();
   *dest = *(TBTR_t*) libp->para[0].ref;
   const TBTR_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TCSB_t */
// automatic default constructor
static int G__bankvarsDict_342_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TCSB_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TCSB_t[n];
     } else {
       p = new((void*) gvp) TCSB_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TCSB_t;
     } else {
       p = new((void*) gvp) TCSB_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TCSB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_342_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TCSB_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TCSB_t(*(TCSB_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TCSB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TCSB_t G__TTCSB_t;
static int G__bankvarsDict_342_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TCSB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TCSB_t*) (soff+(sizeof(TCSB_t)*i)))->~G__TTCSB_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TCSB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TCSB_t*) (soff))->~G__TTCSB_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_342_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TCSB_t* dest = (TCSB_t*) G__getstructoffset();
   *dest = *(TCSB_t*) libp->para[0].ref;
   const TCSB_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TCT_t */
// automatic default constructor
static int G__bankvarsDict_343_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TCT_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TCT_t[n];
     } else {
       p = new((void*) gvp) TCT_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TCT_t;
     } else {
       p = new((void*) gvp) TCT_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TCT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_343_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TCT_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TCT_t(*(TCT_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TCT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TCT_t G__TTCT_t;
static int G__bankvarsDict_343_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TCT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TCT_t*) (soff+(sizeof(TCT_t)*i)))->~G__TTCT_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TCT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TCT_t*) (soff))->~G__TTCT_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_343_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TCT_t* dest = (TCT_t*) G__getstructoffset();
   *dest = *(TCT_t*) libp->para[0].ref;
   const TCT_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TDPL_t */
// automatic default constructor
static int G__bankvarsDict_344_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TDPL_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TDPL_t[n];
     } else {
       p = new((void*) gvp) TDPL_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TDPL_t;
     } else {
       p = new((void*) gvp) TDPL_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TDPL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_344_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TDPL_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TDPL_t(*(TDPL_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TDPL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TDPL_t G__TTDPL_t;
static int G__bankvarsDict_344_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TDPL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TDPL_t*) (soff+(sizeof(TDPL_t)*i)))->~G__TTDPL_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TDPL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TDPL_t*) (soff))->~G__TTDPL_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_344_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TDPL_t* dest = (TDPL_t*) G__getstructoffset();
   *dest = *(TDPL_t*) libp->para[0].ref;
   const TDPL_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TESC_t */
// automatic default constructor
static int G__bankvarsDict_345_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TESC_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TESC_t[n];
     } else {
       p = new((void*) gvp) TESC_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TESC_t;
     } else {
       p = new((void*) gvp) TESC_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TESC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_345_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TESC_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TESC_t(*(TESC_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TESC_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TESC_t G__TTESC_t;
static int G__bankvarsDict_345_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TESC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TESC_t*) (soff+(sizeof(TESC_t)*i)))->~G__TTESC_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TESC_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TESC_t*) (soff))->~G__TTESC_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_345_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TESC_t* dest = (TESC_t*) G__getstructoffset();
   *dest = *(TESC_t*) libp->para[0].ref;
   const TESC_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TGBI_t */
// automatic default constructor
static int G__bankvarsDict_346_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TGBI_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TGBI_t[n];
     } else {
       p = new((void*) gvp) TGBI_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TGBI_t;
     } else {
       p = new((void*) gvp) TGBI_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TGBI_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_346_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TGBI_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TGBI_t(*(TGBI_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TGBI_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TGBI_t G__TTGBI_t;
static int G__bankvarsDict_346_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TGBI_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TGBI_t*) (soff+(sizeof(TGBI_t)*i)))->~G__TTGBI_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TGBI_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TGBI_t*) (soff))->~G__TTGBI_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_346_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TGBI_t* dest = (TGBI_t*) G__getstructoffset();
   *dest = *(TGBI_t*) libp->para[0].ref;
   const TGBI_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TGEO_t */
// automatic default constructor
static int G__bankvarsDict_347_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TGEO_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TGEO_t[n];
     } else {
       p = new((void*) gvp) TGEO_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TGEO_t;
     } else {
       p = new((void*) gvp) TGEO_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TGEO_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_347_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TGEO_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TGEO_t(*(TGEO_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TGEO_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TGEO_t G__TTGEO_t;
static int G__bankvarsDict_347_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TGEO_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TGEO_t*) (soff+(sizeof(TGEO_t)*i)))->~G__TTGEO_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TGEO_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TGEO_t*) (soff))->~G__TTGEO_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_347_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TGEO_t* dest = (TGEO_t*) G__getstructoffset();
   *dest = *(TGEO_t*) libp->para[0].ref;
   const TGEO_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TGPB_t */
// automatic default constructor
static int G__bankvarsDict_348_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TGPB_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TGPB_t[n];
     } else {
       p = new((void*) gvp) TGPB_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TGPB_t;
     } else {
       p = new((void*) gvp) TGPB_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TGPB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_348_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TGPB_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TGPB_t(*(TGPB_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TGPB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TGPB_t G__TTGPB_t;
static int G__bankvarsDict_348_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TGPB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TGPB_t*) (soff+(sizeof(TGPB_t)*i)))->~G__TTGPB_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TGPB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TGPB_t*) (soff))->~G__TTGPB_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_348_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TGPB_t* dest = (TGPB_t*) G__getstructoffset();
   *dest = *(TGPB_t*) libp->para[0].ref;
   const TGPB_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TGS_t */
// automatic default constructor
static int G__bankvarsDict_349_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TGS_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TGS_t[n];
     } else {
       p = new((void*) gvp) TGS_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TGS_t;
     } else {
       p = new((void*) gvp) TGS_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TGS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_349_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TGS_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TGS_t(*(TGS_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TGS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TGS_t G__TTGS_t;
static int G__bankvarsDict_349_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TGS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TGS_t*) (soff+(sizeof(TGS_t)*i)))->~G__TTGS_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TGS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TGS_t*) (soff))->~G__TTGS_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_349_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TGS_t* dest = (TGS_t*) G__getstructoffset();
   *dest = *(TGS_t*) libp->para[0].ref;
   const TGS_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TGTL_t */
// automatic default constructor
static int G__bankvarsDict_350_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TGTL_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TGTL_t[n];
     } else {
       p = new((void*) gvp) TGTL_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TGTL_t;
     } else {
       p = new((void*) gvp) TGTL_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TGTL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_350_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TGTL_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TGTL_t(*(TGTL_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TGTL_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TGTL_t G__TTGTL_t;
static int G__bankvarsDict_350_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TGTL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TGTL_t*) (soff+(sizeof(TGTL_t)*i)))->~G__TTGTL_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TGTL_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TGTL_t*) (soff))->~G__TTGTL_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_350_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TGTL_t* dest = (TGTL_t*) G__getstructoffset();
   *dest = *(TGTL_t*) libp->para[0].ref;
   const TGTL_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TGTR_t */
// automatic default constructor
static int G__bankvarsDict_351_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TGTR_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TGTR_t[n];
     } else {
       p = new((void*) gvp) TGTR_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TGTR_t;
     } else {
       p = new((void*) gvp) TGTR_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TGTR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_351_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TGTR_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TGTR_t(*(TGTR_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TGTR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TGTR_t G__TTGTR_t;
static int G__bankvarsDict_351_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TGTR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TGTR_t*) (soff+(sizeof(TGTR_t)*i)))->~G__TTGTR_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TGTR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TGTR_t*) (soff))->~G__TTGTR_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_351_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TGTR_t* dest = (TGTR_t*) G__getstructoffset();
   *dest = *(TGTR_t*) libp->para[0].ref;
   const TGTR_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TLV1_t */
// automatic default constructor
static int G__bankvarsDict_352_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TLV1_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TLV1_t[n];
     } else {
       p = new((void*) gvp) TLV1_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TLV1_t;
     } else {
       p = new((void*) gvp) TLV1_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TLV1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_352_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TLV1_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TLV1_t(*(TLV1_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TLV1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TLV1_t G__TTLV1_t;
static int G__bankvarsDict_352_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TLV1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TLV1_t*) (soff+(sizeof(TLV1_t)*i)))->~G__TTLV1_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TLV1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TLV1_t*) (soff))->~G__TTLV1_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_352_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TLV1_t* dest = (TLV1_t*) G__getstructoffset();
   *dest = *(TLV1_t*) libp->para[0].ref;
   const TLV1_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TRCF_t */
// automatic default constructor
static int G__bankvarsDict_353_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRCF_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRCF_t[n];
     } else {
       p = new((void*) gvp) TRCF_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRCF_t;
     } else {
       p = new((void*) gvp) TRCF_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TRCF_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_353_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TRCF_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TRCF_t(*(TRCF_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TRCF_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TRCF_t G__TTRCF_t;
static int G__bankvarsDict_353_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TRCF_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TRCF_t*) (soff+(sizeof(TRCF_t)*i)))->~G__TTRCF_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TRCF_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TRCF_t*) (soff))->~G__TTRCF_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_353_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRCF_t* dest = (TRCF_t*) G__getstructoffset();
   *dest = *(TRCF_t*) libp->para[0].ref;
   const TRCF_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TRGS_t */
// automatic default constructor
static int G__bankvarsDict_354_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRGS_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRGS_t[n];
     } else {
       p = new((void*) gvp) TRGS_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRGS_t;
     } else {
       p = new((void*) gvp) TRGS_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TRGS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_354_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TRGS_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TRGS_t(*(TRGS_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TRGS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TRGS_t G__TTRGS_t;
static int G__bankvarsDict_354_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TRGS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TRGS_t*) (soff+(sizeof(TRGS_t)*i)))->~G__TTRGS_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TRGS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TRGS_t*) (soff))->~G__TTRGS_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_354_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRGS_t* dest = (TRGS_t*) G__getstructoffset();
   *dest = *(TRGS_t*) libp->para[0].ref;
   const TRGS_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TRKS_t */
// automatic default constructor
static int G__bankvarsDict_355_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRKS_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRKS_t[n];
     } else {
       p = new((void*) gvp) TRKS_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRKS_t;
     } else {
       p = new((void*) gvp) TRKS_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TRKS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_355_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TRKS_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TRKS_t(*(TRKS_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TRKS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TRKS_t G__TTRKS_t;
static int G__bankvarsDict_355_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TRKS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TRKS_t*) (soff+(sizeof(TRKS_t)*i)))->~G__TTRKS_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TRKS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TRKS_t*) (soff))->~G__TTRKS_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_355_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRKS_t* dest = (TRKS_t*) G__getstructoffset();
   *dest = *(TRKS_t*) libp->para[0].ref;
   const TRKS_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TRL1_t */
// automatic default constructor
static int G__bankvarsDict_356_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRL1_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRL1_t[n];
     } else {
       p = new((void*) gvp) TRL1_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRL1_t;
     } else {
       p = new((void*) gvp) TRL1_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TRL1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_356_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TRL1_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TRL1_t(*(TRL1_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TRL1_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TRL1_t G__TTRL1_t;
static int G__bankvarsDict_356_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TRL1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TRL1_t*) (soff+(sizeof(TRL1_t)*i)))->~G__TTRL1_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TRL1_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TRL1_t*) (soff))->~G__TTRL1_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_356_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRL1_t* dest = (TRL1_t*) G__getstructoffset();
   *dest = *(TRL1_t*) libp->para[0].ref;
   const TRL1_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TRPB_t */
// automatic default constructor
static int G__bankvarsDict_357_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRPB_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRPB_t[n];
     } else {
       p = new((void*) gvp) TRPB_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRPB_t;
     } else {
       p = new((void*) gvp) TRPB_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TRPB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_357_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TRPB_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TRPB_t(*(TRPB_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TRPB_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TRPB_t G__TTRPB_t;
static int G__bankvarsDict_357_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TRPB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TRPB_t*) (soff+(sizeof(TRPB_t)*i)))->~G__TTRPB_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TRPB_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TRPB_t*) (soff))->~G__TTRPB_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_357_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRPB_t* dest = (TRPB_t*) G__getstructoffset();
   *dest = *(TRPB_t*) libp->para[0].ref;
   const TRPB_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TSPR_t */
// automatic default constructor
static int G__bankvarsDict_358_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TSPR_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TSPR_t[n];
     } else {
       p = new((void*) gvp) TSPR_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TSPR_t;
     } else {
       p = new((void*) gvp) TSPR_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TSPR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_358_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TSPR_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TSPR_t(*(TSPR_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TSPR_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TSPR_t G__TTSPR_t;
static int G__bankvarsDict_358_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TSPR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TSPR_t*) (soff+(sizeof(TSPR_t)*i)))->~G__TTSPR_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TSPR_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TSPR_t*) (soff))->~G__TTSPR_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_358_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TSPR_t* dest = (TSPR_t*) G__getstructoffset();
   *dest = *(TSPR_t*) libp->para[0].ref;
   const TSPR_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TSRG_t */
// automatic default constructor
static int G__bankvarsDict_359_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TSRG_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TSRG_t[n];
     } else {
       p = new((void*) gvp) TSRG_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TSRG_t;
     } else {
       p = new((void*) gvp) TSRG_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TSRG_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_359_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TSRG_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TSRG_t(*(TSRG_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_TSRG_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TSRG_t G__TTSRG_t;
static int G__bankvarsDict_359_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TSRG_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TSRG_t*) (soff+(sizeof(TSRG_t)*i)))->~G__TTSRG_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TSRG_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TSRG_t*) (soff))->~G__TTSRG_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_359_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TSRG_t* dest = (TSRG_t*) G__getstructoffset();
   *dest = *(TSRG_t*) libp->para[0].ref;
   const TSRG_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* UNUS_t */
// automatic default constructor
static int G__bankvarsDict_360_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   UNUS_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new UNUS_t[n];
     } else {
       p = new((void*) gvp) UNUS_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new UNUS_t;
     } else {
       p = new((void*) gvp) UNUS_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_UNUS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_360_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   UNUS_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new UNUS_t(*(UNUS_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_UNUS_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef UNUS_t G__TUNUS_t;
static int G__bankvarsDict_360_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (UNUS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((UNUS_t*) (soff+(sizeof(UNUS_t)*i)))->~G__TUNUS_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (UNUS_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((UNUS_t*) (soff))->~G__TUNUS_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_360_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   UNUS_t* dest = (UNUS_t*) G__getstructoffset();
   *dest = *(UNUS_t*) libp->para[0].ref;
   const UNUS_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* VERT_t */
// automatic default constructor
static int G__bankvarsDict_361_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   VERT_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new VERT_t[n];
     } else {
       p = new((void*) gvp) VERT_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new VERT_t;
     } else {
       p = new((void*) gvp) VERT_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_VERT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_361_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   VERT_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new VERT_t(*(VERT_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_VERT_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef VERT_t G__TVERT_t;
static int G__bankvarsDict_361_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (VERT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((VERT_t*) (soff+(sizeof(VERT_t)*i)))->~G__TVERT_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (VERT_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((VERT_t*) (soff))->~G__TVERT_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_361_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   VERT_t* dest = (VERT_t*) G__getstructoffset();
   *dest = *(VERT_t*) libp->para[0].ref;
   const VERT_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* RC26_t */
// automatic default constructor
static int G__bankvarsDict_362_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RC26_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RC26_t[n];
     } else {
       p = new((void*) gvp) RC26_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new RC26_t;
     } else {
       p = new((void*) gvp) RC26_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RC26_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_362_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   RC26_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new RC26_t(*(RC26_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_RC26_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef RC26_t G__TRC26_t;
static int G__bankvarsDict_362_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (RC26_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((RC26_t*) (soff+(sizeof(RC26_t)*i)))->~G__TRC26_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (RC26_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((RC26_t*) (soff))->~G__TRC26_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_362_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   RC26_t* dest = (RC26_t*) G__getstructoffset();
   *dest = *(RC26_t*) libp->para[0].ref;
   const RC26_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* STRE_t */
// automatic default constructor
static int G__bankvarsDict_363_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STRE_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STRE_t[n];
     } else {
       p = new((void*) gvp) STRE_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new STRE_t;
     } else {
       p = new((void*) gvp) STRE_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STRE_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_363_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   STRE_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new STRE_t(*(STRE_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_STRE_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef STRE_t G__TSTRE_t;
static int G__bankvarsDict_363_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (STRE_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((STRE_t*) (soff+(sizeof(STRE_t)*i)))->~G__TSTRE_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (STRE_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((STRE_t*) (soff))->~G__TSTRE_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_363_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   STRE_t* dest = (STRE_t*) G__getstructoffset();
   *dest = *(STRE_t*) libp->para[0].ref;
   const STRE_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* addressBanks_t */
// automatic default constructor
static int G__bankvarsDict_368_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   addressBanks_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new addressBanks_t[n];
     } else {
       p = new((void*) gvp) addressBanks_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new addressBanks_t;
     } else {
       p = new((void*) gvp) addressBanks_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_addressBanks_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__bankvarsDict_368_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   addressBanks_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new addressBanks_t(*(addressBanks_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__bankvarsDictLN_addressBanks_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef addressBanks_t G__TaddressBanks_t;
static int G__bankvarsDict_368_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (addressBanks_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((addressBanks_t*) (soff+(sizeof(addressBanks_t)*i)))->~G__TaddressBanks_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (addressBanks_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((addressBanks_t*) (soff))->~G__TaddressBanks_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__bankvarsDict_368_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   addressBanks_t* dest = (addressBanks_t*) G__getstructoffset();
   *dest = *(addressBanks_t*) libp->para[0].ref;
   const addressBanks_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */

/*********************************************************
* Member function Stub
*********************************************************/

/* BEAM_t */

/* BMPR_t */

/* BREP_t */

/* CALB_t */

/* CALL_t */

/* CC01_t */

/* CC1_t */

/* CC_t */

/* CCDI_t */

/* CCH_t */

/* CCMT_t */

/* CCPB_t */

/* CCPE_t */

/* CCRC_t */

/* CCS_t */

/* CCT_t */

/* CHI2_t */

/* CL01_t */

/* CLST_t */

/* CPED_t */

/* CSQL_t */

/* DC0_t */

/* DC1_t */

/* DCDW_t */

/* DCGM_t */

/* DCGW_t */

/* DCH_t */

/* DCMN_t */

/* DCPB_t */

/* DCV1_t */

/* DCV2_t */

/* DCV3_t */

/* DDLY_t */

/* DGEO_t */

/* DHCL_t */

/* DITM_t */

/* DOCA_t */

/* DPCP_t */

/* DPSP_t */

/* DSPC_t */

/* DSPS_t */

/* DSTC_t */

/* DTCP_t */

/* DTRK_t */

/* EC01_t */

/* EC1_t */

/* EC1P_t */

/* EC1R_t */

/* ECCA_t */

/* ECCL_t */

/* ECCT_t */

/* EC_t */

/* ECDI_t */

/* ECG_t */

/* ECHB_t */

/* ECH_t */

/* ECMT_t */

/* ECP1_t */

/* ECPB_t */

/* ECPC_t */

/* ECP_t */

/* ECPE_t */

/* ECPI_t */

/* ECPO_t */

/* ECRB_t */

/* ECS_t */

/* ECT_t */

/* EID0_t */

/* EPIC_t */

/* EVNT_t */

/* FBPM_t */

/* G1SL_t */

/* G2SL_t */

/* G3SL_t */

/* G4SL_t */

/* GPAR_t */

/* GPID_t */

/* GP_X_t */

/* GP_Y_t */

/* HBER_t */

/* HBID_t */

/* HBLA_t */

/* HBTB_t */

/* HBTR_t */

/* HCAL_t */

/* HDPL_t */

/* HEAD_t */

/* HEVT_t */

/* HLS_t */

/* IC_t */

/* ICHB_t */

/* KFIT_t */

/* L1PG_t */

/* L2H_t */

/* L2S_t */

/* LASR_t */

/* LCDI_t */

/* LCPB_t */

/* LOWQ_t */

/* MCEV_t */

/* MCHD_t */

/* MCTK_t */

/* MCVX_t */

/* MS1_t */

/* MTRK_t */

/* MVRT_t */

/* PART_t */

/* PCO_t */

/* PHTM_t */

/* PID1_t */

/* PID2_t */

/* PID3_t */

/* PID4_t */

/* PID5_t */

/* PID6_t */

/* PIDT_t */

/* PRTM_t */

/* PSO_t */

/* PTDB_t */

/* RCST_t */

/* REF_t */

/* RF_t */

/* RFT_t */

/* RGLK_t */

/* RNLG_t */

/* RNPE_t */

/* RTSL_t */

/* RUNC_t */

/* S1ST_t */

/* SC1_t */

/* SCC_t */

/* SC_t */

/* SCDI_t */

/* SCGD_t */

/* SCG_t */

/* SCH_t */

/* SCMD_t */

/* SCMT_t */

/* SCMW_t */

/* SCPB_t */

/* SCP_t */

/* SCPE_t */

/* SCPS_t */

/* SCRC_t */

/* SCR_t */

/* SCS_t */

/* SCT_t */

/* SGMP_t */

/* SPAR_t */

/* SPIN_t */

/* ST1_t */

/* ST_t */

/* STG_t */

/* STH_t */

/* STN0_t */

/* STN1_t */

/* STPB_t */

/* STPE_t */

/* STR_t */

/* STS_t */

/* STSN_t */

/* SYNC_t */

/* TACO_t */

/* TAGE_t */

/* TAGI_t */

/* TAGM_t */

/* TAGR_t */

/* TAGT_t */

/* TATL_t */

/* TATR_t */

/* TBER_t */

/* TBID_t */

/* TBLA_t */

/* TBTR_t */

/* TCSB_t */

/* TCT_t */

/* TDPL_t */

/* TESC_t */

/* TGBI_t */

/* TGEO_t */

/* TGPB_t */

/* TGS_t */

/* TGTL_t */

/* TGTR_t */

/* TLV1_t */

/* TRCF_t */

/* TRGS_t */

/* TRKS_t */

/* TRL1_t */

/* TRPB_t */

/* TSPR_t */

/* TSRG_t */

/* UNUS_t */

/* VERT_t */

/* RC26_t */

/* STRE_t */

/* addressBanks_t */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncbankvarsDict {
 public:
  G__Sizep2memfuncbankvarsDict(): p(&G__Sizep2memfuncbankvarsDict::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncbankvarsDict::*p)();
};

size_t G__get_sizep2memfuncbankvarsDict()
{
  G__Sizep2memfuncbankvarsDict a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritancebankvarsDict() {

   /* Setting up class inheritance */
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetablebankvarsDict() {

   /* Setting up typedef entry */
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__bankvarsDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__bankvarsDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__bankvarsDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__bankvarsDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__bankvarsDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__bankvarsDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__bankvarsDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__bankvarsDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__bankvarsDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__bankvarsDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<UInt_t>",117,G__get_linked_tagnum(&G__bankvarsDictLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TString>",117,G__get_linked_tagnum(&G__bankvarsDictLN_vectorlETStringcOallocatorlETStringgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__bankvarsDictLN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__bankvarsDictLN_vectorlETStringcOallocatorlETStringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__bankvarsDictLN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__bankvarsDictLN_vectorlETStringcOallocatorlETStringgRsPgR));
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* BEAM_t */
static void G__setup_memvarBEAM_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_BEAM_t));
   { BEAM_t *p; p=(BEAM_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ENERGY)-(long)(p)),102,0,0,-1,-1,-1,1,"ENERGY=",0,"Electron beam energy in GeV");
   G__memvar_setup((void*)((long)(&p->ITORUS)-(long)(p)),102,0,0,-1,-1,-1,1,"ITORUS=",0,"Torus magnet current in Amps");
   G__memvar_setup((void*)((long)(&p->IMINI)-(long)(p)),102,0,0,-1,-1,-1,1,"IMINI=",0,"Mini-torus magnet current in Amps");
   G__memvar_setup((void*)((long)(&p->ITAG)-(long)(p)),102,0,0,-1,-1,-1,1,"ITAG=",0,"Tagger magnet current in Amps");
   }
   G__tag_memvar_reset();
}


   /* BMPR_t */
static void G__setup_memvarBMPR_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_BMPR_t));
   { BMPR_t *p; p=(BMPR_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->Q_TOT)-(long)(p)),102,0,0,-1,-1,-1,1,"Q_TOT=",0,"Total Charge (Coulomb)");
   G__memvar_setup((void*)((long)(&p->Q_TOT_LV)-(long)(p)),102,0,0,-1,-1,-1,1,"Q_TOT_LV=",0,"Total charge in Live Time (Coulomb) ");
   G__memvar_setup((void*)((long)(&p->TL_TU)-(long)(p)),102,0,0,-1,-1,-1,1,"TL_TU=",0,"( Time Live ) / ( Time Ungated )");
   G__memvar_setup((void*)((long)(&p->CURRENT)-(long)(p)),102,0,0,-1,-1,-1,1,"CURRENT=",0,"Current in Ampers");
   }
   G__tag_memvar_reset();
}


   /* BREP_t */
static void G__setup_memvarBREP_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_BREP_t));
   { BREP_t *p; p=(BREP_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->MBSY2C_energy)-(long)(p)),102,0,0,-1,-1,-1,1,"MBSY2C_energy=",0,"beam energy");
   G__memvar_setup((void*)((long)(&p->IGT0I00BIASET)-(long)(p)),102,0,0,-1,-1,-1,1,"IGT0I00BIASET=",0,"thermionic gun");
   G__memvar_setup((void*)((long)(&p->IGL1I00DAC2)-(long)(p)),102,0,0,-1,-1,-1,1,"IGL1I00DAC2=",0,"B polarized gun");
   G__memvar_setup((void*)((long)(&p->SMRPOSA)-(long)(p)),102,0,0,-1,-1,-1,1,"SMRPOSA=",0,"A slit position");
   G__memvar_setup((void*)((long)(&p->SMRPOSB)-(long)(p)),102,0,0,-1,-1,-1,1,"SMRPOSB=",0,"B slit position");
   G__memvar_setup((void*)((long)(&p->SMRPOSC)-(long)(p)),102,0,0,-1,-1,-1,1,"SMRPOSC=",0,"C slit position");
   G__memvar_setup((void*)((long)(&p->Harp)-(long)(p)),102,0,0,-1,-1,-1,1,"Harp=",0,"harp");
   G__memvar_setup((void*)((long)(&p->hallb_sf_xy560)-(long)(p)),102,0,0,-1,-1,-1,1,"hallb_sf_xy560=",0,"torus current");
   G__memvar_setup((void*)((long)(&p->MTSETI)-(long)(p)),102,0,0,-1,-1,-1,1,"MTSETI=",0,"Mini set current");
   G__memvar_setup((void*)((long)(&p->MTIRBCK)-(long)(p)),102,0,0,-1,-1,-1,1,"MTIRBCK=",0,"Mini current readback");
   G__memvar_setup((void*)((long)(&p->MTVRBCK)-(long)(p)),102,0,0,-1,-1,-1,1,"MTVRBCK=",0,"Mini voltage readback");
   G__memvar_setup((void*)((long)(&p->TMSETI)-(long)(p)),102,0,0,-1,-1,-1,1,"TMSETI=",0,"Tagger set current");
   G__memvar_setup((void*)((long)(&p->TMIRBCK)-(long)(p)),102,0,0,-1,-1,-1,1,"TMIRBCK=",0,"Tagger current readback");
   G__memvar_setup((void*)((long)(&p->TMVRBCK)-(long)(p)),102,0,0,-1,-1,-1,1,"TMVRBCK=",0,"Tagger voltage readback");
   G__memvar_setup((void*)((long)(&p->Cryo_pressure)-(long)(p)),102,0,0,-1,-1,-1,1,"Cryo_pressure=",0,"cryotarget pressure");
   G__memvar_setup((void*)((long)(&p->Cryo_temperature)-(long)(p)),102,0,0,-1,-1,-1,1,"Cryo_temperature=",0,"cryotarget temperature");
   G__memvar_setup((void*)((long)(&p->Cryo_status)-(long)(p)),102,0,0,-1,-1,-1,1,"Cryo_status=",0,"cryotarget status");
   G__memvar_setup((void*)((long)(&p->VCG2C24)-(long)(p)),102,0,0,-1,-1,-1,1,"VCG2C24=",0,"upstream beam vacuum");
   G__memvar_setup((void*)((long)(&p->VCG2H01)-(long)(p)),102,0,0,-1,-1,-1,1,"VCG2H01=",0,"target vacuum");
   G__memvar_setup((void*)((long)(&p->scalerS2o)-(long)(p)),102,0,0,-1,-1,-1,1,"scalerS2o=",0,"Halo UP upstream");
   G__memvar_setup((void*)((long)(&p->scalerS3o)-(long)(p)),102,0,0,-1,-1,-1,1,"scalerS3o=",0,"Halo DOWN upstream");
   G__memvar_setup((void*)((long)(&p->scalerS4o)-(long)(p)),102,0,0,-1,-1,-1,1,"scalerS4o=",0,"Halo LEFT upstream");
   G__memvar_setup((void*)((long)(&p->scalerS5o)-(long)(p)),102,0,0,-1,-1,-1,1,"scalerS5o=",0,"Halo RIGHT upstream");
   G__memvar_setup((void*)((long)(&p->scalerS6o)-(long)(p)),102,0,0,-1,-1,-1,1,"scalerS6o=",0,"Halo UP downstream");
   G__memvar_setup((void*)((long)(&p->scalerS7o)-(long)(p)),102,0,0,-1,-1,-1,1,"scalerS7o=",0,"Halo DOWN downstream");
   G__memvar_setup((void*)((long)(&p->scalerS8o)-(long)(p)),102,0,0,-1,-1,-1,1,"scalerS8o=",0,"Halo LEFT downstream");
   G__memvar_setup((void*)((long)(&p->scalerS9o)-(long)(p)),102,0,0,-1,-1,-1,1,"scalerS9o=",0,"Halo RIGHT downstream");
   G__memvar_setup((void*)((long)(&p->IPM2H01_XPOS)-(long)(p)),102,0,0,-1,-1,-1,1,"IPM2H01_XPOS=",0,"bpm 1 x");
   G__memvar_setup((void*)((long)(&p->IPM2H01_YPOS)-(long)(p)),102,0,0,-1,-1,-1,1,"IPM2H01_YPOS=",0,"bpm 1 y");
   G__memvar_setup((void*)((long)(&p->IPM2H01)-(long)(p)),102,0,0,-1,-1,-1,1,"IPM2H01=",0,"bpm 1 current");
   G__memvar_setup((void*)((long)(&p->IPM2C24A_XPOS)-(long)(p)),102,0,0,-1,-1,-1,1,"IPM2C24A_XPOS=",0,"bpm 2 x");
   G__memvar_setup((void*)((long)(&p->IPM2C24A_YPOS)-(long)(p)),102,0,0,-1,-1,-1,1,"IPM2C24A_YPOS=",0,"bpm 2 y");
   G__memvar_setup((void*)((long)(&p->IPM2C24A)-(long)(p)),102,0,0,-1,-1,-1,1,"IPM2C24A=",0,"bpm 2 current");
   G__memvar_setup((void*)((long)(&p->IPM2C22A_XPOS)-(long)(p)),102,0,0,-1,-1,-1,1,"IPM2C22A_XPOS=",0,"bpm 3 x");
   G__memvar_setup((void*)((long)(&p->IPM2C22A_YPOS)-(long)(p)),102,0,0,-1,-1,-1,1,"IPM2C22A_YPOS=",0,"bpm 3 y");
   G__memvar_setup((void*)((long)(&p->IPM2C22A)-(long)(p)),102,0,0,-1,-1,-1,1,"IPM2C22A=",0,"bpm 3 current");
   }
   G__tag_memvar_reset();
}


   /* CALB_t */
static void G__setup_memvarCALB_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CALB_t));
   { CALB_t *p; p=(CALB_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->meanRFe)-(long)(p)),102,0,0,-1,-1,-1,1,"meanRFe=",0,"RF offset for electrons (all sectors)");
   G__memvar_setup((void*)((long)(&p->sigmaRFe)-(long)(p)),102,0,0,-1,-1,-1,1,"sigmaRFe=",0,"Time resolution for electrons (RF)");
   G__memvar_setup((void*)((long)(&p->sigmaRFh)-(long)(p)),102,0,0,-1,-1,-1,1,"sigmaRFh=",0,"Time resolution for pions");
   G__memvar_setup((void*)((long)(&p->sigmaECt)-(long)(p)),102,0,0,-1,-1,-1,1,"sigmaECt=",0,"Time resolution of EC, tEC(e)-tSC(e) ");
   G__memvar_setup((void*)((long)(&p->SFECe)-(long)(p)),102,0,0,-1,-1,-1,1,"SFECe=",0,"Sampling fraction E_EC(e)/p(e)");
   G__memvar_setup((void*)((long)(&p->sigmaSF)-(long)(p)),102,0,0,-1,-1,-1,1,"sigmaSF=",0,"width of the sampling fraction");
   G__memvar_setup((void*)((long)(&p->ResSL1)-(long)(p)),102,0,0,-1,-1,-1,1,"ResSL1=",0,"DC residuals in R1 (all sectors)");
   G__memvar_setup((void*)((long)(&p->ResSL2)-(long)(p)),102,0,0,-1,-1,-1,1,"ResSL2=",0,"DC residuals in R2 (all sectors)");
   G__memvar_setup((void*)((long)(&p->ResSL3)-(long)(p)),102,0,0,-1,-1,-1,1,"ResSL3=",0,"DC residuals in R3 (all sectors)");
   G__memvar_setup((void*)((long)(&p->ResSL4)-(long)(p)),102,0,0,-1,-1,-1,1,"ResSL4=",0,"DC residuals in R1 (all sectors)");
   G__memvar_setup((void*)((long)(&p->ResSL5)-(long)(p)),102,0,0,-1,-1,-1,1,"ResSL5=",0,"DC residuals in R2 (all sectors)");
   G__memvar_setup((void*)((long)(&p->ResSL6)-(long)(p)),102,0,0,-1,-1,-1,1,"ResSL6=",0,"DC residuals in R3 (all sectors)");
   }
   G__tag_memvar_reset();
}


   /* CALL_t */
static void G__setup_memvarCALL_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CALL_t));
   { CALL_t *p; p=(CALL_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"catch-all element(RF,laser diode,etc)");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels)");
   G__memvar_setup((void*)((long)(&p->ADC)-(long)(p)),114,0,0,-1,-1,-1,1,"ADC=",0,"adc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* CC01_t */
static void G__setup_memvarCC01_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CC01_t));
   { CC01_t *p; p=(CC01_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->id)-(long)(p)),105,0,0,-1,-1,-1,1,"id=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->time)-(long)(p)),102,0,0,-1,-1,-1,1,"time=",0,"time(ns) ");
   G__memvar_setup((void*)((long)(&p->n_pe)-(long)(p)),102,0,0,-1,-1,-1,1,"n_pe=",0,"number of photoelectrons");
   }
   G__tag_memvar_reset();
}


   /* CC1_t */
static void G__setup_memvarCC1_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CC1_t));
   { CC1_t *p; p=(CC1_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels)");
   G__memvar_setup((void*)((long)(&p->ADC)-(long)(p)),114,0,0,-1,-1,-1,1,"ADC=",0,"adc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* CC_t */
static void G__setup_memvarCC_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CC_t));
   { CC_t *p; p=(CC_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels)");
   G__memvar_setup((void*)((long)(&p->ADC)-(long)(p)),114,0,0,-1,-1,-1,1,"ADC=",0,"adc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* CCDI_t */
static void G__setup_memvarCCDI_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CCDI_t));
   { CCDI_t *p; p=(CCDI_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->crate)-(long)(p)),105,0,0,-1,-1,-1,1,"crate=",0,"CAMAC crate number");
   G__memvar_setup((void*)((long)(&p->slot)-(long)(p)),105,0,0,-1,-1,-1,1,"slot=",0,"slot");
   G__memvar_setup((void*)((long)(&p->mask)-(long)(p)),105,0,0,-1,-1,-1,1,"mask=",0,"mask");
   G__memvar_setup((void*)((long)(&p->threshold)-(long)(p)),105,0,0,-1,-1,-1,1,"threshold=",0,"actual threshold value (mV)");
   G__memvar_setup((void*)((long)(&p->width)-(long)(p)),105,0,0,-1,-1,-1,1,"width=",0,"actual width value");
   }
   G__tag_memvar_reset();
}


   /* CCH_t */
static void G__setup_memvarCCH_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CCH_t));
   { CCH_t *p; p=(CCH_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->tknum)-(long)(p)),105,0,0,-1,-1,-1,1,"tknum=",0,"track number, 1000*istak+itra");
   G__memvar_setup((void*)((long)(&p->id)-(long)(p)),105,0,0,-1,-1,-1,1,"id=",0,"track PDG id");
   G__memvar_setup((void*)((long)(&p->nhits)-(long)(p)),105,0,0,-1,-1,-1,1,"nhits=",0,"number of CC hits per track");
   G__memvar_setup((void*)((long)(&p->sector)-(long)(p)),105,0,0,-1,-1,-1,1,"sector=",0,"sector number of track");
   G__memvar_setup((void*)((long)(&p->segment)-(long)(p)),105,0,0,-1,-1,-1,1,"segment=",0,"cc segment number of track");
   G__memvar_setup((void*)((long)(&p->pmom)-(long)(p)),105,0,0,-1,-1,-1,1,"pmom=",0,"track momentum ");
   G__memvar_setup((void*)((long)(&p->xin)-(long)(p)),102,0,0,-1,-1,-1,1,"xin=",0,"x pos track entry into cerenkov");
   G__memvar_setup((void*)((long)(&p->yin)-(long)(p)),102,0,0,-1,-1,-1,1,"yin=",0,"y pos");
   G__memvar_setup((void*)((long)(&p->zin)-(long)(p)),102,0,0,-1,-1,-1,1,"zin=",0,"z pos");
   G__memvar_setup((void*)((long)(&p->xout)-(long)(p)),102,0,0,-1,-1,-1,1,"xout=",0,"x pos track exit from cerenkov");
   G__memvar_setup((void*)((long)(&p->yout)-(long)(p)),102,0,0,-1,-1,-1,1,"yout=",0,"y pos");
   G__memvar_setup((void*)((long)(&p->zout)-(long)(p)),102,0,0,-1,-1,-1,1,"zout=",0,"z pos");
   }
   G__tag_memvar_reset();
}


   /* CCMT_t */
static void G__setup_memvarCCMT_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CCMT_t));
   { CCMT_t *p; p=(CCMT_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->mean_high)-(long)(p)),105,0,0,-1,-1,-1,1,"mean_high=",0,"mean high threshold (mV)");
   G__memvar_setup((void*)((long)(&p->mean_lo)-(long)(p)),105,0,0,-1,-1,-1,1,"mean_lo=",0,"mean lo threshold (mV)");
   }
   G__tag_memvar_reset();
}


   /* CCPB_t */
static void G__setup_memvarCCPB_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CCPB_t));
   { CCPB_t *p; p=(CCPB_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ScSgHt)-(long)(p)),105,0,0,-1,-1,-1,1,"ScSgHt=",0,"100*sector + Cluster # in CCRC");
   G__memvar_setup((void*)((long)(&p->Nphe)-(long)(p)),102,0,0,-1,-1,-1,1,"Nphe=",0,"Number of photo-electrons*10");
   G__memvar_setup((void*)((long)(&p->Time)-(long)(p)),102,0,0,-1,-1,-1,1,"Time=",0,"Flight time relative to the evnt start time");
   G__memvar_setup((void*)((long)(&p->Path)-(long)(p)),102,0,0,-1,-1,-1,1,"Path=",0,"Path lenght from target (from tracking)");
   G__memvar_setup((void*)((long)(&p->Chi2CC)-(long)(p)),102,0,0,-1,-1,-1,1,"Chi2CC=",0,"Geometrical matching: angle between CC hit and");
   G__memvar_setup((void*)((long)(&p->Status)-(long)(p)),105,0,0,-1,-1,-1,1,"Status=",0,"Status word - now 10*(CC segment number) ");
   }
   G__tag_memvar_reset();
}


   /* CCPE_t */
static void G__setup_memvarCCPE_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CCPE_t));
   { CCPE_t *p; p=(CCPE_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->mean)-(long)(p)),105,0,0,-1,-1,-1,1,"mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->sigma)-(long)(p)),105,0,0,-1,-1,-1,1,"sigma=",0,"sigma of the pedestal distribution (channel)");
   }
   G__tag_memvar_reset();
}


   /* CCRC_t */
static void G__setup_memvarCCRC_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CCRC_t));
   { CCRC_t *p; p=(CCRC_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->nrsect)-(long)(p)),105,0,0,-1,-1,-1,1,"nrsect=",0,"Sector #");
   G__memvar_setup((void*)((long)(&p->nrsegm)-(long)(p)),105,0,0,-1,-1,-1,1,"nrsegm=",0,"10 * Mean segment #");
   G__memvar_setup((void*)((long)(&p->nrsegm_p)-(long)(p)),105,0,0,-1,-1,-1,1,"nrsegm_p=",0,"10 * Max segment # in the cluster");
   G__memvar_setup((void*)((long)(&p->nrsegm_m)-(long)(p)),105,0,0,-1,-1,-1,1,"nrsegm_m=",0,"10 * Min segment # in the cluster");
   G__memvar_setup((void*)((long)(&p->nrphe)-(long)(p)),105,0,0,-1,-1,-1,1,"nrphe=",0,"Number of photoelectrons obtained");
   G__memvar_setup((void*)((long)(&p->nrtime)-(long)(p)),105,0,0,-1,-1,-1,1,"nrtime=",0,"TOF in channels (50psec/channel)");
   G__memvar_setup((void*)((long)(&p->nrthet)-(long)(p)),105,0,0,-1,-1,-1,1,"nrthet=",0,"Estimated angle Theta");
   G__memvar_setup((void*)((long)(&p->nrdthet)-(long)(p)),105,0,0,-1,-1,-1,1,"nrdthet=",0,"Estimated error of angle Theta");
   G__memvar_setup((void*)((long)(&p->nrphy)-(long)(p)),105,0,0,-1,-1,-1,1,"nrphy=",0,"Phy index ");
   G__memvar_setup((void*)((long)(&p->nriec)-(long)(p)),105,0,0,-1,-1,-1,1,"nriec=",0,"Estimated i-coordinate in EC ");
   G__memvar_setup((void*)((long)(&p->nrdiec)-(long)(p)),105,0,0,-1,-1,-1,1,"nrdiec=",0,"Estimated error of i-coord. in EC");
   G__memvar_setup((void*)((long)(&p->nrstat)-(long)(p)),105,0,0,-1,-1,-1,1,"nrstat=",0,"Status  word (yet unclear) ");
   }
   G__tag_memvar_reset();
}


   /* CCS_t */
static void G__setup_memvarCCS_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CCS_t));
   { CCS_t *p; p=(CCS_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->CCS1)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS1=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->CCS2)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS2=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->CCS3)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS3=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->CCS4)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS4=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->CCS5)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS5=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->CCS6)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS6=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->CCS7)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS7=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->CCS8)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS8=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->CCS9)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS9=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->CCS10)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS10=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->CCS11)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS11=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->CCS12)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS12=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->CCS13)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS13=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->CCS14)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS14=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->CCS15)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS15=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->CCS16)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS16=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->CCS17)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS17=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->CCS18)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS18=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->CCS19)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS19=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->CCS20)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS20=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->CCS21)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS21=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->CCS22)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS22=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->CCS23)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS23=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->CCS24)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS24=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->CCS25)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS25=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->CCS26)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS26=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->CCS27)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS27=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->CCS28)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS28=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->CCS29)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS29=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->CCS30)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS30=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->CCS31)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS31=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->CCS32)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS32=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->CCS33)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS33=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->CCS34)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS34=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->CCS35)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS35=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->CCS36)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS36=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->CCS37)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS37=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->CCS38)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS38=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->CCS39)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS39=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->CCS40)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS40=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->CCS41)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS41=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->CCS42)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS42=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->CCS43)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS43=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->CCS44)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS44=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->CCS45)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS45=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->CCS46)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS46=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->CCS47)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS47=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->CCS48)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS48=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->CCS49)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS49=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->CCS50)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS50=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->CCS51)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS51=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->CCS52)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS52=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->CCS53)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS53=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->CCS54)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS54=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->CCS55)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS55=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->CCS56)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS56=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->CCS57)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS57=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->CCS58)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS58=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->CCS59)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS59=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->CCS60)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS60=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->CCS61)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS61=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->CCS62)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS62=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->CCS63)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS63=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->CCS64)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS64=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->CCS65)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS65=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->CCS66)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS66=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->CCS67)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS67=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->CCS68)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS68=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->CCS69)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS69=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->CCS70)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS70=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->CCS71)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS71=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->CCS72)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS72=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->CCS73)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS73=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->CCS74)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS74=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->CCS75)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS75=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->CCS76)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS76=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->CCS77)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS77=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->CCS78)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS78=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->CCS79)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS79=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->CCS80)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS80=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->CCS81)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS81=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->CCS82)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS82=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->CCS83)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS83=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->CCS84)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS84=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->CCS85)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS85=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->CCS86)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS86=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->CCS87)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS87=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->CCS88)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS88=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->CCS89)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS89=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->CCS90)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS90=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->CCS91)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS91=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->CCS92)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS92=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->CCS93)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS93=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->CCS94)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS94=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->CCS95)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS95=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->CCS96)-(long)(p)),105,0,0,-1,-1,-1,1,"CCS96=",0,"scaler sector 6");
   }
   G__tag_memvar_reset();
}


   /* CCT_t */
static void G__setup_memvarCCT_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CCT_t));
   { CCT_t *p; p=(CCT_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* CHI2_t */
static void G__setup_memvarCHI2_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CHI2_t));
   { CHI2_t *p; p=(CHI2_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->chi2)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2=",0,"overall chi2 for event  ");
   G__memvar_setup((void*)((long)(&p->cl)-(long)(p)),102,0,0,-1,-1,-1,1,"cl=",0,"percentage (confidence level)");
   G__memvar_setup((void*)((long)(&p->ndf)-(long)(p)),105,0,0,-1,-1,-1,1,"ndf=",0,"number of effective degrees of freedom");
   G__memvar_setup((void*)((long)(&p->iter)-(long)(p)),105,0,0,-1,-1,-1,1,"iter=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* CL01_t */
static void G__setup_memvarCL01_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CL01_t));
   { CL01_t *p; p=(CL01_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ac_amp)-(long)(p)),105,0,0,-1,-1,-1,1,"ac_amp=",0,"60 Hz AC amplitude (pedestal subtracted)");
   G__memvar_setup((void*)((long)(&p->fc_diode_amp)-(long)(p)),105,0,0,-1,-1,-1,1,"fc_diode_amp=",0,"Forward Carriage diode amplitude (ped sub.)");
   G__memvar_setup((void*)((long)(&p->fc_diode_t)-(long)(p)),102,0,0,-1,-1,-1,1,"fc_diode_t=",0,"Forward Carriage diode time");
   G__memvar_setup((void*)((long)(&p->nc_diode_amp)-(long)(p)),105,0,0,-1,-1,-1,1,"nc_diode_amp=",0,"North Clamshell diode amplitude (ped sub.)");
   G__memvar_setup((void*)((long)(&p->nc_diode_t)-(long)(p)),102,0,0,-1,-1,-1,1,"nc_diode_t=",0,"Forward  diode time");
   G__memvar_setup((void*)((long)(&p->sc_diode_amp)-(long)(p)),105,0,0,-1,-1,-1,1,"sc_diode_amp=",0,"Forward Carriage diode amplitude (ped sub.)");
   G__memvar_setup((void*)((long)(&p->sc_diode_t)-(long)(p)),102,0,0,-1,-1,-1,1,"sc_diode_t=",0,"Forward Carriage diode time(ns)");
   G__memvar_setup((void*)((long)(&p->sf_diode_amp)-(long)(p)),105,0,0,-1,-1,-1,1,"sf_diode_amp=",0,"Forward Carriage diode amplitude (ped sub.)");
   G__memvar_setup((void*)((long)(&p->sf_diode_t)-(long)(p)),102,0,0,-1,-1,-1,1,"sf_diode_t=",0,"Forward Carriage diode time(ns)");
   G__memvar_setup((void*)((long)(&p->rf1)-(long)(p)),102,0,0,-1,-1,-1,1,"rf1=",0,"RF time 1 (ns)");
   G__memvar_setup((void*)((long)(&p->rf2)-(long)(p)),102,0,0,-1,-1,-1,1,"rf2=",0,"RF time 2 (ns)");
   G__memvar_setup((void*)((long)(&p->rf)-(long)(p)),102,0,0,-1,-1,-1,1,"rf=",0,"GOOD RF time (ns)");
   }
   G__tag_memvar_reset();
}


   /* CLST_t */
static void G__setup_memvarCLST_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CLST_t));
   { CLST_t *p; p=(CLST_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->Clust)-(long)(p)),105,0,0,-1,-1,-1,1,"Clust=",0,"bit packed,  see: include/bosddl.h, clasCLST_t");
   }
   G__tag_memvar_reset();
}


   /* CPED_t */
static void G__setup_memvarCPED_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CPED_t));
   { CPED_t *p; p=(CPED_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->slot)-(long)(p)),105,0,0,-1,-1,-1,1,"slot=",0,"ADC slot");
   G__memvar_setup((void*)((long)(&p->channel)-(long)(p)),105,0,0,-1,-1,-1,1,"channel=",0,"ADC channel");
   G__memvar_setup((void*)((long)(&p->mean)-(long)(p)),105,0,0,-1,-1,-1,1,"mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma=",0,"sigma of the pedestal distribution (channel)");
   G__memvar_setup((void*)((long)(&p->offset)-(long)(p)),105,0,0,-1,-1,-1,1,"offset=",0,"offset for sparsification threshold calculation");
   }
   G__tag_memvar_reset();
}


   /* CSQL_t */
static void G__setup_memvarCSQL_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CSQL_t));
   { CSQL_t *p; p=(CSQL_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->EVID)-(long)(p)),104,0,0,-1,-1,-1,1,"EVID=",0,"Event ID (number of triggers)");
   G__memvar_setup((void*)((long)(&p->NPROC)-(long)(p)),104,0,0,-1,-1,-1,1,"NPROC=",0,"Number of processed triggers");
   G__memvar_setup((void*)((long)(&p->CPU)-(long)(p)),102,0,0,-1,-1,-1,1,"CPU=",0,"CPU used (sec) ");
   G__memvar_setup((void*)((long)(&p->FC)-(long)(p)),102,0,0,-1,-1,-1,1,"FC=",0,"Faraday Cup (K)");
   G__memvar_setup((void*)((long)(&p->FCG)-(long)(p)),102,0,0,-1,-1,-1,1,"FCG=",0,"Faraday Cup Gated (K)");
   G__memvar_setup((void*)((long)(&p->TG)-(long)(p)),102,0,0,-1,-1,-1,1,"TG=",0,"Clock Gated");
   G__memvar_setup((void*)((long)(&p->IBEAM)-(long)(p)),102,0,0,-1,-1,-1,1,"IBEAM=",0,"Beam current ");
   G__memvar_setup((void*)((long)(&p->NeS1)-(long)(p)),104,0,0,-1,-1,-1,1,"NeS1=",0,"Number of electrons in sect 1");
   G__memvar_setup((void*)((long)(&p->NeS2)-(long)(p)),104,0,0,-1,-1,-1,1,"NeS2=",0,"Number of electrons in sect 2");
   G__memvar_setup((void*)((long)(&p->NeS3)-(long)(p)),104,0,0,-1,-1,-1,1,"NeS3=",0,"Number of electrons in sect 3 ");
   G__memvar_setup((void*)((long)(&p->NeS4)-(long)(p)),104,0,0,-1,-1,-1,1,"NeS4=",0,"Number of electrons in sect 4 ");
   G__memvar_setup((void*)((long)(&p->NeS5)-(long)(p)),104,0,0,-1,-1,-1,1,"NeS5=",0,"Number of electrons in sect 5  ");
   G__memvar_setup((void*)((long)(&p->NeS6)-(long)(p)),104,0,0,-1,-1,-1,1,"NeS6=",0,"Number of electrons in sect 6");
   G__memvar_setup((void*)((long)(&p->Nhb)-(long)(p)),104,0,0,-1,-1,-1,1,"Nhb=",0,"Number of HB ");
   G__memvar_setup((void*)((long)(&p->Ntb)-(long)(p)),104,0,0,-1,-1,-1,1,"Ntb=",0,"Number of TB");
   G__memvar_setup((void*)((long)(&p->Nprot)-(long)(p)),104,0,0,-1,-1,-1,1,"Nprot=",0,"Number of protons");
   G__memvar_setup((void*)((long)(&p->Npip)-(long)(p)),104,0,0,-1,-1,-1,1,"Npip=",0,"number of pip");
   G__memvar_setup((void*)((long)(&p->Ndeut)-(long)(p)),104,0,0,-1,-1,-1,1,"Ndeut=",0,"number of deutrons");
   G__memvar_setup((void*)((long)(&p->Nphot)-(long)(p)),104,0,0,-1,-1,-1,1,"Nphot=",0,"number of photons	");
   G__memvar_setup((void*)((long)(&p->Nelhp)-(long)(p)),104,0,0,-1,-1,-1,1,"Nelhp=",0,"Number of electrons at pos. Helic.");
   G__memvar_setup((void*)((long)(&p->Nelhn)-(long)(p)),104,0,0,-1,-1,-1,1,"Nelhn=",0,"Number of electrons at neg. helic.");
   }
   G__tag_memvar_reset();
}


   /* DC0_t */
static void G__setup_memvarDC0_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DC0_t));
   { DC0_t *p; p=(DC0_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* DC1_t */
static void G__setup_memvarDC1_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DC1_t));
   { DC1_t *p; p=(DC1_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->time)-(long)(p)),102,0,0,-1,-1,-1,1,"time=",0,"time(ns) ");
   }
   G__tag_memvar_reset();
}


   /* DCDW_t */
static void G__setup_memvarDCDW_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCDW_t));
   { DCDW_t *p; p=(DCDW_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"ID_wire ");
   G__memvar_setup((void*)((long)(&p->TIDLY)-(long)(p)),102,0,0,-1,-1,-1,1,"TIDLY=",0,"TIme DeLaY (ns) 		 ");
   G__memvar_setup((void*)((long)(&p->STAT)-(long)(p)),105,0,0,-1,-1,-1,1,"STAT=",0,"wire status word ");
   }
   G__tag_memvar_reset();
}


   /* DCGM_t */
static void G__setup_memvarDCGM_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCGM_t));
   { DCGM_t *p; p=(DCGM_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->x_curve)-(long)(p)),102,0,0,-1,-1,-1,1,"x_curve=",0,"x center of curvature (cm)");
   G__memvar_setup((void*)((long)(&p->y_curve)-(long)(p)),102,0,0,-1,-1,-1,1,"y_curve=",0,"y center of curvature (cm)");
   G__memvar_setup((void*)((long)(&p->z_curve)-(long)(p)),102,0,0,-1,-1,-1,1,"z_curve=",0,"z center of curvature (cm)");
   G__memvar_setup((void*)((long)(&p->r_curve)-(long)(p)),102,0,0,-1,-1,-1,1,"r_curve=",0,"radius of curvature (cm)");
   G__memvar_setup((void*)((long)(&p->theta_start)-(long)(p)),102,0,0,-1,-1,-1,1,"theta_start=",0,"angle of first logical wire WRT the center of curvature (rad)");
   G__memvar_setup((void*)((long)(&p->d_theta)-(long)(p)),102,0,0,-1,-1,-1,1,"d_theta=",0,"delta theta between wires WRT center of curvature");
   G__memvar_setup((void*)((long)(&p->x_nmid)-(long)(p)),102,0,0,-1,-1,-1,1,"x_nmid=",0,"x normal vector to the midplane");
   G__memvar_setup((void*)((long)(&p->y_nmid)-(long)(p)),102,0,0,-1,-1,-1,1,"y_nmid=",0,"y normal vector to the midplane");
   G__memvar_setup((void*)((long)(&p->z_nmid)-(long)(p)),102,0,0,-1,-1,-1,1,"z_nmid=",0,"z normal vector to the midplane");
   G__memvar_setup((void*)((long)(&p->theta_min)-(long)(p)),102,0,0,-1,-1,-1,1,"theta_min=",0,"theta of first physical wire (rad)");
   G__memvar_setup((void*)((long)(&p->theta_max)-(long)(p)),102,0,0,-1,-1,-1,1,"theta_max=",0,"theta of last physical wire (rad)");
   G__memvar_setup((void*)((long)(&p->min_wire)-(long)(p)),105,0,0,-1,-1,-1,1,"min_wire=",0,"minimum physical wire number");
   G__memvar_setup((void*)((long)(&p->max_wire)-(long)(p)),105,0,0,-1,-1,-1,1,"max_wire=",0,"maximum physical wire number");
   G__memvar_setup((void*)((long)(&p->stereo)-(long)(p)),102,0,0,-1,-1,-1,1,"stereo=",0,"approximate stereo angle");
   G__memvar_setup((void*)((long)(&p->cell_size)-(long)(p)),102,0,0,-1,-1,-1,1,"cell_size=",0,"cell size (cm)");
   G__memvar_setup((void*)((long)(&p->x_norm)-(long)(p)),102,0,0,-1,-1,-1,1,"x_norm=",0,"x normal vector to the plane(region 1)");
   G__memvar_setup((void*)((long)(&p->y_norm)-(long)(p)),102,0,0,-1,-1,-1,1,"y_norm=",0,"y normal vector to the plane(region 1)");
   G__memvar_setup((void*)((long)(&p->z_norm)-(long)(p)),102,0,0,-1,-1,-1,1,"z_norm=",0,"z normal vector to the plane(region 1)");
   G__memvar_setup((void*)((long)(&p->p_dist)-(long)(p)),102,0,0,-1,-1,-1,1,"p_dist=",0,"distance of plane to origin(cm) (region 1)");
   G__memvar_setup((void*)((long)(&p->p_sep)-(long)(p)),102,0,0,-1,-1,-1,1,"p_sep=",0,"planar separation(cm) (region 1)");
   G__memvar_setup((void*)((long)(&p->max_cylw)-(long)(p)),105,0,0,-1,-1,-1,1,"max_cylw=",0,"maximum cylindrical wire");
   }
   G__tag_memvar_reset();
}


   /* DCGW_t */
static void G__setup_memvarDCGW_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCGW_t));
   { DCGW_t *p; p=(DCGW_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->x_mid)-(long)(p)),102,0,0,-1,-1,-1,1,"x_mid=",0,"x at midplane of wire(cm)");
   G__memvar_setup((void*)((long)(&p->y_mid)-(long)(p)),102,0,0,-1,-1,-1,1,"y_mid=",0,"y at midplane of wire(cm)");
   G__memvar_setup((void*)((long)(&p->z_mid)-(long)(p)),102,0,0,-1,-1,-1,1,"z_mid=",0,"z at midplane of wire(cm)");
   G__memvar_setup((void*)((long)(&p->x_dir)-(long)(p)),102,0,0,-1,-1,-1,1,"x_dir=",0,"x direction cosine along wire (cm)");
   G__memvar_setup((void*)((long)(&p->y_dir)-(long)(p)),102,0,0,-1,-1,-1,1,"y_dir=",0,"y direction cosine along wire (cm)");
   G__memvar_setup((void*)((long)(&p->z_dir)-(long)(p)),102,0,0,-1,-1,-1,1,"z_dir=",0,"z direction cosine along wire (cm)");
   G__memvar_setup((void*)((long)(&p->w_len)-(long)(p)),102,0,0,-1,-1,-1,1,"w_len=",0,"wire length from midplane to amplifier (cm)");
   G__memvar_setup((void*)((long)(&p->w_len_hv)-(long)(p)),102,0,0,-1,-1,-1,1,"w_len_hv=",0,"wire length from midplane to HV (cm)");
   }
   G__tag_memvar_reset();
}


   /* DCH_t */
static void G__setup_memvarDCH_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCH_t));
   { DCH_t *p; p=(DCH_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"x at layer center");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y at layer center");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z at layer center");
   G__memvar_setup((void*)((long)(&p->step)-(long)(p)),102,0,0,-1,-1,-1,1,"step=",0,"step size through layer");
   G__memvar_setup((void*)((long)(&p->dedx)-(long)(p)),102,0,0,-1,-1,-1,1,"dedx=",0,"energy deposit in layer");
   G__memvar_setup((void*)((long)(&p->pmom)-(long)(p)),102,0,0,-1,-1,-1,1,"pmom=",0,"track momentum at layer center ");
   G__memvar_setup((void*)((long)(&p->time)-(long)(p)),102,0,0,-1,-1,-1,1,"time=",0,"time of hit at layer center");
   G__memvar_setup((void*)((long)(&p->cx)-(long)(p)),102,0,0,-1,-1,-1,1,"cx=",0,"track x dir cosine at layer center");
   G__memvar_setup((void*)((long)(&p->cy)-(long)(p)),102,0,0,-1,-1,-1,1,"cy=",0,"track y dir cosine at layer center");
   G__memvar_setup((void*)((long)(&p->cz)-(long)(p)),102,0,0,-1,-1,-1,1,"cz=",0,"track z dir cosine at layer center");
   G__memvar_setup((void*)((long)(&p->track)-(long)(p)),105,0,0,-1,-1,-1,1,"track=",0,"track number");
   G__memvar_setup((void*)((long)(&p->id)-(long)(p)),105,0,0,-1,-1,-1,1,"id=",0,"track PDG id");
   G__memvar_setup((void*)((long)(&p->layer)-(long)(p)),105,0,0,-1,-1,-1,1,"layer=",0,"layer number");
   }
   G__tag_memvar_reset();
}


   /* DCMN_t */
static void G__setup_memvarDCMN_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCMN_t));
   { DCMN_t *p; p=(DCMN_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->HBT_evt_1)-(long)(p)),102,0,0,-1,-1,-1,1,"HBT_evt_1=",0,"Hit Based tracks per event for Sector 1 ");
   G__memvar_setup((void*)((long)(&p->TBT_evt_1)-(long)(p)),102,0,0,-1,-1,-1,1,"TBT_evt_1=",0,"Time Based tracks per event for Sector 1 ");
   G__memvar_setup((void*)((long)(&p->HBT_evt_2)-(long)(p)),102,0,0,-1,-1,-1,1,"HBT_evt_2=",0,"Hit Based tracks per event for Sector 2");
   G__memvar_setup((void*)((long)(&p->TBT_evt_2)-(long)(p)),102,0,0,-1,-1,-1,1,"TBT_evt_2=",0,"Time Based tracks per event for Sector 2 ");
   G__memvar_setup((void*)((long)(&p->HBT_evt_3)-(long)(p)),102,0,0,-1,-1,-1,1,"HBT_evt_3=",0,"Hit Based tracks per event for Sector 3 ");
   G__memvar_setup((void*)((long)(&p->TBT_evt_3)-(long)(p)),102,0,0,-1,-1,-1,1,"TBT_evt_3=",0,"Time Based tracks per event for Sector 3 ");
   G__memvar_setup((void*)((long)(&p->HBT_evt_4)-(long)(p)),102,0,0,-1,-1,-1,1,"HBT_evt_4=",0,"Hit Based tracks per event for Sector 4 ");
   G__memvar_setup((void*)((long)(&p->TBT_evt_4)-(long)(p)),102,0,0,-1,-1,-1,1,"TBT_evt_4=",0,"Time Based tracks per event for Sector 4 ");
   G__memvar_setup((void*)((long)(&p->HBT_evt_5)-(long)(p)),102,0,0,-1,-1,-1,1,"HBT_evt_5=",0,"Hit Based tracks per event for Sector 5 ");
   G__memvar_setup((void*)((long)(&p->TBT_evt_5)-(long)(p)),102,0,0,-1,-1,-1,1,"TBT_evt_5=",0,"Time Based tracks per event for Sector 5 ");
   G__memvar_setup((void*)((long)(&p->HBT_evt_6)-(long)(p)),102,0,0,-1,-1,-1,1,"HBT_evt_6=",0,"Hit Based tracks per event for Sector 6 ");
   G__memvar_setup((void*)((long)(&p->TBT_evt_6)-(long)(p)),102,0,0,-1,-1,-1,1,"TBT_evt_6=",0,"Time Based tracks per event for Sector 6 ");
   G__memvar_setup((void*)((long)(&p->HBT_evt_all)-(long)(p)),102,0,0,-1,-1,-1,1,"HBT_evt_all=",0,"Hit Based tracks per event for all sec.  ");
   G__memvar_setup((void*)((long)(&p->TBT_evt_all)-(long)(p)),102,0,0,-1,-1,-1,1,"TBT_evt_all=",0,"Time Based tracks per event for all sec. ");
   G__memvar_setup((void*)((long)(&p->Res_s1_sl1)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s1_sl1=",0,"Residual rms for sec 1, superlayer 1  ");
   G__memvar_setup((void*)((long)(&p->Res_s1_sl2)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s1_sl2=",0,"Residual rms for sec 1, superlayer 2  ");
   G__memvar_setup((void*)((long)(&p->Res_s1_sl3)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s1_sl3=",0,"Residual rms for sec 1, superlayer 3  ");
   G__memvar_setup((void*)((long)(&p->Res_s1_sl4)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s1_sl4=",0,"Residual rms for sec 1, superlayer 4  ");
   G__memvar_setup((void*)((long)(&p->Res_s1_sl5)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s1_sl5=",0,"Residual rms for sec 1, superlayer 5  ");
   G__memvar_setup((void*)((long)(&p->Res_s1_sl6)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s1_sl6=",0,"Residual rms for sec 1, superlayer 6  ");
   G__memvar_setup((void*)((long)(&p->Res_s2_sl1)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s2_sl1=",0,"Residual rms for sec 2, superlayer 1  ");
   G__memvar_setup((void*)((long)(&p->Res_s2_sl2)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s2_sl2=",0,"Residual rms for sec 2, superlayer 2  ");
   G__memvar_setup((void*)((long)(&p->Res_s2_sl3)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s2_sl3=",0,"Residual rms for sec 2, superlayer 3  ");
   G__memvar_setup((void*)((long)(&p->Res_s2_sl4)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s2_sl4=",0,"Residual rms for sec 2, superlayer 4  ");
   G__memvar_setup((void*)((long)(&p->Res_s2_sl5)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s2_sl5=",0,"Residual rms for sec 2, superlayer 5  ");
   G__memvar_setup((void*)((long)(&p->Res_s2_sl6)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s2_sl6=",0,"Residual rms for sec 2, superlayer 6  ");
   G__memvar_setup((void*)((long)(&p->Res_s3_sl1)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s3_sl1=",0,"Residual rms for sec 3, superlayer 1  ");
   G__memvar_setup((void*)((long)(&p->Res_s3_sl2)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s3_sl2=",0,"Residual rms for sec 3, superlayer 2  ");
   G__memvar_setup((void*)((long)(&p->Res_s3_sl3)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s3_sl3=",0,"Residual rms for sec 3, superlayer 3  ");
   G__memvar_setup((void*)((long)(&p->Res_s3_sl4)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s3_sl4=",0,"Residual rms for sec 3, superlayer 4  ");
   G__memvar_setup((void*)((long)(&p->Res_s3_sl5)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s3_sl5=",0,"Residual rms for sec 3, superlayer 5  ");
   G__memvar_setup((void*)((long)(&p->Res_s3_sl6)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s3_sl6=",0,"Residual rms for sec 3, superlayer 6  ");
   G__memvar_setup((void*)((long)(&p->Res_s4_sl1)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s4_sl1=",0,"Residual rms for sec 4, superlayer 1  ");
   G__memvar_setup((void*)((long)(&p->Res_s4_sl2)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s4_sl2=",0,"Residual rms for sec 4, superlayer 2  ");
   G__memvar_setup((void*)((long)(&p->Res_s4_sl3)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s4_sl3=",0,"Residual rms for sec 4, superlayer 3  ");
   G__memvar_setup((void*)((long)(&p->Res_s4_sl4)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s4_sl4=",0,"Residual rms for sec 4, superlayer 4  ");
   G__memvar_setup((void*)((long)(&p->Res_s4_sl5)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s4_sl5=",0,"Residual rms for sec 4, superlayer 5  ");
   G__memvar_setup((void*)((long)(&p->Res_s4_sl6)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s4_sl6=",0,"Residual rms for sec 4, superlayer 6  ");
   G__memvar_setup((void*)((long)(&p->Res_s5_sl1)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s5_sl1=",0,"Residual rms for sec 5, superlayer 1  ");
   G__memvar_setup((void*)((long)(&p->Res_s5_sl2)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s5_sl2=",0,"Residual rms for sec 5, superlayer 2  ");
   G__memvar_setup((void*)((long)(&p->Res_s5_sl3)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s5_sl3=",0,"Residual rms for sec 5, superlayer 3  ");
   G__memvar_setup((void*)((long)(&p->Res_s5_sl4)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s5_sl4=",0,"Residual rms for sec 5, superlayer 4  ");
   G__memvar_setup((void*)((long)(&p->Res_s5_sl5)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s5_sl5=",0,"Residual rms for sec 5, superlayer 5  ");
   G__memvar_setup((void*)((long)(&p->Res_s5_sl6)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s5_sl6=",0,"Residual rms for sec 5, superlayer 6  ");
   G__memvar_setup((void*)((long)(&p->Res_s6_sl1)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s6_sl1=",0,"Residual rms for sec 6, superlayer 1  ");
   G__memvar_setup((void*)((long)(&p->Res_s6_sl2)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s6_sl2=",0,"Residual rms for sec 6, superlayer 2  ");
   G__memvar_setup((void*)((long)(&p->Res_s6_sl3)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s6_sl3=",0,"Residual rms for sec 6, superlayer 3  ");
   G__memvar_setup((void*)((long)(&p->Res_s6_sl4)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s6_sl4=",0,"Residual rms for sec 6, superlayer 4  ");
   G__memvar_setup((void*)((long)(&p->Res_s6_sl5)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s6_sl5=",0,"Residual rms for sec 6, superlayer 5  ");
   G__memvar_setup((void*)((long)(&p->Res_s6_sl6)-(long)(p)),102,0,0,-1,-1,-1,1,"Res_s6_sl6=",0,"Residual rms for sec 6, superlayer 6  ");
   }
   G__tag_memvar_reset();
}


   /* DCPB_t */
static void G__setup_memvarDCPB_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCPB_t));
   { DCPB_t *p; p=(DCPB_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ScTr)-(long)(p)),105,0,0,-1,-1,-1,1,"ScTr=",0,"100*sector+track_ID in *BTR  ");
   G__memvar_setup((void*)((long)(&p->x_SC)-(long)(p)),102,0,0,-1,-1,-1,1,"x_SC=",0,"x coordinate of track intersection with SC plane ");
   G__memvar_setup((void*)((long)(&p->y_SC)-(long)(p)),102,0,0,-1,-1,-1,1,"y_SC=",0,"y coordinate of track intersection with SC plane");
   G__memvar_setup((void*)((long)(&p->z_SC)-(long)(p)),102,0,0,-1,-1,-1,1,"z_SC=",0,"z coordinate of track intersection with SC plane");
   G__memvar_setup((void*)((long)(&p->CX_SC)-(long)(p)),102,0,0,-1,-1,-1,1,"CX_SC=",0,"X dir cosine at (x_SC,y_SC,z_SC)");
   G__memvar_setup((void*)((long)(&p->CY_SC)-(long)(p)),102,0,0,-1,-1,-1,1,"CY_SC=",0,"y dir cosine at (x_SC,y_SC,z_SC)");
   G__memvar_setup((void*)((long)(&p->CZ_SC)-(long)(p)),102,0,0,-1,-1,-1,1,"CZ_SC=",0,"z dir cosine at (x_SC,y_SC,z_SC)");
   G__memvar_setup((void*)((long)(&p->X_v)-(long)(p)),102,0,0,-1,-1,-1,1,"X_v=",0,"vertex X after fiting to the beam position");
   G__memvar_setup((void*)((long)(&p->Y_v)-(long)(p)),102,0,0,-1,-1,-1,1,"Y_v=",0,"vertex Y after fiting to the beam position");
   G__memvar_setup((void*)((long)(&p->Z_v)-(long)(p)),102,0,0,-1,-1,-1,1,"Z_v=",0,"vertex Z after fiting to the beam position");
   G__memvar_setup((void*)((long)(&p->R_v)-(long)(p)),102,0,0,-1,-1,-1,1,"R_v=",0,"distance from production vertex to the bemam. ");
   G__memvar_setup((void*)((long)(&p->Chi2)-(long)(p)),102,0,0,-1,-1,-1,1,"Chi2=",0,"Chisquare of track fitting");
   G__memvar_setup((void*)((long)(&p->Status)-(long)(p)),105,0,0,-1,-1,-1,1,"Status=",0,"Status word");
   }
   G__tag_memvar_reset();
}


   /* DCV1_t */
static void G__setup_memvarDCV1_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCV1_t));
   { DCV1_t *p; p=(DCV1_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->TsR1)-(long)(p)),102,0,0,-1,-1,-1,1,"TsR1=",0,"Tsmear ");
   G__memvar_setup((void*)((long)(&p->V0R1)-(long)(p)),102,0,0,-1,-1,-1,1,"V0R1=",0,"drift velocity (slope)");
   G__memvar_setup((void*)((long)(&p->TmR1)-(long)(p)),102,0,0,-1,-1,-1,1,"TmR1=",0,"Maximum drift time (Tmax)");
   G__memvar_setup((void*)((long)(&p->sp1R1)-(long)(p)),102,0,0,-1,-1,-1,1,"sp1R1=",0,"spare  ");
   G__memvar_setup((void*)((long)(&p->sp2R1)-(long)(p)),102,0,0,-1,-1,-1,1,"sp2R1=",0,"spare	 ");
   }
   G__tag_memvar_reset();
}


   /* DCV2_t */
static void G__setup_memvarDCV2_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCV2_t));
   { DCV2_t *p; p=(DCV2_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->Ts1R2)-(long)(p)),102,0,0,-1,-1,-1,1,"Ts1R2=",0,"Tsmear ");
   G__memvar_setup((void*)((long)(&p->V01R2)-(long)(p)),102,0,0,-1,-1,-1,1,"V01R2=",0,"drift velocity (slope)");
   G__memvar_setup((void*)((long)(&p->VA1R2)-(long)(p)),102,0,0,-1,-1,-1,1,"VA1R2=",0,"drift velocity function parameter");
   G__memvar_setup((void*)((long)(&p->VB1R2)-(long)(p)),102,0,0,-1,-1,-1,1,"VB1R2=",0,"drift velocity function parameter  ");
   G__memvar_setup((void*)((long)(&p->Tm1R2)-(long)(p)),102,0,0,-1,-1,-1,1,"Tm1R2=",0,"Maximum drift time (Tmax) 		 ");
   G__memvar_setup((void*)((long)(&p->TA1R2)-(long)(p)),102,0,0,-1,-1,-1,1,"TA1R2=",0,"Tmax function parameter");
   G__memvar_setup((void*)((long)(&p->TB1R2)-(long)(p)),102,0,0,-1,-1,-1,1,"TB1R2=",0,"Tmax function parameter");
   G__memvar_setup((void*)((long)(&p->Ts2R2)-(long)(p)),102,0,0,-1,-1,-1,1,"Ts2R2=",0,"Tsmear ");
   G__memvar_setup((void*)((long)(&p->V02R2)-(long)(p)),102,0,0,-1,-1,-1,1,"V02R2=",0,"drift velocity (slope)");
   G__memvar_setup((void*)((long)(&p->VA2R2)-(long)(p)),102,0,0,-1,-1,-1,1,"VA2R2=",0,"drift velocity function parameter");
   G__memvar_setup((void*)((long)(&p->VB2R2)-(long)(p)),102,0,0,-1,-1,-1,1,"VB2R2=",0,"drift velocity function parameter  ");
   G__memvar_setup((void*)((long)(&p->Tm2R2)-(long)(p)),102,0,0,-1,-1,-1,1,"Tm2R2=",0,"Maximum drift time (Tmax) 		 ");
   G__memvar_setup((void*)((long)(&p->TA2R2)-(long)(p)),102,0,0,-1,-1,-1,1,"TA2R2=",0,"Tmax function parameter");
   G__memvar_setup((void*)((long)(&p->TB2R2)-(long)(p)),102,0,0,-1,-1,-1,1,"TB2R2=",0,"Tmax function parameter");
   }
   G__tag_memvar_reset();
}


   /* DCV3_t */
static void G__setup_memvarDCV3_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCV3_t));
   { DCV3_t *p; p=(DCV3_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->TsR3)-(long)(p)),102,0,0,-1,-1,-1,1,"TsR3=",0,"Tsmear ");
   G__memvar_setup((void*)((long)(&p->V0R3)-(long)(p)),102,0,0,-1,-1,-1,1,"V0R3=",0,"drift velocity (slope)");
   G__memvar_setup((void*)((long)(&p->TmR3)-(long)(p)),102,0,0,-1,-1,-1,1,"TmR3=",0,"Maximum drift time (Tmax)");
   G__memvar_setup((void*)((long)(&p->sp1R3)-(long)(p)),102,0,0,-1,-1,-1,1,"sp1R3=",0,"spare  ");
   G__memvar_setup((void*)((long)(&p->sp2R3)-(long)(p)),102,0,0,-1,-1,-1,1,"sp2R3=",0,"spare	 ");
   }
   G__tag_memvar_reset();
}


   /* DDLY_t */
static void G__setup_memvarDDLY_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DDLY_t));
   { DDLY_t *p; p=(DDLY_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"ID_wire ");
   G__memvar_setup((void*)((long)(&p->TIDLY)-(long)(p)),102,0,0,-1,-1,-1,1,"TIDLY=",0,"TIme DeLaY (ns) 		 ");
   G__memvar_setup((void*)((long)(&p->STAT)-(long)(p)),105,0,0,-1,-1,-1,1,"STAT=",0,"wire STATus = 100*C + 10*A + B");
   }
   G__tag_memvar_reset();
}


   /* DGEO_t */
static void G__setup_memvarDGEO_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DGEO_t));
   { DGEO_t *p; p=(DGEO_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID_sec)-(long)(p)),105,0,0,-1,-1,-1,1,"ID_sec=",0,"ID_sector ");
   G__memvar_setup((void*)((long)(&p->ID_reg)-(long)(p)),105,0,0,-1,-1,-1,1,"ID_reg=",0,"ID_region ");
   G__memvar_setup((void*)((long)(&p->xpos)-(long)(p)),102,0,0,-1,-1,-1,1,"xpos=",0,"x misalignment 		 ");
   G__memvar_setup((void*)((long)(&p->ypos)-(long)(p)),102,0,0,-1,-1,-1,1,"ypos=",0,"y misalignment 		 ");
   G__memvar_setup((void*)((long)(&p->zpos)-(long)(p)),102,0,0,-1,-1,-1,1,"zpos=",0,"z misalignment 		 ");
   G__memvar_setup((void*)((long)(&p->sxpos)-(long)(p)),102,0,0,-1,-1,-1,1,"sxpos=",0,"sx sine of little x angle 		 ");
   G__memvar_setup((void*)((long)(&p->sypos)-(long)(p)),102,0,0,-1,-1,-1,1,"sypos=",0,"sy sine of little y angle ");
   G__memvar_setup((void*)((long)(&p->szpos)-(long)(p)),102,0,0,-1,-1,-1,1,"szpos=",0,"sz sine of little z angle ");
   }
   G__tag_memvar_reset();
}


   /* DHCL_t */
static void G__setup_memvarDHCL_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DHCL_t));
   { DHCL_t *p; p=(DHCL_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->SLY)-(long)(p)),105,0,0,-1,-1,-1,1,"SLY=",0,"superlayer");
   G__memvar_setup((void*)((long)(&p->BTRK)-(long)(p)),105,0,0,-1,-1,-1,1,"BTRK=",0,"track_in_sector# (bit set)");
   G__memvar_setup((void*)((long)(&p->TRKS1)-(long)(p)),105,0,0,-1,-1,-1,1,"TRKS1=",0,"combinations to track segments");
   G__memvar_setup((void*)((long)(&p->TRKS2)-(long)(p)),105,0,0,-1,-1,-1,1,"TRKS2=",0,"\"             \"       \"");
   G__memvar_setup((void*)((long)(&p->WIRE1)-(long)(p)),105,0,0,-1,-1,-1,1,"WIRE1=",0,"1.wire# in this cluster in 1.layer");
   G__memvar_setup((void*)((long)(&p->BWIR1)-(long)(p)),105,0,0,-1,-1,-1,1,"BWIR1=",0,"hits in this layer (starting from WIRE1) (bit st)");
   G__memvar_setup((void*)((long)(&p->WIRE2)-(long)(p)),105,0,0,-1,-1,-1,1,"WIRE2=",0,"1.wire# in this cluster in 1.layer");
   G__memvar_setup((void*)((long)(&p->BWIR2)-(long)(p)),105,0,0,-1,-1,-1,1,"BWIR2=",0,"hits in this layer (starting from WIRE1) (bit st)");
   G__memvar_setup((void*)((long)(&p->WIRE3)-(long)(p)),105,0,0,-1,-1,-1,1,"WIRE3=",0,"1.wire# in this cluster in 1.layer");
   G__memvar_setup((void*)((long)(&p->BWIR3)-(long)(p)),105,0,0,-1,-1,-1,1,"BWIR3=",0,"hits in this layer (starting from WIRE1) (bit st)");
   G__memvar_setup((void*)((long)(&p->WIRE4)-(long)(p)),105,0,0,-1,-1,-1,1,"WIRE4=",0,"1.wire# in this cluster in 1.layer");
   G__memvar_setup((void*)((long)(&p->BWIR4)-(long)(p)),105,0,0,-1,-1,-1,1,"BWIR4=",0,"hits in this layer (starting from WIRE1) (bit st)");
   G__memvar_setup((void*)((long)(&p->WIRE5)-(long)(p)),105,0,0,-1,-1,-1,1,"WIRE5=",0,"1.wire# in this cluster in 1.layer");
   G__memvar_setup((void*)((long)(&p->BWIR5)-(long)(p)),105,0,0,-1,-1,-1,1,"BWIR5=",0,"hits in this layer (starting from WIRE1) (bit st)");
   G__memvar_setup((void*)((long)(&p->WIRE6)-(long)(p)),105,0,0,-1,-1,-1,1,"WIRE6=",0,"1.wire# in this cluster in 1.layer");
   G__memvar_setup((void*)((long)(&p->BWIR6)-(long)(p)),105,0,0,-1,-1,-1,1,"BWIR6=",0,"hits in this layer (starting from WIRE1) (bit st)");
   }
   G__tag_memvar_reset();
}


   /* DITM_t */
static void G__setup_memvarDITM_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DITM_t));
   { DITM_t *p; p=(DITM_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->time)-(long)(p)),105,0,0,-1,-1,-1,1,"time=",0,"time of discriminator calibration");
   }
   G__tag_memvar_reset();
}


   /* DOCA_t */
static void G__setup_memvarDOCA_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DOCA_t));
   { DOCA_t *p; p=(DOCA_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->DOCA)-(long)(p)),114,0,0,-1,-1,-1,1,"DOCA=",0,"doca from GSIM (micron)");
   }
   G__tag_memvar_reset();
}


   /* DPCP_t */
static void G__setup_memvarDPCP_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DPCP_t));
   { DPCP_t *p; p=(DPCP_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->MN_mean)-(long)(p)),105,0,0,-1,-1,-1,1,"MN_mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->MN_sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"MN_sigma=",0,"sigma of the pedestal distribution (channel)");
   G__memvar_setup((void*)((long)(&p->LT_mean)-(long)(p)),105,0,0,-1,-1,-1,1,"LT_mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->LT_sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"LT_sigma=",0,"sigma of the pedestal distribution (channel)");
   G__memvar_setup((void*)((long)(&p->RB_mean)-(long)(p)),105,0,0,-1,-1,-1,1,"RB_mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->RB_sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"RB_sigma=",0,"sigma of the pedestal distribution (channel)");
   G__memvar_setup((void*)((long)(&p->LB_mean)-(long)(p)),105,0,0,-1,-1,-1,1,"LB_mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->LB_sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"LB_sigma=",0,"sigma of the pedestal distribution (channel)");
   G__memvar_setup((void*)((long)(&p->RT_mean)-(long)(p)),105,0,0,-1,-1,-1,1,"RT_mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->RT_sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"RT_sigma=",0,"sigma of the pedestal distribution (channel)");
   G__memvar_setup((void*)((long)(&p->VT_mean)-(long)(p)),105,0,0,-1,-1,-1,1,"VT_mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->VT_sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"VT_sigma=",0,"sigma of the pedestal distribution (channel)");
   }
   G__tag_memvar_reset();
}


   /* DPSP_t */
static void G__setup_memvarDPSP_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DPSP_t));
   { DPSP_t *p; p=(DPSP_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->mean)-(long)(p)),105,0,0,-1,-1,-1,1,"mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma=",0,"sigma of the pedestal distribution (channel)");
   }
   G__tag_memvar_reset();
}


   /* DSPC_t */
static void G__setup_memvarDSPC_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DSPC_t));
   { DSPC_t *p; p=(DSPC_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->PCID)-(long)(p)),114,0,0,-1,-1,-1,1,"PCID=",0,"Id compelled by DAQ (always 1)");
   G__memvar_setup((void*)((long)(&p->TDCPC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDCPC=",0,"tdc information ( scintillator)");
   G__memvar_setup((void*)((long)(&p->ADCMN)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCMN=",0,"adc information (main)");
   G__memvar_setup((void*)((long)(&p->ADCLT)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCLT=",0,"adc information (left top)");
   G__memvar_setup((void*)((long)(&p->ADCRB)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCRB=",0,"adc information (right bottom)");
   G__memvar_setup((void*)((long)(&p->ADCLB)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCLB=",0,"adc information (left bottom)");
   G__memvar_setup((void*)((long)(&p->ADCRT)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCRT=",0,"adc information (right top)");
   G__memvar_setup((void*)((long)(&p->ADCVE)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCVE=",0,"adc information (veto)");
   }
   G__tag_memvar_reset();
}


   /* DSPS_t */
static void G__setup_memvarDSPS_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DSPS_t));
   { DSPS_t *p; p=(DSPS_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"paddle ID (left = 1 to 4)( right = 5 to 8)");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information");
   G__memvar_setup((void*)((long)(&p->ADC)-(long)(p)),114,0,0,-1,-1,-1,1,"ADC=",0,"adc information ");
   }
   G__tag_memvar_reset();
}


   /* DSTC_t */
static void G__setup_memvarDSTC_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DSTC_t));
   { DSTC_t *p; p=(DSTC_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->TACID)-(long)(p)),114,0,0,-1,-1,-1,1,"TACID=",0,"ID compelled by DAQ (always 1)");
   G__memvar_setup((void*)((long)(&p->TDCTAC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDCTAC=",0,"tdc information (on sum)");
   G__memvar_setup((void*)((long)(&p->ADCLT)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCLT=",0,"adc information (left top)");
   G__memvar_setup((void*)((long)(&p->ADCRT)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCRT=",0,"adc information (right top)");
   G__memvar_setup((void*)((long)(&p->ADCLB)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCLB=",0,"adc information (left bottom)");
   G__memvar_setup((void*)((long)(&p->ADCRB)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCRB=",0,"adc information (right bottom)");
   G__memvar_setup((void*)((long)(&p->ADCSUM1)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCSUM1=",0,"adc information (sum scale1)");
   G__memvar_setup((void*)((long)(&p->ADCSUM2)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCSUM2=",0,"adc information (sum scale2)");
   G__memvar_setup((void*)((long)(&p->ADCSUM3)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCSUM3=",0,"adc information (sum scale3)");
   }
   G__tag_memvar_reset();
}


   /* DTCP_t */
static void G__setup_memvarDTCP_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DTCP_t));
   { DTCP_t *p; p=(DTCP_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->LT_mean)-(long)(p)),105,0,0,-1,-1,-1,1,"LT_mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->LT_sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"LT_sigma=",0,"sigma of the pedestal distribution (channel)");
   G__memvar_setup((void*)((long)(&p->RT_mean)-(long)(p)),105,0,0,-1,-1,-1,1,"RT_mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->RT_sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"RT_sigma=",0,"sigma of the pedestal distribution (channel)");
   G__memvar_setup((void*)((long)(&p->LB_mean)-(long)(p)),105,0,0,-1,-1,-1,1,"LB_mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->LB_sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"LB_sigma=",0,"sigma of the pedestal distribution (channel)");
   G__memvar_setup((void*)((long)(&p->RB_mean)-(long)(p)),105,0,0,-1,-1,-1,1,"RB_mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->RB_sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"RB_sigma=",0,"sigma of the pedestal distribution (channel)");
   G__memvar_setup((void*)((long)(&p->sum1_mean)-(long)(p)),105,0,0,-1,-1,-1,1,"sum1_mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->sum1_sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"sum1_sigma=",0,"sigma of the pedestal distribution (channel)");
   G__memvar_setup((void*)((long)(&p->sum2_mean)-(long)(p)),105,0,0,-1,-1,-1,1,"sum2_mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->sum2_sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"sum2_sigma=",0,"sigma of the pedestal distribution (channel)");
   G__memvar_setup((void*)((long)(&p->sum3_mean)-(long)(p)),105,0,0,-1,-1,-1,1,"sum3_mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->sum3_sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"sum3_sigma=",0,"sigma of the pedestal distribution (channel)");
   }
   G__tag_memvar_reset();
}


   /* DTRK_t */
static void G__setup_memvarDTRK_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DTRK_t));
   { DTRK_t *p; p=(DTRK_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->X)-(long)(p)),102,0,0,-1,-1,-1,1,"X=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Y)-(long)(p)),102,0,0,-1,-1,-1,1,"Y=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Z)-(long)(p)),102,0,0,-1,-1,-1,1,"Z=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* EC01_t */
static void G__setup_memvarEC01_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_EC01_t));
   { EC01_t *p; p=(EC01_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->time)-(long)(p)),102,0,0,-1,-1,-1,1,"time=",0,"time for left paddle(ns) ");
   G__memvar_setup((void*)((long)(&p->energy)-(long)(p)),102,0,0,-1,-1,-1,1,"energy=",0,"energy in left paddle(MeV) ");
   }
   G__tag_memvar_reset();
}


   /* EC1_t */
static void G__setup_memvarEC1_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_EC1_t));
   { EC1_t *p; p=(EC1_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDCL)-(long)(p)),114,0,0,-1,-1,-1,1,"TDCL=",0,"tdc information (channels)");
   G__memvar_setup((void*)((long)(&p->ADCL)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCL=",0,"adc information (channels)");
   G__memvar_setup((void*)((long)(&p->TDCR)-(long)(p)),114,0,0,-1,-1,-1,1,"TDCR=",0,"tdc information (channels)");
   G__memvar_setup((void*)((long)(&p->ADCR)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCR=",0,"adc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* EC1P_t */
static void G__setup_memvarEC1P_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_EC1P_t));
   { EC1P_t *p; p=(EC1P_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->N1x)-(long)(p)),102,0,0,-1,-1,-1,1,"N1x=",0,"x component of outward normal to plane");
   G__memvar_setup((void*)((long)(&p->N1y)-(long)(p)),102,0,0,-1,-1,-1,1,"N1y=",0,"y component of outward normal to plane");
   G__memvar_setup((void*)((long)(&p->N1z)-(long)(p)),102,0,0,-1,-1,-1,1,"N1z=",0,"z component of outward normal to plane");
   G__memvar_setup((void*)((long)(&p->R1n)-(long)(p)),102,0,0,-1,-1,-1,1,"R1n=",0,"distanse in cm from origin to plane");
   }
   G__tag_memvar_reset();
}


   /* EC1R_t */
static void G__setup_memvarEC1R_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_EC1R_t));
   { EC1R_t *p; p=(EC1R_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->E_tot)-(long)(p)),102,0,0,-1,-1,-1,1,"E_tot=",0,"cluster energy (sum of inner+outer)");
   G__memvar_setup((void*)((long)(&p->dE_tot)-(long)(p)),102,0,0,-1,-1,-1,1,"dE_tot=",0,"error on the cluster energy");
   G__memvar_setup((void*)((long)(&p->t_tot)-(long)(p)),102,0,0,-1,-1,-1,1,"t_tot=",0,"time");
   G__memvar_setup((void*)((long)(&p->dt_tot)-(long)(p)),102,0,0,-1,-1,-1,1,"dt_tot=",0,"error on the time");
   G__memvar_setup((void*)((long)(&p->x_m)-(long)(p)),102,0,0,-1,-1,-1,1,"x_m=",0,"x-in CLAS frame");
   G__memvar_setup((void*)((long)(&p->y_m)-(long)(p)),102,0,0,-1,-1,-1,1,"y_m=",0,"y-in CLAS frame");
   G__memvar_setup((void*)((long)(&p->z_m)-(long)(p)),102,0,0,-1,-1,-1,1,"z_m=",0,"z-in CLAS frame");
   G__memvar_setup((void*)((long)(&p->dx_m)-(long)(p)),102,0,0,-1,-1,-1,1,"dx_m=",0,"error on x");
   G__memvar_setup((void*)((long)(&p->dy_m)-(long)(p)),102,0,0,-1,-1,-1,1,"dy_m=",0,"error on y");
   G__memvar_setup((void*)((long)(&p->dz_m)-(long)(p)),102,0,0,-1,-1,-1,1,"dz_m=",0,"error on z");
   G__memvar_setup((void*)((long)(&p->E_in)-(long)(p)),102,0,0,-1,-1,-1,1,"E_in=",0,"cluster energy in inner layer");
   G__memvar_setup((void*)((long)(&p->t_in)-(long)(p)),102,0,0,-1,-1,-1,1,"t_in=",0,"time from inner layer");
   G__memvar_setup((void*)((long)(&p->x_in)-(long)(p)),102,0,0,-1,-1,-1,1,"x_in=",0,"lab coordinate , inner layer");
   G__memvar_setup((void*)((long)(&p->y_in)-(long)(p)),102,0,0,-1,-1,-1,1,"y_in=",0,"lab coordinate , inner layer");
   G__memvar_setup((void*)((long)(&p->x_out)-(long)(p)),102,0,0,-1,-1,-1,1,"x_out=",0,"lab coordinate , outer layer");
   G__memvar_setup((void*)((long)(&p->y_out)-(long)(p)),102,0,0,-1,-1,-1,1,"y_out=",0,"lab coordinate , outer layer");
   G__memvar_setup((void*)((long)(&p->x2_in_l)-(long)(p)),102,0,0,-1,-1,-1,1,"x2_in_l=",0,"second moment of x inner left");
   G__memvar_setup((void*)((long)(&p->x2_in_r)-(long)(p)),102,0,0,-1,-1,-1,1,"x2_in_r=",0,"second moment of x inner right ");
   G__memvar_setup((void*)((long)(&p->y2_in_l)-(long)(p)),102,0,0,-1,-1,-1,1,"y2_in_l=",0,"second moment of y inner left");
   G__memvar_setup((void*)((long)(&p->y2_in_r)-(long)(p)),102,0,0,-1,-1,-1,1,"y2_in_r=",0,"second moment of y inner right");
   G__memvar_setup((void*)((long)(&p->x2_out_l)-(long)(p)),102,0,0,-1,-1,-1,1,"x2_out_l=",0,"second moment of x outer hit left");
   G__memvar_setup((void*)((long)(&p->x2_out_r)-(long)(p)),102,0,0,-1,-1,-1,1,"x2_out_r=",0,"second moment of x outer hit right");
   G__memvar_setup((void*)((long)(&p->y2_out_l)-(long)(p)),102,0,0,-1,-1,-1,1,"y2_out_l=",0,"second moment of y outer hit left");
   G__memvar_setup((void*)((long)(&p->y2_out_r)-(long)(p)),102,0,0,-1,-1,-1,1,"y2_out_r=",0,"second moment of y outer hit right");
   G__memvar_setup((void*)((long)(&p->i_in)-(long)(p)),105,0,0,-1,-1,-1,1,"i_in=",0,"cluster center in X inner short layer");
   G__memvar_setup((void*)((long)(&p->j_in)-(long)(p)),105,0,0,-1,-1,-1,1,"j_in=",0,"cluster center in Y inner long layer");
   G__memvar_setup((void*)((long)(&p->i_out)-(long)(p)),105,0,0,-1,-1,-1,1,"i_out=",0,"cluster center in X outer layers");
   G__memvar_setup((void*)((long)(&p->j_out)-(long)(p)),105,0,0,-1,-1,-1,1,"j_out=",0,"cluster center in Y outer layer");
   G__memvar_setup((void*)((long)(&p->a_in_xl)-(long)(p)),102,0,0,-1,-1,-1,1,"a_in_xl=",0,"energy sum in inner short left pmts");
   G__memvar_setup((void*)((long)(&p->a_in_xr)-(long)(p)),102,0,0,-1,-1,-1,1,"a_in_xr=",0,"energy sum in inner short right pmts");
   G__memvar_setup((void*)((long)(&p->a_in_yl)-(long)(p)),102,0,0,-1,-1,-1,1,"a_in_yl=",0,"energy sum in inner long  left pmts");
   G__memvar_setup((void*)((long)(&p->a_in_yr)-(long)(p)),102,0,0,-1,-1,-1,1,"a_in_yr=",0,"energy sum in inner long  right pmts");
   G__memvar_setup((void*)((long)(&p->a_out_xl)-(long)(p)),102,0,0,-1,-1,-1,1,"a_out_xl=",0,"energy sum in outer short left pmts");
   G__memvar_setup((void*)((long)(&p->a_out_xr)-(long)(p)),102,0,0,-1,-1,-1,1,"a_out_xr=",0,"energy sum in outer short right pmts");
   G__memvar_setup((void*)((long)(&p->a_out_yl)-(long)(p)),102,0,0,-1,-1,-1,1,"a_out_yl=",0,"energy sum in outer long left pmts");
   G__memvar_setup((void*)((long)(&p->a_out_yr)-(long)(p)),102,0,0,-1,-1,-1,1,"a_out_yr=",0,"energy sum in outer long right pmts");
   G__memvar_setup((void*)((long)(&p->t_in_xs)-(long)(p)),102,0,0,-1,-1,-1,1,"t_in_xs=",0,"tdc sum in inner short righ+left  for cluster center");
   G__memvar_setup((void*)((long)(&p->t_in_xd)-(long)(p)),102,0,0,-1,-1,-1,1,"t_in_xd=",0,"tdc dif in inner short right-left ");
   G__memvar_setup((void*)((long)(&p->t_in_ys)-(long)(p)),102,0,0,-1,-1,-1,1,"t_in_ys=",0,"tdc sum in inner long  righ+left");
   G__memvar_setup((void*)((long)(&p->t_in_yd)-(long)(p)),102,0,0,-1,-1,-1,1,"t_in_yd=",0,"tdc dif in inner long  right-left");
   G__memvar_setup((void*)((long)(&p->t_out_xs)-(long)(p)),102,0,0,-1,-1,-1,1,"t_out_xs=",0,"tdc sum in outer short righ+left ");
   G__memvar_setup((void*)((long)(&p->t_out_xd)-(long)(p)),102,0,0,-1,-1,-1,1,"t_out_xd=",0,"tdc dif in outer short right-left ");
   G__memvar_setup((void*)((long)(&p->t_out_ys)-(long)(p)),102,0,0,-1,-1,-1,1,"t_out_ys=",0,"tdc sum in outer long righ+left");
   G__memvar_setup((void*)((long)(&p->t_out_yd)-(long)(p)),102,0,0,-1,-1,-1,1,"t_out_yd=",0,"tdc dif in outer long right-left ");
   G__memvar_setup((void*)((long)(&p->ibl)-(long)(p)),105,0,0,-1,-1,-1,1,"ibl=",0,"LAC  block number");
   G__memvar_setup((void*)((long)(&p->ncluster)-(long)(p)),105,0,0,-1,-1,-1,1,"ncluster=",0,"1000xNclust4+100xNclust3+10xNclust2+Nclust1 ");
   G__memvar_setup((void*)((long)(&p->pmtfired)-(long)(p)),105,0,0,-1,-1,-1,1,"pmtfired=",0,"Number of fired pmt (more than threshold) ");
   G__memvar_setup((void*)((long)(&p->z_in)-(long)(p)),102,0,0,-1,-1,-1,1,"z_in=",0,"Z in CLAS frame");
   G__memvar_setup((void*)((long)(&p->z_out)-(long)(p)),102,0,0,-1,-1,-1,1,"z_out=",0,"Z out in CLAS frame");
   G__memvar_setup((void*)((long)(&p->istat)-(long)(p)),105,0,0,-1,-1,-1,1,"istat=",0,"status word");
   }
   G__tag_memvar_reset();
}


   /* ECCA_t */
static void G__setup_memvarECCA_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECCA_t));
   { ECCA_t *p; p=(ECCA_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->id)-(long)(p)),105,0,0,-1,-1,-1,1,"id=",0,"PMT ID");
   G__memvar_setup((void*)((long)(&p->aPED)-(long)(p)),102,0,0,-1,-1,-1,1,"aPED=",0,"ADC pedestals (channels)");
   G__memvar_setup((void*)((long)(&p->aSIG)-(long)(p)),102,0,0,-1,-1,-1,1,"aSIG=",0,"ADC pedestal variance (channels)");
   G__memvar_setup((void*)((long)(&p->aMIP)-(long)(p)),102,0,0,-1,-1,-1,1,"aMIP=",0,"ADC calibration from MIP (N.I.M.P/ch.)");
   G__memvar_setup((void*)((long)(&p->aMIPu)-(long)(p)),102,0,0,-1,-1,-1,1,"aMIPu=",0,"aMIP Error");
   G__memvar_setup((void*)((long)(&p->aSHR)-(long)(p)),102,0,0,-1,-1,-1,1,"aSHR=",0,"ADC calibration from showers (GeV/ch.)");
   G__memvar_setup((void*)((long)(&p->aSHRu)-(long)(p)),102,0,0,-1,-1,-1,1,"aSHRu=",0,"aSHR Error");
   G__memvar_setup((void*)((long)(&p->stat)-(long)(p)),105,0,0,-1,-1,-1,1,"stat=",0,"4 byte status word    ");
   }
   G__tag_memvar_reset();
}


   /* ECCL_t */
static void G__setup_memvarECCL_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECCL_t));
   { ECCL_t *p; p=(ECCL_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->id)-(long)(p)),105,0,0,-1,-1,-1,1,"id=",0,"PMT ID");
   G__memvar_setup((void*)((long)(&p->lDB)-(long)(p)),102,0,0,-1,-1,-1,1,"lDB=",0,"Stack atten length (database)(cm)");
   G__memvar_setup((void*)((long)(&p->lDBu)-(long)(p)),102,0,0,-1,-1,-1,1,"lDBu=",0,"lDB Error (cm)");
   G__memvar_setup((void*)((long)(&p->lMIP)-(long)(p)),102,0,0,-1,-1,-1,1,"lMIP=",0,"Stack atten length (MinIonPart)(cm) ");
   G__memvar_setup((void*)((long)(&p->lMIPu)-(long)(p)),102,0,0,-1,-1,-1,1,"lMIPu=",0,"lMIP Error (cm)");
   G__memvar_setup((void*)((long)(&p->lSHR)-(long)(p)),102,0,0,-1,-1,-1,1,"lSHR=",0,"Stack atten length (showers)(cm)  ");
   G__memvar_setup((void*)((long)(&p->lSHRu)-(long)(p)),102,0,0,-1,-1,-1,1,"lSHRu=",0,"lSHR Error (cm) ");
   G__memvar_setup((void*)((long)(&p->stat)-(long)(p)),105,0,0,-1,-1,-1,1,"stat=",0,"4 byte status word    ");
   }
   G__tag_memvar_reset();
}


   /* ECCT_t */
static void G__setup_memvarECCT_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECCT_t));
   { ECCT_t *p; p=(ECCT_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->id)-(long)(p)),105,0,0,-1,-1,-1,1,"id=",0,"PMT ID");
   G__memvar_setup((void*)((long)(&p->tOFF)-(long)(p)),102,0,0,-1,-1,-1,1,"tOFF=",0,"TDC offset (channels)");
   G__memvar_setup((void*)((long)(&p->tOFFu)-(long)(p)),102,0,0,-1,-1,-1,1,"tOFFu=",0,"tOFF Error");
   G__memvar_setup((void*)((long)(&p->tGAIN)-(long)(p)),102,0,0,-1,-1,-1,1,"tGAIN=",0,"TDC conversion gain (nS/channel)");
   G__memvar_setup((void*)((long)(&p->tGAINu)-(long)(p)),102,0,0,-1,-1,-1,1,"tGAINu=",0,"tGAIN Error");
   G__memvar_setup((void*)((long)(&p->tW0)-(long)(p)),102,0,0,-1,-1,-1,1,"tW0=",0,"Time walk constant (channels)");
   G__memvar_setup((void*)((long)(&p->tW0u)-(long)(p)),102,0,0,-1,-1,-1,1,"tW0u=",0,"tWOu Error");
   G__memvar_setup((void*)((long)(&p->tW1)-(long)(p)),102,0,0,-1,-1,-1,1,"tW1=",0,"Time walk correction parameter ");
   G__memvar_setup((void*)((long)(&p->tW1u)-(long)(p)),102,0,0,-1,-1,-1,1,"tW1u=",0,"tW1u Error");
   G__memvar_setup((void*)((long)(&p->tVEF)-(long)(p)),102,0,0,-1,-1,-1,1,"tVEF=",0,"Effective velocity of light (cm/ns)");
   G__memvar_setup((void*)((long)(&p->tVEFu)-(long)(p)),102,0,0,-1,-1,-1,1,"tVEFu=",0,"tVEFu Error");
   G__memvar_setup((void*)((long)(&p->stat)-(long)(p)),105,0,0,-1,-1,-1,1,"stat=",0,"4 byte status word    ");
   }
   G__tag_memvar_reset();
}


   /* EC_t */
static void G__setup_memvarEC_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_EC_t));
   { EC_t *p; p=(EC_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels)");
   G__memvar_setup((void*)((long)(&p->ADC)-(long)(p)),114,0,0,-1,-1,-1,1,"ADC=",0,"adc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* ECDI_t */
static void G__setup_memvarECDI_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECDI_t));
   { ECDI_t *p; p=(ECDI_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->crate)-(long)(p)),105,0,0,-1,-1,-1,1,"crate=",0,"CAMAC crate number");
   G__memvar_setup((void*)((long)(&p->slot)-(long)(p)),105,0,0,-1,-1,-1,1,"slot=",0,"slot");
   G__memvar_setup((void*)((long)(&p->mask)-(long)(p)),105,0,0,-1,-1,-1,1,"mask=",0,"mask");
   G__memvar_setup((void*)((long)(&p->threshold)-(long)(p)),105,0,0,-1,-1,-1,1,"threshold=",0,"actual threshold value (mV)");
   G__memvar_setup((void*)((long)(&p->width)-(long)(p)),105,0,0,-1,-1,-1,1,"width=",0,"actual width value");
   }
   G__tag_memvar_reset();
}


   /* ECG_t */
static void G__setup_memvarECG_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECG_t));
   { ECG_t *p; p=(ECG_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->L0)-(long)(p)),102,0,0,-1,-1,-1,1,"L0=",0,"distance from the target ");
   G__memvar_setup((void*)((long)(&p->THE0)-(long)(p)),102,0,0,-1,-1,-1,1,"THE0=",0,"angle between the beam and perpendicular");
   G__memvar_setup((void*)((long)(&p->YLOW)-(long)(p)),102,0,0,-1,-1,-1,1,"YLOW=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->YHI)-(long)(p)),102,0,0,-1,-1,-1,1,"YHI=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DYLOW)-(long)(p)),102,0,0,-1,-1,-1,1,"DYLOW=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DYHI)-(long)(p)),102,0,0,-1,-1,-1,1,"DYHI=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->LRTH)-(long)(p)),102,0,0,-1,-1,-1,1,"LRTH=",0,"thickness of the single layer");
   G__memvar_setup((void*)((long)(&p->TANGR)-(long)(p)),102,0,0,-1,-1,-1,1,"TANGR=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SECTOR)-(long)(p)),105,0,0,-1,-1,-1,1,"SECTOR=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PHISEC)-(long)(p)),102,0,0,-1,-1,-1,1,"PHISEC=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->X0OFF)-(long)(p)),102,0,0,-1,-1,-1,1,"X0OFF=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Y0OFF)-(long)(p)),102,0,0,-1,-1,-1,1,"Y0OFF=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Z0OFF)-(long)(p)),102,0,0,-1,-1,-1,1,"Z0OFF=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ROTM11)-(long)(p)),102,0,0,-1,-1,-1,1,"ROTM11=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ROTM12)-(long)(p)),102,0,0,-1,-1,-1,1,"ROTM12=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ROTM13)-(long)(p)),102,0,0,-1,-1,-1,1,"ROTM13=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ROTM21)-(long)(p)),102,0,0,-1,-1,-1,1,"ROTM21=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ROTM22)-(long)(p)),102,0,0,-1,-1,-1,1,"ROTM22=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ROTM23)-(long)(p)),102,0,0,-1,-1,-1,1,"ROTM23=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ROTM31)-(long)(p)),102,0,0,-1,-1,-1,1,"ROTM31=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ROTM32)-(long)(p)),102,0,0,-1,-1,-1,1,"ROTM32=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ROTM33)-(long)(p)),102,0,0,-1,-1,-1,1,"ROTM33=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ECHB_t */
static void G__setup_memvarECHB_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECHB_t));
   { ECHB_t *p; p=(ECHB_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->Sect)-(long)(p)),105,0,0,-1,-1,-1,1,"Sect=",0,"Sector number & Layer number");
   G__memvar_setup((void*)((long)(&p->E__hit)-(long)(p)),102,0,0,-1,-1,-1,1,"E__hit=",0,"energy found ");
   G__memvar_setup((void*)((long)(&p->dE_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"dE_hit=",0,"error on the energy found ");
   G__memvar_setup((void*)((long)(&p->t_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"t_hit=",0,"time found ");
   G__memvar_setup((void*)((long)(&p->dt_hi)-(long)(p)),102,0,0,-1,-1,-1,1,"dt_hi=",0,"error time found ");
   G__memvar_setup((void*)((long)(&p->i_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"i_hit=",0,"sector rectangular coordinate ");
   G__memvar_setup((void*)((long)(&p->j_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"j_hit=",0,"sector rectangular coordinate ");
   G__memvar_setup((void*)((long)(&p->di_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"di_hit=",0,"sector rectangular coordinate error,");
   G__memvar_setup((void*)((long)(&p->dj_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"dj_hit=",0,"sector rectangular coordinate error,");
   G__memvar_setup((void*)((long)(&p->x_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"x_hit=",0,"lab coordinate,");
   G__memvar_setup((void*)((long)(&p->y_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"y_hit=",0,"lab coordinate,");
   G__memvar_setup((void*)((long)(&p->z_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"z_hit=",0,"lab coordinate,");
   G__memvar_setup((void*)((long)(&p->dx_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"dx_hit=",0,"lab coordinate error,");
   G__memvar_setup((void*)((long)(&p->dy_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"dy_hit=",0,"lab coordinate error, ");
   G__memvar_setup((void*)((long)(&p->dz_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"dz_hit=",0,"lab coordinate error,");
   G__memvar_setup((void*)((long)(&p->u2_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"u2_hit=",0,"second moment of u  _hit pattern");
   G__memvar_setup((void*)((long)(&p->v2_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"v2_hit=",0,"second moment of v  _hit pattern");
   G__memvar_setup((void*)((long)(&p->w2_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"w2_hit=",0,"second moment of w  _hit pattern");
   G__memvar_setup((void*)((long)(&p->u3_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"u3_hit=",0,"third moment of u  _hit pattern ");
   G__memvar_setup((void*)((long)(&p->v3_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"v3_hit=",0,"third moment of v  _hit pattern ");
   G__memvar_setup((void*)((long)(&p->w3_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"w3_hit=",0,"third moment of w  _hit pattern ");
   G__memvar_setup((void*)((long)(&p->u4_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"u4_hit=",0,"forth moment of u  _hit pattern ");
   G__memvar_setup((void*)((long)(&p->v4_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"v4_hit=",0,"forth moment of v  _hit pattern ");
   G__memvar_setup((void*)((long)(&p->w4_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"w4_hit=",0,"forth moment of w  _hit pattern ");
   G__memvar_setup((void*)((long)(&p->centr_U)-(long)(p)),102,0,0,-1,-1,-1,1,"centr_U=",0,"peak position on U axis ");
   G__memvar_setup((void*)((long)(&p->centr_V)-(long)(p)),102,0,0,-1,-1,-1,1,"centr_V=",0,"peak position on V axis ");
   G__memvar_setup((void*)((long)(&p->centr_W)-(long)(p)),102,0,0,-1,-1,-1,1,"centr_W=",0,"peak position on W axis ");
   G__memvar_setup((void*)((long)(&p->path_U)-(long)(p)),102,0,0,-1,-1,-1,1,"path_U=",0,"path length from hit position to U axis ");
   G__memvar_setup((void*)((long)(&p->path_V)-(long)(p)),102,0,0,-1,-1,-1,1,"path_V=",0,"path length from hit position to V axis ");
   G__memvar_setup((void*)((long)(&p->path_W)-(long)(p)),102,0,0,-1,-1,-1,1,"path_W=",0,"path length from hit position to W axis ");
   G__memvar_setup((void*)((long)(&p->Nstrp_U)-(long)(p)),105,0,0,-1,-1,-1,1,"Nstrp_U=",0,"Number of U strips in the hit");
   G__memvar_setup((void*)((long)(&p->Nstrp_V)-(long)(p)),105,0,0,-1,-1,-1,1,"Nstrp_V=",0,"Number of V strips in the hit");
   G__memvar_setup((void*)((long)(&p->Nstrp_W)-(long)(p)),105,0,0,-1,-1,-1,1,"Nstrp_W=",0,"Number of W strips in the hit");
   G__memvar_setup((void*)((long)(&p->MatchID1)-(long)(p)),105,0,0,-1,-1,-1,1,"MatchID1=",0,"Id of matched hit in the layer1");
   G__memvar_setup((void*)((long)(&p->CH21)-(long)(p)),102,0,0,-1,-1,-1,1,"CH21=",0,"Quality measure of matching with layer1");
   G__memvar_setup((void*)((long)(&p->MatchID2)-(long)(p)),105,0,0,-1,-1,-1,1,"MatchID2=",0,"Id of matched hit in the layer2");
   G__memvar_setup((void*)((long)(&p->CH22)-(long)(p)),102,0,0,-1,-1,-1,1,"CH22=",0,"Quality measure of matching with layer2");
   G__memvar_setup((void*)((long)(&p->istat)-(long)(p)),105,0,0,-1,-1,-1,1,"istat=",0,"Number of hits & hit ID");
   }
   G__tag_memvar_reset();
}


   /* ECH_t */
static void G__setup_memvarECH_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECH_t));
   { ECH_t *p; p=(ECH_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"x of hit");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y of hit");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z of hit");
   G__memvar_setup((void*)((long)(&p->cx)-(long)(p)),102,0,0,-1,-1,-1,1,"cx=",0,"track x dir cosine");
   G__memvar_setup((void*)((long)(&p->cy)-(long)(p)),102,0,0,-1,-1,-1,1,"cy=",0,"track y dir cosine");
   G__memvar_setup((void*)((long)(&p->cz)-(long)(p)),102,0,0,-1,-1,-1,1,"cz=",0,"track z dir cosine");
   G__memvar_setup((void*)((long)(&p->pmom)-(long)(p)),102,0,0,-1,-1,-1,1,"pmom=",0,"track momentum");
   G__memvar_setup((void*)((long)(&p->id)-(long)(p)),105,0,0,-1,-1,-1,1,"id=",0,"track PDG id");
   G__memvar_setup((void*)((long)(&p->tof)-(long)(p)),102,0,0,-1,-1,-1,1,"tof=",0,"time of flight");
   G__memvar_setup((void*)((long)(&p->edepin)-(long)(p)),102,0,0,-1,-1,-1,1,"edepin=",0,"deposit energy (inner part)");
   G__memvar_setup((void*)((long)(&p->edepout)-(long)(p)),102,0,0,-1,-1,-1,1,"edepout=",0,"deposit energy (outer part)");
   }
   G__tag_memvar_reset();
}


   /* ECMT_t */
static void G__setup_memvarECMT_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECMT_t));
   { ECMT_t *p; p=(ECMT_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->in_high)-(long)(p)),105,0,0,-1,-1,-1,1,"in_high=",0,"inner high threshold (mV)");
   G__memvar_setup((void*)((long)(&p->out_high)-(long)(p)),105,0,0,-1,-1,-1,1,"out_high=",0,"outer high threshold (mV)");
   G__memvar_setup((void*)((long)(&p->total_high)-(long)(p)),105,0,0,-1,-1,-1,1,"total_high=",0,"total high threshold (mV)");
   G__memvar_setup((void*)((long)(&p->in_lo)-(long)(p)),105,0,0,-1,-1,-1,1,"in_lo=",0,"inner lo threshold (mV)");
   G__memvar_setup((void*)((long)(&p->out_lo)-(long)(p)),105,0,0,-1,-1,-1,1,"out_lo=",0,"outer lo threshold (mV)");
   G__memvar_setup((void*)((long)(&p->total_lo)-(long)(p)),105,0,0,-1,-1,-1,1,"total_lo=",0,"total lo threshold (mV)");
   }
   G__tag_memvar_reset();
}


   /* ECP1_t */
static void G__setup_memvarECP1_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECP1_t));
   { ECP1_t *p; p=(ECP1_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->mean_left)-(long)(p)),105,0,0,-1,-1,-1,1,"mean_left=",0,"left adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->sigma_left)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma_left=",0,"sigma of the pedestal distribution for left adc (channel)");
   G__memvar_setup((void*)((long)(&p->mean_right)-(long)(p)),105,0,0,-1,-1,-1,1,"mean_right=",0,"right adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->sigma_right)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma_right=",0,"sigma of the pedestal distribution for right adc (channel");
   }
   G__tag_memvar_reset();
}


   /* ECPB_t */
static void G__setup_memvarECPB_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECPB_t));
   { ECPB_t *p; p=(ECPB_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ScHt)-(long)(p)),105,0,0,-1,-1,-1,1,"ScHt=",0,"100*sector+Whole_Hit_ID in ECHB ");
   G__memvar_setup((void*)((long)(&p->Etot)-(long)(p)),102,0,0,-1,-1,-1,1,"Etot=",0,"Reconstructed total energy");
   G__memvar_setup((void*)((long)(&p->Ein)-(long)(p)),102,0,0,-1,-1,-1,1,"Ein=",0,"Inner energy");
   G__memvar_setup((void*)((long)(&p->Eout)-(long)(p)),102,0,0,-1,-1,-1,1,"Eout=",0,"Outer energy ");
   G__memvar_setup((void*)((long)(&p->Time)-(long)(p)),102,0,0,-1,-1,-1,1,"Time=",0,"Flight time relative to the evnt start time");
   G__memvar_setup((void*)((long)(&p->Path)-(long)(p)),102,0,0,-1,-1,-1,1,"Path=",0,"Path lenght from target");
   G__memvar_setup((void*)((long)(&p->X)-(long)(p)),102,0,0,-1,-1,-1,1,"X=",0,"x coordinate of hit ");
   G__memvar_setup((void*)((long)(&p->Y)-(long)(p)),102,0,0,-1,-1,-1,1,"Y=",0,"y coordinate of hit");
   G__memvar_setup((void*)((long)(&p->Z)-(long)(p)),102,0,0,-1,-1,-1,1,"Z=",0,"z coordinate of hit");
   G__memvar_setup((void*)((long)(&p->M2_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"M2_hit=",0,"second moment of _hit pattern");
   G__memvar_setup((void*)((long)(&p->M3_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"M3_hit=",0,"third moment of  _hit pattern ");
   G__memvar_setup((void*)((long)(&p->M4_hit)-(long)(p)),102,0,0,-1,-1,-1,1,"M4_hit=",0,"forth moment of  _hit pattern ");
   G__memvar_setup((void*)((long)(&p->InnStr)-(long)(p)),105,0,0,-1,-1,-1,1,"InnStr=",0,"10000*UI+100*VI+WI ");
   G__memvar_setup((void*)((long)(&p->OutStr)-(long)(p)),105,0,0,-1,-1,-1,1,"OutStr=",0,"10000*UO+100*VO+WO ");
   G__memvar_setup((void*)((long)(&p->Chi2EC)-(long)(p)),102,0,0,-1,-1,-1,1,"Chi2EC=",0,"Quality measure of geometrical matching");
   G__memvar_setup((void*)((long)(&p->Status)-(long)(p)),105,0,0,-1,-1,-1,1,"Status=",0,"Status word (not implemented yet)");
   }
   G__tag_memvar_reset();
}


   /* ECPC_t */
static void G__setup_memvarECPC_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECPC_t));
   { ECPC_t *p; p=(ECPC_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"layer(1-3) * 100 + strip ID");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),102,0,0,-1,-1,-1,1,"TDC=",0,"tdc (channels)");
   G__memvar_setup((void*)((long)(&p->ADC)-(long)(p)),102,0,0,-1,-1,-1,1,"ADC=",0,"adc - pedestal (channels)");
   }
   G__tag_memvar_reset();
}


   /* ECP_t */
static void G__setup_memvarECP_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECP_t));
   { ECP_t *p; p=(ECP_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->N1x)-(long)(p)),102,0,0,-1,-1,-1,1,"N1x=",0,"x component of outward normal to plane");
   G__memvar_setup((void*)((long)(&p->N1y)-(long)(p)),102,0,0,-1,-1,-1,1,"N1y=",0,"y component of outward normal to plane");
   G__memvar_setup((void*)((long)(&p->N1z)-(long)(p)),102,0,0,-1,-1,-1,1,"N1z=",0,"z component of outward normal to plane");
   G__memvar_setup((void*)((long)(&p->R1n)-(long)(p)),102,0,0,-1,-1,-1,1,"R1n=",0,"distanse in cm from origin to plane");
   G__memvar_setup((void*)((long)(&p->PlW)-(long)(p)),102,0,0,-1,-1,-1,1,"PlW=",0,"whole plane depth");
   G__memvar_setup((void*)((long)(&p->PlI)-(long)(p)),102,0,0,-1,-1,-1,1,"PlI=",0,"inner plane depth");
   G__memvar_setup((void*)((long)(&p->PlO)-(long)(p)),102,0,0,-1,-1,-1,1,"PlO=",0,"outer plane depth");
   }
   G__tag_memvar_reset();
}


   /* ECPE_t */
static void G__setup_memvarECPE_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECPE_t));
   { ECPE_t *p; p=(ECPE_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->mean)-(long)(p)),105,0,0,-1,-1,-1,1,"mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma=",0,"sigma of the pedestal distribution (channel)");
   }
   G__tag_memvar_reset();
}


   /* ECPI_t */
static void G__setup_memvarECPI_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECPI_t));
   { ECPI_t *p; p=(ECPI_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"sector number");
   G__memvar_setup((void*)((long)(&p->Layer)-(long)(p)),105,0,0,-1,-1,-1,1,"Layer=",0,"layer number, note 1-inner, 2-outer, 3-whole");
   G__memvar_setup((void*)((long)(&p->HITID)-(long)(p)),105,0,0,-1,-1,-1,1,"HITID=",0,"number of hits (first 16 bits) and hit ID (last 16 bits)");
   G__memvar_setup((void*)((long)(&p->iloc)-(long)(p)),102,0,0,-1,-1,-1,1,"iloc=",0,"position of the hit in the local coordinate system");
   G__memvar_setup((void*)((long)(&p->jloc)-(long)(p)),102,0,0,-1,-1,-1,1,"jloc=",0,"position of the hit in the local coordinate system");
   G__memvar_setup((void*)((long)(&p->diloc)-(long)(p)),102,0,0,-1,-1,-1,1,"diloc=",0,"i width of the hit");
   G__memvar_setup((void*)((long)(&p->djloc)-(long)(p)),102,0,0,-1,-1,-1,1,"djloc=",0,"j width of the hit ");
   G__memvar_setup((void*)((long)(&p->R)-(long)(p)),102,0,0,-1,-1,-1,1,"R=",0,"radius of the shower");
   G__memvar_setup((void*)((long)(&p->E)-(long)(p)),102,0,0,-1,-1,-1,1,"E=",0,"energy");
   }
   G__tag_memvar_reset();
}


   /* ECPO_t */
static void G__setup_memvarECPO_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECPO_t));
   { ECPO_t *p; p=(ECPO_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->UID1)-(long)(p)),105,0,0,-1,-1,-1,1,"UID1=",0,"Pointer to the U-strips 1-18 for hit");
   G__memvar_setup((void*)((long)(&p->UID2)-(long)(p)),105,0,0,-1,-1,-1,1,"UID2=",0,"Pointer to the U-strips 19-3 for hit");
   G__memvar_setup((void*)((long)(&p->VID1)-(long)(p)),105,0,0,-1,-1,-1,1,"VID1=",0,"Pointer to the V-strips 1-18 for hit");
   G__memvar_setup((void*)((long)(&p->VID2)-(long)(p)),105,0,0,-1,-1,-1,1,"VID2=",0,"Pointer to the V-strips 19-3 for hit");
   G__memvar_setup((void*)((long)(&p->WID1)-(long)(p)),105,0,0,-1,-1,-1,1,"WID1=",0,"Pointer to the W-strips 1-18 for hit ");
   G__memvar_setup((void*)((long)(&p->WID2)-(long)(p)),105,0,0,-1,-1,-1,1,"WID2=",0,"Pointer to the W-strips 19-36 for hit ");
   G__memvar_setup((void*)((long)(&p->SLH)-(long)(p)),105,0,0,-1,-1,-1,1,"SLH=",0,"Sector*1000+Layer*100+Hit");
   }
   G__tag_memvar_reset();
}


   /* ECRB_t */
static void G__setup_memvarECRB_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECRB_t));
   { ECRB_t *p; p=(ECRB_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->E_in)-(long)(p)),102,0,0,-1,-1,-1,1,"E_in=",0,"energy found for the inner layer");
   G__memvar_setup((void*)((long)(&p->E_out)-(long)(p)),102,0,0,-1,-1,-1,1,"E_out=",0,"energy found for the outer layer");
   G__memvar_setup((void*)((long)(&p->dE_in)-(long)(p)),102,0,0,-1,-1,-1,1,"dE_in=",0,"error on the energy found for the inner layer");
   G__memvar_setup((void*)((long)(&p->dE_out)-(long)(p)),102,0,0,-1,-1,-1,1,"dE_out=",0,"error on the energy found for the outer layer");
   G__memvar_setup((void*)((long)(&p->t_in)-(long)(p)),102,0,0,-1,-1,-1,1,"t_in=",0,"time found for the inner layer");
   G__memvar_setup((void*)((long)(&p->t_out)-(long)(p)),102,0,0,-1,-1,-1,1,"t_out=",0,"time found for the outer layer");
   G__memvar_setup((void*)((long)(&p->dt_in)-(long)(p)),102,0,0,-1,-1,-1,1,"dt_in=",0,"error on the time found for the inner layer");
   G__memvar_setup((void*)((long)(&p->dt_out)-(long)(p)),102,0,0,-1,-1,-1,1,"dt_out=",0,"error on the time found for the outer layer");
   G__memvar_setup((void*)((long)(&p->i_in)-(long)(p)),102,0,0,-1,-1,-1,1,"i_in=",0,"sector rectangular coordinate for the inner layer");
   G__memvar_setup((void*)((long)(&p->j_in)-(long)(p)),102,0,0,-1,-1,-1,1,"j_in=",0,"sector rectangular coordinate for the inner layer");
   G__memvar_setup((void*)((long)(&p->i_out)-(long)(p)),102,0,0,-1,-1,-1,1,"i_out=",0,"sector rectangular coordinate for the outer layer");
   G__memvar_setup((void*)((long)(&p->j_out)-(long)(p)),102,0,0,-1,-1,-1,1,"j_out=",0,"sector rectangular coordinate for the outer layer");
   G__memvar_setup((void*)((long)(&p->di_in)-(long)(p)),102,0,0,-1,-1,-1,1,"di_in=",0,"sector rectangular coordinate error, inner layer");
   G__memvar_setup((void*)((long)(&p->dj_in)-(long)(p)),102,0,0,-1,-1,-1,1,"dj_in=",0,"sector rectangular coordinate error, inner layer");
   G__memvar_setup((void*)((long)(&p->di_out)-(long)(p)),102,0,0,-1,-1,-1,1,"di_out=",0,"sector rectangular coordinate error, outer layer");
   G__memvar_setup((void*)((long)(&p->dj_out)-(long)(p)),102,0,0,-1,-1,-1,1,"dj_out=",0,"sector rectangular coordinate error, outer layer");
   G__memvar_setup((void*)((long)(&p->x_in)-(long)(p)),102,0,0,-1,-1,-1,1,"x_in=",0,"lab coordinate, inner layer");
   G__memvar_setup((void*)((long)(&p->y_in)-(long)(p)),102,0,0,-1,-1,-1,1,"y_in=",0,"lab coordinate, inner layer");
   G__memvar_setup((void*)((long)(&p->z_in)-(long)(p)),102,0,0,-1,-1,-1,1,"z_in=",0,"lab coordinate, inner layer");
   G__memvar_setup((void*)((long)(&p->x_out)-(long)(p)),102,0,0,-1,-1,-1,1,"x_out=",0,"lab coordinate, outer layer");
   G__memvar_setup((void*)((long)(&p->y_out)-(long)(p)),102,0,0,-1,-1,-1,1,"y_out=",0,"lab coordinate, outer layer");
   G__memvar_setup((void*)((long)(&p->z_out)-(long)(p)),102,0,0,-1,-1,-1,1,"z_out=",0,"lab coordinate, outer layer");
   G__memvar_setup((void*)((long)(&p->dx_in)-(long)(p)),102,0,0,-1,-1,-1,1,"dx_in=",0,"lab coordinate error, inner layer");
   G__memvar_setup((void*)((long)(&p->dy_in)-(long)(p)),102,0,0,-1,-1,-1,1,"dy_in=",0,"lab coordinate error, inner layer");
   G__memvar_setup((void*)((long)(&p->dz_in)-(long)(p)),102,0,0,-1,-1,-1,1,"dz_in=",0,"lab coordinate error, inner layer");
   G__memvar_setup((void*)((long)(&p->dx_out)-(long)(p)),102,0,0,-1,-1,-1,1,"dx_out=",0,"lab coordinate error, outer layer");
   G__memvar_setup((void*)((long)(&p->dy_out)-(long)(p)),102,0,0,-1,-1,-1,1,"dy_out=",0,"lab coordinate error, outer layer");
   G__memvar_setup((void*)((long)(&p->dz_out)-(long)(p)),102,0,0,-1,-1,-1,1,"dz_out=",0,"lab coordinate error, outer layer");
   G__memvar_setup((void*)((long)(&p->u2_in)-(long)(p)),102,0,0,-1,-1,-1,1,"u2_in=",0,"second moment of u inner hit pattern");
   G__memvar_setup((void*)((long)(&p->v2_in)-(long)(p)),102,0,0,-1,-1,-1,1,"v2_in=",0,"second moment of v inner hit pattern");
   G__memvar_setup((void*)((long)(&p->w2_in)-(long)(p)),102,0,0,-1,-1,-1,1,"w2_in=",0,"second moment of w inner hit pattern");
   G__memvar_setup((void*)((long)(&p->u2_out)-(long)(p)),102,0,0,-1,-1,-1,1,"u2_out=",0,"second moment of u outer hit pattern");
   G__memvar_setup((void*)((long)(&p->v2_out)-(long)(p)),102,0,0,-1,-1,-1,1,"v2_out=",0,"second moment of v outer hit pattern");
   G__memvar_setup((void*)((long)(&p->w2_out)-(long)(p)),102,0,0,-1,-1,-1,1,"w2_out=",0,"second moment of w outer hit pattern");
   G__memvar_setup((void*)((long)(&p->u3_in)-(long)(p)),102,0,0,-1,-1,-1,1,"u3_in=",0,"third moment of u inner hit pattern ");
   G__memvar_setup((void*)((long)(&p->v3_in)-(long)(p)),102,0,0,-1,-1,-1,1,"v3_in=",0,"third moment of v inner hit pattern ");
   G__memvar_setup((void*)((long)(&p->w3_in)-(long)(p)),102,0,0,-1,-1,-1,1,"w3_in=",0,"third moment of w inner hit pattern ");
   G__memvar_setup((void*)((long)(&p->u3_out)-(long)(p)),102,0,0,-1,-1,-1,1,"u3_out=",0,"third moment of u outer hit pattern ");
   G__memvar_setup((void*)((long)(&p->v3_out)-(long)(p)),102,0,0,-1,-1,-1,1,"v3_out=",0,"third moment of v outer hit pattern ");
   G__memvar_setup((void*)((long)(&p->w3_out)-(long)(p)),102,0,0,-1,-1,-1,1,"w3_out=",0,"third moment of w outer hit pattern ");
   G__memvar_setup((void*)((long)(&p->i2)-(long)(p)),102,0,0,-1,-1,-1,1,"i2=",0,"second moment of overall shower, sector coordinates");
   G__memvar_setup((void*)((long)(&p->j2)-(long)(p)),102,0,0,-1,-1,-1,1,"j2=",0,"second moment of overall shower, sector coordinates");
   G__memvar_setup((void*)((long)(&p->i3)-(long)(p)),102,0,0,-1,-1,-1,1,"i3=",0,"third moment of overall shower, sector coordinates");
   G__memvar_setup((void*)((long)(&p->j3)-(long)(p)),102,0,0,-1,-1,-1,1,"j3=",0,"third moment of overall shower, sector coordinates");
   G__memvar_setup((void*)((long)(&p->spare1)-(long)(p)),102,0,0,-1,-1,-1,1,"spare1=",0,"spare");
   G__memvar_setup((void*)((long)(&p->spare2)-(long)(p)),102,0,0,-1,-1,-1,1,"spare2=",0,"spare");
   G__memvar_setup((void*)((long)(&p->spare3)-(long)(p)),102,0,0,-1,-1,-1,1,"spare3=",0,"spare");
   G__memvar_setup((void*)((long)(&p->spare4)-(long)(p)),102,0,0,-1,-1,-1,1,"spare4=",0,"spare");
   G__memvar_setup((void*)((long)(&p->istat)-(long)(p)),105,0,0,-1,-1,-1,1,"istat=",0,"status word");
   }
   G__tag_memvar_reset();
}


   /* ECS_t */
static void G__setup_memvarECS_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECS_t));
   { ECS_t *p; p=(ECS_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ECS1)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS1=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->ECS2)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS2=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->ECS3)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS3=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->ECS4)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS4=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->ECS5)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS5=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->ECS6)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS6=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->ECS7)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS7=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->ECS8)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS8=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->ECS9)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS9=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->ECS10)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS10=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->ECS11)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS11=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->ECS12)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS12=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->ECS13)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS13=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->ECS14)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS14=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->ECS15)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS15=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->ECS16)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS16=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->ECS17)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS17=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->ECS18)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS18=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->ECS19)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS19=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->ECS20)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS20=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->ECS21)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS21=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->ECS22)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS22=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->ECS23)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS23=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->ECS24)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS24=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->ECS25)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS25=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->ECS26)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS26=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->ECS27)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS27=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->ECS28)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS28=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->ECS29)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS29=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->ECS30)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS30=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->ECS31)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS31=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->ECS32)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS32=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->ECS33)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS33=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->ECS34)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS34=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->ECS35)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS35=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->ECS36)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS36=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->ECS37)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS37=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->ECS38)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS38=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->ECS39)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS39=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->ECS40)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS40=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->ECS41)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS41=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->ECS42)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS42=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->ECS43)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS43=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->ECS44)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS44=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->ECS45)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS45=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->ECS46)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS46=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->ECS47)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS47=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->ECS48)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS48=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->ECS49)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS49=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->ECS50)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS50=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->ECS51)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS51=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->ECS52)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS52=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->ECS53)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS53=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->ECS54)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS54=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->ECS55)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS55=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->ECS56)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS56=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->ECS57)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS57=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->ECS58)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS58=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->ECS59)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS59=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->ECS60)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS60=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->ECS61)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS61=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->ECS62)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS62=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->ECS63)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS63=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->ECS64)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS64=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->ECS65)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS65=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->ECS66)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS66=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->ECS67)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS67=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->ECS68)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS68=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->ECS69)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS69=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->ECS70)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS70=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->ECS71)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS71=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->ECS72)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS72=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->ECS73)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS73=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->ECS74)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS74=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->ECS75)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS75=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->ECS76)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS76=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->ECS77)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS77=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->ECS78)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS78=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->ECS79)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS79=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->ECS80)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS80=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->ECS81)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS81=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->ECS82)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS82=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->ECS83)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS83=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->ECS84)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS84=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->ECS85)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS85=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->ECS86)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS86=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->ECS87)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS87=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->ECS88)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS88=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->ECS89)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS89=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->ECS90)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS90=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->ECS91)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS91=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->ECS92)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS92=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->ECS93)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS93=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->ECS94)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS94=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->ECS95)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS95=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->ECS96)-(long)(p)),105,0,0,-1,-1,-1,1,"ECS96=",0,"scaler sector 6");
   }
   G__tag_memvar_reset();
}


   /* ECT_t */
static void G__setup_memvarECT_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECT_t));
   { ECT_t *p; p=(ECT_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* EID0_t */
static void G__setup_memvarEID0_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_EID0_t));
   { EID0_t *p; p=(EID0_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->jeid0sec)-(long)(p)),105,0,0,-1,-1,-1,1,"jeid0sec=",0,"Sector # for electron candidate");
   G__memvar_setup((void*)((long)(&p->jeid0cc)-(long)(p)),105,0,0,-1,-1,-1,1,"jeid0cc=",0,"Pointer to the hit in CCRC bank");
   G__memvar_setup((void*)((long)(&p->jeid0ec)-(long)(p)),105,0,0,-1,-1,-1,1,"jeid0ec=",0,"Pointer to the hit in ECHB bank");
   G__memvar_setup((void*)((long)(&p->jeid0sc)-(long)(p)),105,0,0,-1,-1,-1,1,"jeid0sc=",0,"Pointer to the hit in SCRX bank");
   }
   G__tag_memvar_reset();
}


   /* EPIC_t */
static void G__setup_memvarEPIC_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_EPIC_t));
   { EPIC_t *p; p=(EPIC_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->value)-(long)(p)),102,0,0,-1,-1,-1,1,"value=",0,"value of the epics channel");
   G__memvar_setup((void*)((long)(&p->char1)-(long)(p)),99,0,0,-1,-1,-1,1,"char1[32]=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* EVNT_t */
static void G__setup_memvarEVNT_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_EVNT_t));
   { EVNT_t *p; p=(EVNT_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"Particle Data Group ID (from SEB) ");
   G__memvar_setup((void*)((long)(&p->Pmom)-(long)(p)),102,0,0,-1,-1,-1,1,"Pmom=",0,"momentum (from tracking)");
   G__memvar_setup((void*)((long)(&p->Mass)-(long)(p)),102,0,0,-1,-1,-1,1,"Mass=",0,"mass squared (from SEB =p**2(1.-beta**2)/beta**2) ");
   G__memvar_setup((void*)((long)(&p->Charge)-(long)(p)),105,0,0,-1,-1,-1,1,"Charge=",0,"charge (from tracking)");
   G__memvar_setup((void*)((long)(&p->Beta)-(long)(p)),102,0,0,-1,-1,-1,1,"Beta=",0,"Particle velocity in the units of c (=R_trk/TOF/c)");
   G__memvar_setup((void*)((long)(&p->cx)-(long)(p)),102,0,0,-1,-1,-1,1,"cx=",0,"x dir cosine at track origin ");
   G__memvar_setup((void*)((long)(&p->cy)-(long)(p)),102,0,0,-1,-1,-1,1,"cy=",0,"y dir cosine at track origin");
   G__memvar_setup((void*)((long)(&p->cz)-(long)(p)),102,0,0,-1,-1,-1,1,"cz=",0,"z dir cosine at track origin");
   G__memvar_setup((void*)((long)(&p->X)-(long)(p)),102,0,0,-1,-1,-1,1,"X=",0,"X coordinate of vertex (cm)");
   G__memvar_setup((void*)((long)(&p->Y)-(long)(p)),102,0,0,-1,-1,-1,1,"Y=",0,"Y coordinate of vertex (cm)");
   G__memvar_setup((void*)((long)(&p->Z)-(long)(p)),102,0,0,-1,-1,-1,1,"Z=",0,"Z coordinate of vertex (cm)");
   G__memvar_setup((void*)((long)(&p->DCstat)-(long)(p)),105,0,0,-1,-1,-1,1,"DCstat=",0,"Pointer to DCPB bank (=0 if DC is not involved) ");
   G__memvar_setup((void*)((long)(&p->CCstat)-(long)(p)),105,0,0,-1,-1,-1,1,"CCstat=",0,"Pointer to CCPB bank (=0 if CC is not involved) ");
   G__memvar_setup((void*)((long)(&p->SCstat)-(long)(p)),105,0,0,-1,-1,-1,1,"SCstat=",0,"Pointer to SCPB bank (=0 if SC is not involved)  ");
   G__memvar_setup((void*)((long)(&p->ECstat)-(long)(p)),105,0,0,-1,-1,-1,1,"ECstat=",0,"Pointer to ECPB bank (=0 if EC is not involved) ");
   G__memvar_setup((void*)((long)(&p->LCstat)-(long)(p)),105,0,0,-1,-1,-1,1,"LCstat=",0,"Pointer to LCPB bank (=0 if LAC is not involved) ");
   G__memvar_setup((void*)((long)(&p->STstat)-(long)(p)),105,0,0,-1,-1,-1,1,"STstat=",0,"Pointer to STPB bank (=0 if ST is not involved) ");
   G__memvar_setup((void*)((long)(&p->Status)-(long)(p)),105,0,0,-1,-1,-1,1,"Status=",0,"Status word (=0 out of time particle)");
   }
   G__tag_memvar_reset();
}


   /* FBPM_t */
static void G__setup_memvarFBPM_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_FBPM_t));
   { FBPM_t *p; p=(FBPM_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels)");
   G__memvar_setup((void*)((long)(&p->ADC)-(long)(p)),114,0,0,-1,-1,-1,1,"ADC=",0,"adc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* G1SL_t */
static void G__setup_memvarG1SL_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_G1SL_t));
   { G1SL_t *p; p=(G1SL_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->G1T1)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T2)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T3)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T3=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T4)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T4=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T5)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T5=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T6)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T6=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T7)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T7=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T8)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T8=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T9)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T9=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T10)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T10=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T11)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T11=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T12)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T12=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T13)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T13=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T14)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T14=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T15)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T15=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T16)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T16=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T17)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T17=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T18)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T18=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T19)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T19=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T20)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T20=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T21)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T21=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T22)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T22=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T23)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T23=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T24)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T24=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T25)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T25=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T26)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T26=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T27)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T27=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T28)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T28=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T29)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T29=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T30)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T30=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T31)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T31=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T32)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T32=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T33)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T33=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T34)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T34=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T35)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T35=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T36)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T36=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T37)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T37=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T38)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T38=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T39)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T39=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T40)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T40=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T41)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T41=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T42)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T42=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T43)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T43=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T44)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T44=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T45)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T45=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T46)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T46=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T47)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T47=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T48)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T48=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T49)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T49=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T50)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T50=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T51)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T51=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T52)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T52=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T53)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T53=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T54)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T54=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T55)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T55=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T56)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T56=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T57)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T57=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T58)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T58=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T59)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T59=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T60)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T60=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T61)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T61=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T62)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T62=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T63)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T63=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G1T64)-(long)(p)),105,0,0,-1,-1,-1,1,"G1T64=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* G2SL_t */
static void G__setup_memvarG2SL_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_G2SL_t));
   { G2SL_t *p; p=(G2SL_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->G2T1)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T2)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T3)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T3=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T4)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T4=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T5)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T5=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T6)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T6=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T7)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T7=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T8)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T8=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T9)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T9=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T10)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T10=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T11)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T11=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T12)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T12=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T13)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T13=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T14)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T14=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T15)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T15=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T16)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T16=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T17)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T17=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T18)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T18=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T19)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T19=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T20)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T20=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T21)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T21=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T22)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T22=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T23)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T23=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T24)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T24=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T25)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T25=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T26)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T26=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T27)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T27=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T28)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T28=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T29)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T29=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T30)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T30=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T31)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T31=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T32)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T32=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T33)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T33=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T34)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T34=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T35)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T35=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T36)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T36=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T37)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T37=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T38)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T38=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T39)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T39=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T40)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T40=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T41)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T41=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T42)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T42=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T43)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T43=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T44)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T44=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T45)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T45=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T46)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T46=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T47)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T47=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T48)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T48=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T49)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T49=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T50)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T50=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T51)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T51=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T52)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T52=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T53)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T53=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T54)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T54=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T55)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T55=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T56)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T56=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T57)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T57=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T58)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T58=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T59)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T59=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T60)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T60=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T61)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T61=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T62)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T62=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T63)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T63=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G2T64)-(long)(p)),105,0,0,-1,-1,-1,1,"G2T64=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* G3SL_t */
static void G__setup_memvarG3SL_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_G3SL_t));
   { G3SL_t *p; p=(G3SL_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->G3T1)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T2)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T3)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T3=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T4)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T4=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T5)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T5=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T6)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T6=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T7)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T7=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T8)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T8=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T9)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T9=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T10)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T10=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T11)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T11=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T12)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T12=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T13)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T13=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T14)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T14=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T15)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T15=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T16)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T16=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T17)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T17=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T18)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T18=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T19)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T19=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T20)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T20=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T21)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T21=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T22)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T22=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T23)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T23=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T24)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T24=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T25)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T25=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T26)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T26=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T27)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T27=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T28)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T28=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T29)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T29=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T30)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T30=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T31)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T31=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T32)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T32=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T33)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T33=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T34)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T34=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T35)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T35=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T36)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T36=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T37)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T37=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T38)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T38=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T39)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T39=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T40)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T40=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T41)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T41=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T42)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T42=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T43)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T43=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T44)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T44=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T45)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T45=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T46)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T46=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T47)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T47=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T48)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T48=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T49)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T49=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T50)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T50=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T51)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T51=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T52)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T52=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T53)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T53=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T54)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T54=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T55)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T55=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T56)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T56=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T57)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T57=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T58)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T58=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T59)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T59=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T60)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T60=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T61)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T61=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T62)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T62=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T63)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T63=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G3T64)-(long)(p)),105,0,0,-1,-1,-1,1,"G3T64=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* G4SL_t */
static void G__setup_memvarG4SL_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_G4SL_t));
   { G4SL_t *p; p=(G4SL_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->G4T1)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T2)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T3)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T3=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T4)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T4=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T5)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T5=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T6)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T6=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T7)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T7=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T8)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T8=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T9)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T9=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T10)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T10=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T11)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T11=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T12)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T12=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T13)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T13=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T14)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T14=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T15)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T15=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T16)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T16=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T17)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T17=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T18)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T18=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T19)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T19=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T20)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T20=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T21)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T21=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T22)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T22=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T23)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T23=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T24)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T24=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T25)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T25=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T26)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T26=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T27)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T27=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T28)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T28=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T29)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T29=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T30)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T30=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T31)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T31=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T32)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T32=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T33)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T33=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T34)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T34=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T35)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T35=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T36)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T36=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T37)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T37=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T38)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T38=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T39)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T39=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T40)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T40=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T41)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T41=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T42)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T42=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T43)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T43=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T44)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T44=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T45)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T45=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T46)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T46=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T47)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T47=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T48)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T48=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T49)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T49=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T50)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T50=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T51)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T51=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T52)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T52=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T53)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T53=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T54)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T54=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T55)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T55=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T56)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T56=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T57)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T57=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T58)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T58=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T59)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T59=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T60)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T60=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T61)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T61=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T62)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T62=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T63)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T63=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->G4T64)-(long)(p)),105,0,0,-1,-1,-1,1,"G4T64=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* GPAR_t */
static void G__setup_memvarGPAR_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_GPAR_t));
   { GPAR_t *p; p=(GPAR_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fval)-(long)(p)),102,0,0,-1,-1,-1,1,"fval=",0,"float value");
   G__memvar_setup((void*)((long)(&p->ival)-(long)(p)),105,0,0,-1,-1,-1,1,"ival=",0,"int value ");
   G__memvar_setup((void*)((long)(&p->char1)-(long)(p)),99,0,0,-1,-1,-1,1,"char1[20]=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* GPID_t */
static void G__setup_memvarGPID_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_GPID_t));
   { GPID_t *p; p=(GPID_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->pid)-(long)(p)),105,0,0,-1,-1,-1,1,"pid=",0,"particle id (GEANT)");
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"vector3_t vert; Vertex position {x,y,z} ");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z");
   G__memvar_setup((void*)((long)(&p->E)-(long)(p)),102,0,0,-1,-1,-1,1,"E=",0,"vector4_t p; Energy");
   G__memvar_setup((void*)((long)(&p->px)-(long)(p)),102,0,0,-1,-1,-1,1,"px=",0,"momentum {x,y,z}");
   G__memvar_setup((void*)((long)(&p->py)-(long)(p)),102,0,0,-1,-1,-1,1,"py=",0,"py");
   G__memvar_setup((void*)((long)(&p->pz)-(long)(p)),102,0,0,-1,-1,-1,1,"pz=",0,"pz");
   G__memvar_setup((void*)((long)(&p->q)-(long)(p)),105,0,0,-1,-1,-1,1,"q=",0,"charge");
   G__memvar_setup((void*)((long)(&p->trkid)-(long)(p)),105,0,0,-1,-1,-1,1,"trkid=",0,"index to TBID bank, counting from 1");
   G__memvar_setup((void*)((long)(&p->sec)-(long)(p)),105,0,0,-1,-1,-1,1,"sec=",0,"Sector track is in");
   G__memvar_setup((void*)((long)(&p->paddle)-(long)(p)),105,0,0,-1,-1,-1,1,"paddle=",0,"Paddle hit");
   G__memvar_setup((void*)((long)(&p->dedx)-(long)(p)),102,0,0,-1,-1,-1,1,"dedx=",0,"Energy deposited in TOF");
   G__memvar_setup((void*)((long)(&p->beta)-(long)(p)),102,0,0,-1,-1,-1,1,"beta=",0,"beta pmag/E");
   G__memvar_setup((void*)((long)(&p->sc_stat)-(long)(p)),105,0,0,-1,-1,-1,1,"sc_stat=",0,"status of hit matching to SC: see sc.h");
   G__memvar_setup((void*)((long)(&p->sc_time)-(long)(p)),102,0,0,-1,-1,-1,1,"sc_time=",0,"SC calibrated time for this track (ns)");
   G__memvar_setup((void*)((long)(&p->sc_len)-(long)(p)),102,0,0,-1,-1,-1,1,"sc_len=",0,"track length [cm] from origin to SC");
   G__memvar_setup((void*)((long)(&p->st_stat)-(long)(p)),105,0,0,-1,-1,-1,1,"st_stat=",0,"ST status");
   G__memvar_setup((void*)((long)(&p->st_time)-(long)(p)),102,0,0,-1,-1,-1,1,"st_time=",0,"ST calibrated time for this track (ns) ");
   G__memvar_setup((void*)((long)(&p->st_len)-(long)(p)),102,0,0,-1,-1,-1,1,"st_len=",0,"track length [cm] from origin to ST");
   G__memvar_setup((void*)((long)(&p->mass)-(long)(p)),102,0,0,-1,-1,-1,1,"mass=",0,"mass from time-of-flight");
   G__memvar_setup((void*)((long)(&p->mass_ref)-(long)(p)),105,0,0,-1,-1,-1,1,"mass_ref=",0,"0: mass calc from SC & TAG, 1: SC & ST; -1 neutral or no SC;2:from PART");
   G__memvar_setup((void*)((long)(&p->betam)-(long)(p)),102,0,0,-1,-1,-1,1,"betam=",0,"beta from time_of-flight");
   G__memvar_setup((void*)((long)(&p->epho)-(long)(p)),102,0,0,-1,-1,-1,1,"epho=",0,"closest photon energy (GeV)");
   G__memvar_setup((void*)((long)(&p->tpho)-(long)(p)),102,0,0,-1,-1,-1,1,"tpho=",0,"Time of the photon after RF correction");
   G__memvar_setup((void*)((long)(&p->tagrid)-(long)(p)),105,0,0,-1,-1,-1,1,"tagrid=",0,"index to TAGR bank, counting from 1");
   G__memvar_setup((void*)((long)(&p->ngrf)-(long)(p)),105,0,0,-1,-1,-1,1,"ngrf=",0,"number of photons in the same RF bucket");
   G__memvar_setup((void*)((long)(&p->ppid)-(long)(p)),105,0,0,-1,-1,-1,1,"ppid=",0,"pid as seen in PART bank");
   }
   G__tag_memvar_reset();
}


   /* GP_X_t */
static void G__setup_memvarGP_X_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_GP_X_t));
   { GP_X_t *p; p=(GP_X_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->value)-(long)(p)),102,0,0,-1,-1,-1,1,"value=",0,"count rate per channel");
   }
   G__tag_memvar_reset();
}


   /* GP_Y_t */
static void G__setup_memvarGP_Y_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_GP_Y_t));
   { GP_Y_t *p; p=(GP_Y_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->value)-(long)(p)),102,0,0,-1,-1,-1,1,"value=",0,"count rate per channel");
   }
   G__tag_memvar_reset();
}


   /* HBER_t */
static void G__setup_memvarHBER_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HBER_t));
   { HBER_t *p; p=(HBER_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->q_over_p)-(long)(p)),102,0,0,-1,-1,-1,1,"q_over_p=",0,"q/p");
   G__memvar_setup((void*)((long)(&p->lambda)-(long)(p)),102,0,0,-1,-1,-1,1,"lambda=",0,"dip angle (pi/2 - theta)");
   G__memvar_setup((void*)((long)(&p->phi)-(long)(p)),102,0,0,-1,-1,-1,1,"phi=",0,"phi");
   G__memvar_setup((void*)((long)(&p->d0)-(long)(p)),102,0,0,-1,-1,-1,1,"d0=",0,"min.distance from (x=0,y=0,z=?)   [cm]");
   G__memvar_setup((void*)((long)(&p->z0)-(long)(p)),102,0,0,-1,-1,-1,1,"z0=",0,"z position of starting point  [cm]");
   G__memvar_setup((void*)((long)(&p->c11)-(long)(p)),102,0,0,-1,-1,-1,1,"c11=",0,"element C{1,1}");
   G__memvar_setup((void*)((long)(&p->c12)-(long)(p)),102,0,0,-1,-1,-1,1,"c12=",0,"element C{1,2}");
   G__memvar_setup((void*)((long)(&p->c13)-(long)(p)),102,0,0,-1,-1,-1,1,"c13=",0,"element C{1,3}");
   G__memvar_setup((void*)((long)(&p->c14)-(long)(p)),102,0,0,-1,-1,-1,1,"c14=",0,"element C{1,4}");
   G__memvar_setup((void*)((long)(&p->c15)-(long)(p)),102,0,0,-1,-1,-1,1,"c15=",0,"element C{1,5}");
   G__memvar_setup((void*)((long)(&p->c22)-(long)(p)),102,0,0,-1,-1,-1,1,"c22=",0,"element C{2,2}");
   G__memvar_setup((void*)((long)(&p->c23)-(long)(p)),102,0,0,-1,-1,-1,1,"c23=",0,"element C{2,3}");
   G__memvar_setup((void*)((long)(&p->c24)-(long)(p)),102,0,0,-1,-1,-1,1,"c24=",0,"element C{2,4}");
   G__memvar_setup((void*)((long)(&p->c25)-(long)(p)),102,0,0,-1,-1,-1,1,"c25=",0,"element C{2,5}");
   G__memvar_setup((void*)((long)(&p->c33)-(long)(p)),102,0,0,-1,-1,-1,1,"c33=",0,"element C{3,3}");
   G__memvar_setup((void*)((long)(&p->c34)-(long)(p)),102,0,0,-1,-1,-1,1,"c34=",0,"element C{3,4}");
   G__memvar_setup((void*)((long)(&p->c35)-(long)(p)),102,0,0,-1,-1,-1,1,"c35=",0,"element C{3,5}");
   G__memvar_setup((void*)((long)(&p->c44)-(long)(p)),102,0,0,-1,-1,-1,1,"c44=",0,"element C{4,4}");
   G__memvar_setup((void*)((long)(&p->c45)-(long)(p)),102,0,0,-1,-1,-1,1,"c45=",0,"element C{4,5}");
   G__memvar_setup((void*)((long)(&p->c55)-(long)(p)),102,0,0,-1,-1,-1,1,"c55=",0,"element C{5,5}");
   G__memvar_setup((void*)((long)(&p->chi2)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2=",0,"Chisquare for this Track");
   G__memvar_setup((void*)((long)(&p->layinfo1)-(long)(p)),105,0,0,-1,-1,-1,1,"layinfo1=",0,"layerhit info");
   G__memvar_setup((void*)((long)(&p->layinfo2)-(long)(p)),105,0,0,-1,-1,-1,1,"layinfo2=",0,"layerhit info&sector&track#in sector");
   }
   G__tag_memvar_reset();
}


   /* HBID_t */
static void G__setup_memvarHBID_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HBID_t));
   { HBID_t *p; p=(HBID_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->track)-(long)(p)),105,0,0,-1,-1,-1,1,"track=",0,"Track Candidate (ptr to HBTR)");
   G__memvar_setup((void*)((long)(&p->sec)-(long)(p)),105,0,0,-1,-1,-1,1,"sec=",0,"Sector track is in");
   G__memvar_setup((void*)((long)(&p->beta)-(long)(p)),102,0,0,-1,-1,-1,1,"beta=",0,"Beta of the track in units of c");
   G__memvar_setup((void*)((long)(&p->vtime)-(long)(p)),102,0,0,-1,-1,-1,1,"vtime=",0,"vertex time of track");
   G__memvar_setup((void*)((long)(&p->sc_stat)-(long)(p)),105,0,0,-1,-1,-1,1,"sc_stat=",0,"status of hit matching to SC: see sc.h");
   G__memvar_setup((void*)((long)(&p->sc_id)-(long)(p)),105,0,0,-1,-1,-1,1,"sc_id=",0,"Pointer to SCRC bank");
   G__memvar_setup((void*)((long)(&p->sc_time)-(long)(p)),102,0,0,-1,-1,-1,1,"sc_time=",0,"SC calibrated time for this track (ns)");
   G__memvar_setup((void*)((long)(&p->sc_qual)-(long)(p)),102,0,0,-1,-1,-1,1,"sc_qual=",0,"quality of match for SC");
   G__memvar_setup((void*)((long)(&p->sc_vtime)-(long)(p)),102,0,0,-1,-1,-1,1,"sc_vtime=",0,"time at vertex for SC(ns)");
   G__memvar_setup((void*)((long)(&p->sc_beta)-(long)(p)),102,0,0,-1,-1,-1,1,"sc_beta=",0,"Beta calculated from TOF from SC");
   G__memvar_setup((void*)((long)(&p->cc_stat)-(long)(p)),105,0,0,-1,-1,-1,1,"cc_stat=",0,"status of hit matching to CC: see sc.h");
   G__memvar_setup((void*)((long)(&p->cc_id)-(long)(p)),105,0,0,-1,-1,-1,1,"cc_id=",0,"pointer to CC01 bank");
   G__memvar_setup((void*)((long)(&p->cc_time)-(long)(p)),102,0,0,-1,-1,-1,1,"cc_time=",0,"CC calibrated time for this track (ns)");
   G__memvar_setup((void*)((long)(&p->cc_qual)-(long)(p)),102,0,0,-1,-1,-1,1,"cc_qual=",0,"quality of match for CC");
   G__memvar_setup((void*)((long)(&p->cc_vtime)-(long)(p)),102,0,0,-1,-1,-1,1,"cc_vtime=",0,"time at vertex for CC(ns)");
   G__memvar_setup((void*)((long)(&p->cc_beta)-(long)(p)),102,0,0,-1,-1,-1,1,"cc_beta=",0,"Beta as calculated by the EC");
   G__memvar_setup((void*)((long)(&p->ec_stat)-(long)(p)),105,0,0,-1,-1,-1,1,"ec_stat=",0,"status of hit matching to ec: see sc.h");
   G__memvar_setup((void*)((long)(&p->ec_id)-(long)(p)),105,0,0,-1,-1,-1,1,"ec_id=",0,"Pointer to ECHB bank");
   G__memvar_setup((void*)((long)(&p->ec_time)-(long)(p)),102,0,0,-1,-1,-1,1,"ec_time=",0,"EC calibrated time for this track (ns)");
   G__memvar_setup((void*)((long)(&p->ec_qual)-(long)(p)),102,0,0,-1,-1,-1,1,"ec_qual=",0,"EC quality factor");
   G__memvar_setup((void*)((long)(&p->ec_vtime)-(long)(p)),102,0,0,-1,-1,-1,1,"ec_vtime=",0,"time at vertex for EC(ns)");
   G__memvar_setup((void*)((long)(&p->ec_beta)-(long)(p)),102,0,0,-1,-1,-1,1,"ec_beta=",0,"Beta as calculated by the EC");
   G__memvar_setup((void*)((long)(&p->st_stat)-(long)(p)),105,0,0,-1,-1,-1,1,"st_stat=",0,"status of hit matching to ST");
   G__memvar_setup((void*)((long)(&p->st_id)-(long)(p)),105,0,0,-1,-1,-1,1,"st_id=",0,"Pointer to STR bank");
   G__memvar_setup((void*)((long)(&p->st_time)-(long)(p)),102,0,0,-1,-1,-1,1,"st_time=",0,"ST calibrated time for this track (ns)");
   G__memvar_setup((void*)((long)(&p->st_qual)-(long)(p)),102,0,0,-1,-1,-1,1,"st_qual=",0,"ST quality factor");
   G__memvar_setup((void*)((long)(&p->st_vtime)-(long)(p)),102,0,0,-1,-1,-1,1,"st_vtime=",0,"time at vertex for ST(ns)");
   G__memvar_setup((void*)((long)(&p->st_beta)-(long)(p)),102,0,0,-1,-1,-1,1,"st_beta=",0,"Beta as calculated by the ST");
   G__memvar_setup((void*)((long)(&p->lac_stat)-(long)(p)),105,0,0,-1,-1,-1,1,"lac_stat=",0,"status of hit matching to LAC");
   G__memvar_setup((void*)((long)(&p->lac_id)-(long)(p)),105,0,0,-1,-1,-1,1,"lac_id=",0,"Pointer to EC1R bank");
   G__memvar_setup((void*)((long)(&p->lac_time)-(long)(p)),102,0,0,-1,-1,-1,1,"lac_time=",0,"LAC calibrated time for this track (ns)");
   G__memvar_setup((void*)((long)(&p->lac_qual)-(long)(p)),102,0,0,-1,-1,-1,1,"lac_qual=",0,"LAC quality factor");
   G__memvar_setup((void*)((long)(&p->lac_vtime)-(long)(p)),102,0,0,-1,-1,-1,1,"lac_vtime=",0,"time at vertex for LAC(ns)");
   G__memvar_setup((void*)((long)(&p->lac_beta)-(long)(p)),102,0,0,-1,-1,-1,1,"lac_beta=",0,"Beta as calculated by the LAC");
   }
   G__tag_memvar_reset();
}


   /* HBLA_t */
static void G__setup_memvarHBLA_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HBLA_t));
   { HBLA_t *p; p=(HBLA_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->trk_pln)-(long)(p)),105,0,0,-1,-1,-1,1,"trk_pln=",0,"(track_number) *100 + Trk_plane_number");
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"z coord [cm]  for track in this plane");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y coord [cm]  for track in this plane");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z coord [cm]  for track in this plane");
   G__memvar_setup((void*)((long)(&p->Bx)-(long)(p)),102,0,0,-1,-1,-1,1,"Bx=",0,"B-field in x [kG] at coord.{x,y,z}");
   G__memvar_setup((void*)((long)(&p->By)-(long)(p)),102,0,0,-1,-1,-1,1,"By=",0,"B-field in y [kG] at coord.{x,y,z}");
   G__memvar_setup((void*)((long)(&p->Bz)-(long)(p)),102,0,0,-1,-1,-1,1,"Bz=",0,"B-field in z [kG] at coord.{x,y,z}");
   G__memvar_setup((void*)((long)(&p->tlen)-(long)(p)),102,0,0,-1,-1,-1,1,"tlen=",0,"track length [cm] from origin to this plane");
   G__memvar_setup((void*)((long)(&p->dc1)-(long)(p)),105,0,0,-1,-1,-1,1,"dc1=",0,"Pointer to DC1 bank");
   G__memvar_setup((void*)((long)(&p->stat)-(long)(p)),105,0,0,-1,-1,-1,1,"stat=",0,"Status of the hit");
   G__memvar_setup((void*)((long)(&p->wire)-(long)(p)),105,0,0,-1,-1,-1,1,"wire=",0,"Wire number ");
   G__memvar_setup((void*)((long)(&p->dtime)-(long)(p)),102,0,0,-1,-1,-1,1,"dtime=",0,"drift time [ns]  (not corrected for start ime)");
   G__memvar_setup((void*)((long)(&p->alpha)-(long)(p)),102,0,0,-1,-1,-1,1,"alpha=",0,"track angle (relative to R of SL) [deg]");
   G__memvar_setup((void*)((long)(&p->wlen)-(long)(p)),102,0,0,-1,-1,-1,1,"wlen=",0,"Wire length (hit pos. to preamp)  [cm]");
   G__memvar_setup((void*)((long)(&p->sgdoca)-(long)(p)),102,0,0,-1,-1,-1,1,"sgdoca=",0,"sigma DOCA");
   G__memvar_setup((void*)((long)(&p->fitdoca)-(long)(p)),102,0,0,-1,-1,-1,1,"fitdoca=",0,"Fitted DOCA");
   }
   G__tag_memvar_reset();
}


   /* HBTB_t */
static void G__setup_memvarHBTB_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HBTB_t));
   { HBTB_t *p; p=(HBTB_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->trk)-(long)(p)),105,0,0,-1,-1,-1,1,"trk=",0,"Track Candidate ");
   G__memvar_setup((void*)((long)(&p->sly)-(long)(p)),105,0,0,-1,-1,-1,1,"sly=",0,"Superlayer");
   G__memvar_setup((void*)((long)(&p->icl)-(long)(p)),105,0,0,-1,-1,-1,1,"icl=",0,"Cluster# that matched to the track");
   G__memvar_setup((void*)((long)(&p->isg)-(long)(p)),105,0,0,-1,-1,-1,1,"isg=",0,"Segment# in this cluster");
   G__memvar_setup((void*)((long)(&p->id1)-(long)(p)),105,0,0,-1,-1,-1,1,"id1=",0,"Ptr. to DC1 entry  for 1.Layer in SL");
   G__memvar_setup((void*)((long)(&p->id2)-(long)(p)),105,0,0,-1,-1,-1,1,"id2=",0,"Ptr. to DC1 entry  for 2.Layer in SL");
   G__memvar_setup((void*)((long)(&p->id3)-(long)(p)),105,0,0,-1,-1,-1,1,"id3=",0,"Ptr. to DC1 entry  for 3.Layer in SL");
   G__memvar_setup((void*)((long)(&p->id4)-(long)(p)),105,0,0,-1,-1,-1,1,"id4=",0,"Ptr. to DC1 entry  for 4.Layer in SL");
   G__memvar_setup((void*)((long)(&p->id5)-(long)(p)),105,0,0,-1,-1,-1,1,"id5=",0,"Ptr. to DC1 entry  for 5.Layer in SL");
   G__memvar_setup((void*)((long)(&p->id6)-(long)(p)),105,0,0,-1,-1,-1,1,"id6=",0,"Ptr. to DC1 entry  for 6.Layer in SL");
   }
   G__tag_memvar_reset();
}


   /* HBTR_t */
static void G__setup_memvarHBTR_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HBTR_t));
   { HBTR_t *p; p=(HBTR_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"x");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y 'Vertex' position {x,y,z}");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z");
   G__memvar_setup((void*)((long)(&p->px)-(long)(p)),102,0,0,-1,-1,-1,1,"px=",0,"Px");
   G__memvar_setup((void*)((long)(&p->py)-(long)(p)),102,0,0,-1,-1,-1,1,"py=",0,"Py  momentum at 'vertex' {Px,Py,Pz}");
   G__memvar_setup((void*)((long)(&p->pz)-(long)(p)),102,0,0,-1,-1,-1,1,"pz=",0,"Pz");
   G__memvar_setup((void*)((long)(&p->q)-(long)(p)),102,0,0,-1,-1,-1,1,"q=",0,"charge   (straight tracks: set q=0.)");
   G__memvar_setup((void*)((long)(&p->chi2)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2=",0,"Chisquare for this Track");
   G__memvar_setup((void*)((long)(&p->itr_sec)-(long)(p)),105,0,0,-1,-1,-1,1,"itr_sec=",0,"Trackno_in_Sector + Sector*100");
   }
   G__tag_memvar_reset();
}


   /* HCAL_t */
static void G__setup_memvarHCAL_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HCAL_t));
   { HCAL_t *p; p=(HCAL_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->VERSION)-(long)(p)),105,0,0,-1,-1,-1,1,"VERSION=",0,"Version number");
   G__memvar_setup((void*)((long)(&p->RUN_LOW)-(long)(p)),105,0,0,-1,-1,-1,1,"RUN_LOW=",0,"LOW RUN number		 ");
   G__memvar_setup((void*)((long)(&p->RUN_HIGH)-(long)(p)),105,0,0,-1,-1,-1,1,"RUN_HIGH=",0,"HIGH RUN number");
   G__memvar_setup((void*)((long)(&p->CATIME)-(long)(p)),105,0,0,-1,-1,-1,1,"CATIME=",0,"CAlibration TIME (unix time = 0 1/1/1970)		");
   G__memvar_setup((void*)((long)(&p->ROCCA)-(long)(p)),105,0,0,-1,-1,-1,1,"ROCCA=",0,"32 bit ReadOut Controller CAlibration status");
   }
   G__tag_memvar_reset();
}


   /* HDPL_t */
static void G__setup_memvarHDPL_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HDPL_t));
   { HDPL_t *p; p=(HDPL_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->trk_pln)-(long)(p)),105,0,0,-1,-1,-1,1,"trk_pln=",0,"(track_number) *100 + plane_number");
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"vector3_t pos;");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"(x, y, z coord. for track in on the plane)");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cx)-(long)(p)),102,0,0,-1,-1,-1,1,"cx=",0,"vector3_t dir;");
   G__memvar_setup((void*)((long)(&p->cy)-(long)(p)),102,0,0,-1,-1,-1,1,"cy=",0,"direction cosines (x,y,z) for track at coord.{x,y,z}");
   G__memvar_setup((void*)((long)(&p->cz)-(long)(p)),102,0,0,-1,-1,-1,1,"cz=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->tlen)-(long)(p)),102,0,0,-1,-1,-1,1,"tlen=",0,"track length [cm] from origin to this plane");
   }
   G__tag_memvar_reset();
}


   /* HEAD_t */
static void G__setup_memvarHEAD_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HEAD_t));
   { HEAD_t *p; p=(HEAD_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->VERSION)-(long)(p)),105,0,0,-1,-1,-1,1,"VERSION=",0,"Version Number");
   G__memvar_setup((void*)((long)(&p->NRUN)-(long)(p)),105,0,0,-1,-1,-1,1,"NRUN=",0,"Run Number (monotonically increasing)");
   G__memvar_setup((void*)((long)(&p->NEVENT)-(long)(p)),105,0,0,-1,-1,-1,1,"NEVENT=",0,"Event Number (starting with 1 at run begin,");
   G__memvar_setup((void*)((long)(&p->TIME)-(long)(p)),105,0,0,-1,-1,-1,1,"TIME=",0,"Event Time (UNIX time = seconds as of January 1,1970)");
   G__memvar_setup((void*)((long)(&p->TYPE)-(long)(p)),105,0,0,-1,-1,-1,1,"TYPE=",0,"Event Type (Defined by on-line system or MC run:");
   G__memvar_setup((void*)((long)(&p->ROC)-(long)(p)),105,0,0,-1,-1,-1,1,"ROC=",0,"= 0        - sync status is OK");
   G__memvar_setup((void*)((long)(&p->EVTCLASS)-(long)(p)),105,0,0,-1,-1,-1,1,"EVTCLASS=",0,"Event Classification from DAQ:");
   G__memvar_setup((void*)((long)(&p->TRIGBITS)-(long)(p)),105,0,0,-1,-1,-1,1,"TRIGBITS=",0,"Level 1 Trigger Latch Word (16 bits)");
   }
   G__tag_memvar_reset();
}


   /* HEVT_t */
static void G__setup_memvarHEVT_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HEVT_t));
   { HEVT_t *p; p=(HEVT_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ESTATUS)-(long)(p)),105,0,0,-1,-1,-1,1,"ESTATUS=",0,"Event Statuse after reconstruction");
   G__memvar_setup((void*)((long)(&p->NRUN)-(long)(p)),105,0,0,-1,-1,-1,1,"NRUN=",0,"Run Number (monotonically increasing)");
   G__memvar_setup((void*)((long)(&p->NEVENT)-(long)(p)),105,0,0,-1,-1,-1,1,"NEVENT=",0,"Event Number in the run NRUN ");
   G__memvar_setup((void*)((long)(&p->TYPE)-(long)(p)),105,0,0,-1,-1,-1,1,"TYPE=",0,"Event Type (Data or MC)");
   G__memvar_setup((void*)((long)(&p->NPGP)-(long)(p)),105,0,0,-1,-1,-1,1,"NPGP=",0,"Number of final reconstructed particles*100 +");
   G__memvar_setup((void*)((long)(&p->TRGPRS)-(long)(p)),105,0,0,-1,-1,-1,1,"TRGPRS=",0,"Trigger type*10000 + ");
   G__memvar_setup((void*)((long)(&p->FC)-(long)(p)),102,0,0,-1,-1,-1,1,"FC=",0,"Faraday Cup (K)");
   G__memvar_setup((void*)((long)(&p->FCG)-(long)(p)),102,0,0,-1,-1,-1,1,"FCG=",0,"Faraday Cup Gated (K)");
   G__memvar_setup((void*)((long)(&p->TG)-(long)(p)),102,0,0,-1,-1,-1,1,"TG=",0,"Clock Gated");
   G__memvar_setup((void*)((long)(&p->STT)-(long)(p)),102,0,0,-1,-1,-1,1,"STT=",0,"Event Start Time ");
   G__memvar_setup((void*)((long)(&p->RF1)-(long)(p)),102,0,0,-1,-1,-1,1,"RF1=",0,"RF Time ");
   G__memvar_setup((void*)((long)(&p->RF2)-(long)(p)),102,0,0,-1,-1,-1,1,"RF2=",0,"RF Time");
   G__memvar_setup((void*)((long)(&p->CON1)-(long)(p)),102,0,0,-1,-1,-1,1,"CON1=",0,"Control Rates ");
   G__memvar_setup((void*)((long)(&p->CON2)-(long)(p)),102,0,0,-1,-1,-1,1,"CON2=",0,"Control Rates  ");
   G__memvar_setup((void*)((long)(&p->CON3)-(long)(p)),102,0,0,-1,-1,-1,1,"CON3=",0,"Control Rates ");
   G__memvar_setup((void*)((long)(&p->PTIME)-(long)(p)),105,0,0,-1,-1,-1,1,"PTIME=",0,"Event Processing Time (UNIX time = seconds)");
   }
   G__tag_memvar_reset();
}


   /* HLS_t */
static void G__setup_memvarHLS_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HLS_t));
   { HLS_t *p; p=(HLS_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->S1)-(long)(p)),104,0,0,-1,-1,-1,1,"S1=",0,"10MHz clock");
   G__memvar_setup((void*)((long)(&p->S2)-(long)(p)),104,0,0,-1,-1,-1,1,"S2=",0,"OTR-1");
   G__memvar_setup((void*)((long)(&p->S3)-(long)(p)),104,0,0,-1,-1,-1,1,"S3=",0,"OTR-2");
   G__memvar_setup((void*)((long)(&p->S4)-(long)(p)),104,0,0,-1,-1,-1,1,"S4=",0,"SLM");
   G__memvar_setup((void*)((long)(&p->S5)-(long)(p)),104,0,0,-1,-1,-1,1,"S5=",0,"lvl-1 trigger rate");
   G__memvar_setup((void*)((long)(&p->S6)-(long)(p)),104,0,0,-1,-1,-1,1,"S6=",0,"L.R Moller coincidences");
   G__memvar_setup((void*)((long)(&p->S7)-(long)(p)),104,0,0,-1,-1,-1,1,"S7=",0,"L.R Moller accidentals");
   G__memvar_setup((void*)((long)(&p->S8)-(long)(p)),104,0,0,-1,-1,-1,1,"S8=",0,"F-CUP");
   G__memvar_setup((void*)((long)(&p->S9)-(long)(p)),104,0,0,-1,-1,-1,1,"S9=",0,"pmt-1");
   G__memvar_setup((void*)((long)(&p->S10)-(long)(p)),104,0,0,-1,-1,-1,1,"S10=",0,"pmt-2");
   G__memvar_setup((void*)((long)(&p->S11)-(long)(p)),104,0,0,-1,-1,-1,1,"S11=",0,"pmt-3");
   G__memvar_setup((void*)((long)(&p->S12)-(long)(p)),104,0,0,-1,-1,-1,1,"S12=",0,"pmt-4");
   G__memvar_setup((void*)((long)(&p->S13)-(long)(p)),104,0,0,-1,-1,-1,1,"S13=",0,"reserve");
   G__memvar_setup((void*)((long)(&p->S14)-(long)(p)),104,0,0,-1,-1,-1,1,"S14=",0,"reserve");
   G__memvar_setup((void*)((long)(&p->S15)-(long)(p)),104,0,0,-1,-1,-1,1,"S15=",0,"Helicity states accumulating counter");
   G__memvar_setup((void*)((long)(&p->S16)-(long)(p)),104,0,0,-1,-1,-1,1,"S16=",0,"HLS banks accumulating counter");
   }
   G__tag_memvar_reset();
}


   /* IC_t */
static void G__setup_memvarIC_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_IC_t));
   { IC_t *p; p=(IC_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels)");
   G__memvar_setup((void*)((long)(&p->ADC)-(long)(p)),114,0,0,-1,-1,-1,1,"ADC=",0,"adc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* ICHB_t */
static void G__setup_memvarICHB_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ICHB_t));
   { ICHB_t *p; p=(ICHB_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->Eclust)-(long)(p)),102,0,0,-1,-1,-1,1,"Eclust=",0,"Cluster energy ");
   G__memvar_setup((void*)((long)(&p->Eclmax)-(long)(p)),102,0,0,-1,-1,-1,1,"Eclmax=",0,"Max energy in a crystal of the cluster ");
   G__memvar_setup((void*)((long)(&p->Tclust)-(long)(p)),102,0,0,-1,-1,-1,1,"Tclust=",0,"Reconstructed cluster time");
   G__memvar_setup((void*)((long)(&p->Tclmax)-(long)(p)),102,0,0,-1,-1,-1,1,"Tclmax=",0,"Time in a crystal with Max enrgy");
   G__memvar_setup((void*)((long)(&p->xclust)-(long)(p)),102,0,0,-1,-1,-1,1,"xclust=",0,"lab coordinate X,");
   G__memvar_setup((void*)((long)(&p->yclust)-(long)(p)),102,0,0,-1,-1,-1,1,"yclust=",0,"lab coordinate Y,");
   G__memvar_setup((void*)((long)(&p->zclust)-(long)(p)),102,0,0,-1,-1,-1,1,"zclust=",0,"lab coordinate Z,");
   G__memvar_setup((void*)((long)(&p->xclmax)-(long)(p)),102,0,0,-1,-1,-1,1,"xclmax=",0,"lab coordinate X,");
   G__memvar_setup((void*)((long)(&p->yclmax)-(long)(p)),102,0,0,-1,-1,-1,1,"yclmax=",0,"lab coordinate Y,");
   G__memvar_setup((void*)((long)(&p->zclmax)-(long)(p)),102,0,0,-1,-1,-1,1,"zclmax=",0,"lab coordinate Z,");
   G__memvar_setup((void*)((long)(&p->res1)-(long)(p)),102,0,0,-1,-1,-1,1,"res1=",0,"lab coordinate error,");
   G__memvar_setup((void*)((long)(&p->res2)-(long)(p)),102,0,0,-1,-1,-1,1,"res2=",0,"lab coordinate error,");
   G__memvar_setup((void*)((long)(&p->res3)-(long)(p)),102,0,0,-1,-1,-1,1,"res3=",0,"lab coordinate error,");
   G__memvar_setup((void*)((long)(&p->ncryst)-(long)(p)),105,0,0,-1,-1,-1,1,"ncryst=",0,"Number of crystal in the cluster");
   }
   G__tag_memvar_reset();
}


   /* KFIT_t */
static void G__setup_memvarKFIT_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_KFIT_t));
   { KFIT_t *p; p=(KFIT_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->momenta_f)-(long)(p)),102,0,0,-1,-1,-1,1,"momenta_f=",0,"fitted momentum parameter (GeV)   ");
   G__memvar_setup((void*)((long)(&p->lambda_f)-(long)(p)),102,0,0,-1,-1,-1,1,"lambda_f=",0,"fitted dip angle (radians) ");
   G__memvar_setup((void*)((long)(&p->phi_f)-(long)(p)),102,0,0,-1,-1,-1,1,"phi_f=",0,"fitted phi angle (radians)");
   G__memvar_setup((void*)((long)(&p->d0_f)-(long)(p)),102,0,0,-1,-1,-1,1,"d0_f=",0,"fitted d0 (cm)");
   G__memvar_setup((void*)((long)(&p->z0_f)-(long)(p)),102,0,0,-1,-1,-1,1,"z0_f=",0,"fitted z0 (cm)");
   G__memvar_setup((void*)((long)(&p->sigma11)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma11=",0,"error element of known");
   G__memvar_setup((void*)((long)(&p->sigma12)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma12=",0,"error element of known");
   G__memvar_setup((void*)((long)(&p->sigma13)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma13=",0,"error element of known");
   G__memvar_setup((void*)((long)(&p->sigma14)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma14=",0,"error element of known");
   G__memvar_setup((void*)((long)(&p->sigma15)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma15=",0,"error element of known");
   G__memvar_setup((void*)((long)(&p->sigma22)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma22=",0,"error element of known   ");
   G__memvar_setup((void*)((long)(&p->sigma23)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma23=",0,"error element of known");
   G__memvar_setup((void*)((long)(&p->sigma24)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma24=",0,"error element of known");
   G__memvar_setup((void*)((long)(&p->sigma25)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma25=",0,"error element of known");
   G__memvar_setup((void*)((long)(&p->sigma33)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma33=",0,"error element of known ");
   G__memvar_setup((void*)((long)(&p->sigma34)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma34=",0,"error element of known ");
   G__memvar_setup((void*)((long)(&p->sigma35)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma35=",0,"error element of known ");
   G__memvar_setup((void*)((long)(&p->sigma44)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma44=",0,"error element of known ");
   G__memvar_setup((void*)((long)(&p->sigma45)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma45=",0,"error element of known ");
   G__memvar_setup((void*)((long)(&p->sigma55)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma55=",0,"error element of known ");
   G__memvar_setup((void*)((long)(&p->cov11)-(long)(p)),102,0,0,-1,-1,-1,1,"cov11=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov12)-(long)(p)),102,0,0,-1,-1,-1,1,"cov12=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov13)-(long)(p)),102,0,0,-1,-1,-1,1,"cov13=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov14)-(long)(p)),102,0,0,-1,-1,-1,1,"cov14=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov15)-(long)(p)),102,0,0,-1,-1,-1,1,"cov15=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov21)-(long)(p)),102,0,0,-1,-1,-1,1,"cov21=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov22)-(long)(p)),102,0,0,-1,-1,-1,1,"cov22=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov23)-(long)(p)),102,0,0,-1,-1,-1,1,"cov23=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov24)-(long)(p)),102,0,0,-1,-1,-1,1,"cov24=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov25)-(long)(p)),102,0,0,-1,-1,-1,1,"cov25=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov31)-(long)(p)),102,0,0,-1,-1,-1,1,"cov31=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov32)-(long)(p)),102,0,0,-1,-1,-1,1,"cov32=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov33)-(long)(p)),102,0,0,-1,-1,-1,1,"cov33=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov34)-(long)(p)),102,0,0,-1,-1,-1,1,"cov34=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov35)-(long)(p)),102,0,0,-1,-1,-1,1,"cov35=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov41)-(long)(p)),102,0,0,-1,-1,-1,1,"cov41=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov42)-(long)(p)),102,0,0,-1,-1,-1,1,"cov42=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov43)-(long)(p)),102,0,0,-1,-1,-1,1,"cov43=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov44)-(long)(p)),102,0,0,-1,-1,-1,1,"cov44=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov45)-(long)(p)),102,0,0,-1,-1,-1,1,"cov45=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov51)-(long)(p)),102,0,0,-1,-1,-1,1,"cov51=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov52)-(long)(p)),102,0,0,-1,-1,-1,1,"cov52=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov53)-(long)(p)),102,0,0,-1,-1,-1,1,"cov53=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov54)-(long)(p)),102,0,0,-1,-1,-1,1,"cov54=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->cov55)-(long)(p)),102,0,0,-1,-1,-1,1,"cov55=",0,"error element bewteen known and unknown");
   G__memvar_setup((void*)((long)(&p->chi2piece)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2piece=",0,"track contribution to chi2");
   }
   G__tag_memvar_reset();
}


   /* L1PG_t */
static void G__setup_memvarL1PG_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_L1PG_t));
   { L1PG_t *p; p=(L1PG_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->l1prog)-(long)(p)),99,0,0,-1,-1,-1,1,"l1prog[4]=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* L2H_t */
static void G__setup_memvarL2H_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_L2H_t));
   { L2H_t *p; p=(L2H_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"Superlayer + 256*(hit# in TDC)");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* L2S_t */
static void G__setup_memvarL2S_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_L2S_t));
   { L2S_t *p; p=(L2S_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"ID+256*hit#");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"TDC value");
   }
   G__tag_memvar_reset();
}


   /* LASR_t */
static void G__setup_memvarLASR_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_LASR_t));
   { LASR_t *p; p=(LASR_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"identifier  0-1099  TOF 1100-10000 EC laser  ");
   G__memvar_setup((void*)((long)(&p->stat1)-(long)(p)),105,0,0,-1,-1,-1,1,"stat1=",0,"status words different for each id");
   G__memvar_setup((void*)((long)(&p->stat2)-(long)(p)),105,0,0,-1,-1,-1,1,"stat2=",0,"\"");
   G__memvar_setup((void*)((long)(&p->stat3)-(long)(p)),105,0,0,-1,-1,-1,1,"stat3=",0,"\"");
   }
   G__tag_memvar_reset();
}


   /* LCDI_t */
static void G__setup_memvarLCDI_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_LCDI_t));
   { LCDI_t *p; p=(LCDI_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->crate)-(long)(p)),105,0,0,-1,-1,-1,1,"crate=",0,"CAMAC crate number");
   G__memvar_setup((void*)((long)(&p->slot)-(long)(p)),105,0,0,-1,-1,-1,1,"slot=",0,"slot");
   G__memvar_setup((void*)((long)(&p->mask)-(long)(p)),105,0,0,-1,-1,-1,1,"mask=",0,"mask");
   G__memvar_setup((void*)((long)(&p->threshold)-(long)(p)),105,0,0,-1,-1,-1,1,"threshold=",0,"actual threshold value (mV)");
   }
   G__tag_memvar_reset();
}


   /* LCPB_t */
static void G__setup_memvarLCPB_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_LCPB_t));
   { LCPB_t *p; p=(LCPB_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ScHt)-(long)(p)),105,0,0,-1,-1,-1,1,"ScHt=",0,"100*sector+Hit_ID in EC1R");
   G__memvar_setup((void*)((long)(&p->Etot)-(long)(p)),102,0,0,-1,-1,-1,1,"Etot=",0,"Reconstructed total energy");
   G__memvar_setup((void*)((long)(&p->Time)-(long)(p)),102,0,0,-1,-1,-1,1,"Time=",0,"Flight time relative to the evnt start time");
   G__memvar_setup((void*)((long)(&p->Path)-(long)(p)),102,0,0,-1,-1,-1,1,"Path=",0,"Path lenght from target");
   G__memvar_setup((void*)((long)(&p->X)-(long)(p)),102,0,0,-1,-1,-1,1,"X=",0,"x coordinate of the hit");
   G__memvar_setup((void*)((long)(&p->Y)-(long)(p)),102,0,0,-1,-1,-1,1,"Y=",0,"y coordinate of the hit");
   G__memvar_setup((void*)((long)(&p->Z)-(long)(p)),102,0,0,-1,-1,-1,1,"Z=",0,"z coordinate of the hit");
   G__memvar_setup((void*)((long)(&p->Chi2LC)-(long)(p)),102,0,0,-1,-1,-1,1,"Chi2LC=",0,"Quality measure of geometrical matching");
   G__memvar_setup((void*)((long)(&p->Status)-(long)(p)),105,0,0,-1,-1,-1,1,"Status=",0,"Status word");
   G__memvar_setup((void*)((long)(&p->Ein)-(long)(p)),102,0,0,-1,-1,-1,1,"Ein=",0,"Reconstructed energy in the inner part");
   }
   G__tag_memvar_reset();
}


   /* LOWQ_t */
static void G__setup_memvarLOWQ_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_LOWQ_t));
   { LOWQ_t *p; p=(LOWQ_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->pid)-(long)(p)),105,0,0,-1,-1,-1,1,"pid=",0,"particle id (GEANT)");
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"vector3_t vert; Vertex position {x,y,z}");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z");
   G__memvar_setup((void*)((long)(&p->E)-(long)(p)),102,0,0,-1,-1,-1,1,"E=",0,"vector4_t p; Energy");
   G__memvar_setup((void*)((long)(&p->px)-(long)(p)),102,0,0,-1,-1,-1,1,"px=",0,"momentum {x,y,z}");
   G__memvar_setup((void*)((long)(&p->py)-(long)(p)),102,0,0,-1,-1,-1,1,"py=",0,"py");
   G__memvar_setup((void*)((long)(&p->pz)-(long)(p)),102,0,0,-1,-1,-1,1,"pz=",0,"pz");
   G__memvar_setup((void*)((long)(&p->q)-(long)(p)),102,0,0,-1,-1,-1,1,"q=",0,"charge");
   G__memvar_setup((void*)((long)(&p->qpid)-(long)(p)),102,0,0,-1,-1,-1,1,"qpid=",0,"quality factor for the pid");
   G__memvar_setup((void*)((long)(&p->qtrk)-(long)(p)),102,0,0,-1,-1,-1,1,"qtrk=",0,"quality factor for the trk");
   G__memvar_setup((void*)((long)(&p->flags)-(long)(p)),105,0,0,-1,-1,-1,1,"flags=",0,"set of flags defining track (ie, BEAM)");
   }
   G__tag_memvar_reset();
}


   /* MCEV_t */
static void G__setup_memvarMCEV_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_MCEV_t));
   { MCEV_t *p; p=(MCEV_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->I1)-(long)(p)),105,0,0,-1,-1,-1,1,"I1=",0,"first geant random number seed for event");
   G__memvar_setup((void*)((long)(&p->i2)-(long)(p)),105,0,0,-1,-1,-1,1,"i2=",0,"second seed");
   }
   G__tag_memvar_reset();
}


   /* MCHD_t */
static void G__setup_memvarMCHD_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_MCHD_t));
   { MCHD_t *p; p=(MCHD_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->NRUN)-(long)(p)),105,0,0,-1,-1,-1,1,"NRUN=",0,"Run Number");
   G__memvar_setup((void*)((long)(&p->NEVENT)-(long)(p)),105,0,0,-1,-1,-1,1,"NEVENT=",0,"Event Number");
   G__memvar_setup((void*)((long)(&p->TIME)-(long)(p)),105,0,0,-1,-1,-1,1,"TIME=",0,"Event Time (UNIX time)");
   G__memvar_setup((void*)((long)(&p->TYPE)-(long)(p)),105,0,0,-1,-1,-1,1,"TYPE=",0,"Event Type (MUST be negative)");
   G__memvar_setup((void*)((long)(&p->REACTYPE)-(long)(p)),105,0,0,-1,-1,-1,1,"REACTYPE=",0,"optional: user defined reaction type");
   G__memvar_setup((void*)((long)(&p->WEIGHT)-(long)(p)),102,0,0,-1,-1,-1,1,"WEIGHT=",0,"event weight");
   G__memvar_setup((void*)((long)(&p->W)-(long)(p)),102,0,0,-1,-1,-1,1,"W=",0,"center_of_mass energy (inv.mass of hadronic states)");
   G__memvar_setup((void*)((long)(&p->Q2)-(long)(p)),102,0,0,-1,-1,-1,1,"Q2=",0,"Q2 (photon virtuallity)");
   G__memvar_setup((void*)((long)(&p->E_PHOT)-(long)(p)),102,0,0,-1,-1,-1,1,"E_PHOT=",0,"energy of (real/virtual) photon");
   G__memvar_setup((void*)((long)(&p->PX_PHOT)-(long)(p)),102,0,0,-1,-1,-1,1,"PX_PHOT=",0,"p_x: momentum (in x) of (real/virtual) photon");
   G__memvar_setup((void*)((long)(&p->PY_PHOT)-(long)(p)),102,0,0,-1,-1,-1,1,"PY_PHOT=",0,"p_y: momentum (in y) of (real/virtual) photon");
   G__memvar_setup((void*)((long)(&p->PZ_PHOT)-(long)(p)),102,0,0,-1,-1,-1,1,"PZ_PHOT=",0,"p_z: momentum (in z) of (real/virtual) photon");
   G__memvar_setup((void*)((long)(&p->E_TARG)-(long)(p)),102,0,0,-1,-1,-1,1,"E_TARG=",0,"energy of target particle");
   G__memvar_setup((void*)((long)(&p->PX_TARG)-(long)(p)),102,0,0,-1,-1,-1,1,"PX_TARG=",0,"p_x: momentum (in x) of target part.");
   G__memvar_setup((void*)((long)(&p->PY_TARG)-(long)(p)),102,0,0,-1,-1,-1,1,"PY_TARG=",0,"p_y: momentum (in y) of target part.");
   G__memvar_setup((void*)((long)(&p->PZ_TARG)-(long)(p)),102,0,0,-1,-1,-1,1,"PZ_TARG=",0,"p_z: momentum (in z) of target part.");
   }
   G__tag_memvar_reset();
}


   /* MCTK_t */
static void G__setup_memvarMCTK_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_MCTK_t));
   { MCTK_t *p; p=(MCTK_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->cx)-(long)(p)),102,0,0,-1,-1,-1,1,"cx=",0,"x dir cosine at track origin");
   G__memvar_setup((void*)((long)(&p->cy)-(long)(p)),102,0,0,-1,-1,-1,1,"cy=",0,"y dir cosine");
   G__memvar_setup((void*)((long)(&p->cz)-(long)(p)),102,0,0,-1,-1,-1,1,"cz=",0,"z dir cosine");
   G__memvar_setup((void*)((long)(&p->pmom)-(long)(p)),102,0,0,-1,-1,-1,1,"pmom=",0,"momentum");
   G__memvar_setup((void*)((long)(&p->mass)-(long)(p)),102,0,0,-1,-1,-1,1,"mass=",0,"mass");
   G__memvar_setup((void*)((long)(&p->charge)-(long)(p)),102,0,0,-1,-1,-1,1,"charge=",0,"charge");
   G__memvar_setup((void*)((long)(&p->id)-(long)(p)),105,0,0,-1,-1,-1,1,"id=",0,"track Particle Data Group id");
   G__memvar_setup((void*)((long)(&p->flag)-(long)(p)),105,0,0,-1,-1,-1,1,"flag=",0,"track flag");
   G__memvar_setup((void*)((long)(&p->beg_vtx)-(long)(p)),105,0,0,-1,-1,-1,1,"beg_vtx=",0,"beginning vertex number ");
   G__memvar_setup((void*)((long)(&p->end_vtx)-(long)(p)),105,0,0,-1,-1,-1,1,"end_vtx=",0,"ending vertex number");
   G__memvar_setup((void*)((long)(&p->parent)-(long)(p)),105,0,0,-1,-1,-1,1,"parent=",0,"parent track");
   }
   G__tag_memvar_reset();
}


   /* MCVX_t */
static void G__setup_memvarMCVX_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_MCVX_t));
   { MCVX_t *p; p=(MCVX_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"x of vertex");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z");
   G__memvar_setup((void*)((long)(&p->tof)-(long)(p)),102,0,0,-1,-1,-1,1,"tof=",0,"secs of flight");
   G__memvar_setup((void*)((long)(&p->flag)-(long)(p)),105,0,0,-1,-1,-1,1,"flag=",0,"vertex flag");
   }
   G__tag_memvar_reset();
}


   /* MS1_t */
static void G__setup_memvarMS1_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_MS1_t));
   { MS1_t *p; p=(MS1_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the struck microstrip/panel (4 panels)");
   G__memvar_setup((void*)((long)(&p->ADC)-(long)(p)),114,0,0,-1,-1,-1,1,"ADC=",0,"adc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* MTRK_t */
static void G__setup_memvarMTRK_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_MTRK_t));
   { MTRK_t *p; p=(MTRK_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->sect)-(long)(p)),105,0,0,-1,-1,-1,1,"sect=",0,"Sector Number for track");
   G__memvar_setup((void*)((long)(&p->trkl1)-(long)(p)),105,0,0,-1,-1,-1,1,"trkl1=",0,"track segment and track cluster for Superlayer 1 (lnk_t)");
   G__memvar_setup((void*)((long)(&p->trkl2)-(long)(p)),105,0,0,-1,-1,-1,1,"trkl2=",0,"track segment and track cluster for Superlayer 2");
   G__memvar_setup((void*)((long)(&p->trkl3)-(long)(p)),105,0,0,-1,-1,-1,1,"trkl3=",0,"track segment and track cluster for Superlayer 3");
   G__memvar_setup((void*)((long)(&p->trkl4)-(long)(p)),105,0,0,-1,-1,-1,1,"trkl4=",0,"track segment and track cluster for Superlayer 4");
   G__memvar_setup((void*)((long)(&p->trkl5)-(long)(p)),105,0,0,-1,-1,-1,1,"trkl5=",0,"track segment and track cluster for Superlayer 5");
   G__memvar_setup((void*)((long)(&p->trkl6)-(long)(p)),105,0,0,-1,-1,-1,1,"trkl6=",0,"track segment and track cluster for Superlayer 6");
   }
   G__tag_memvar_reset();
}


   /* MVRT_t */
static void G__setup_memvarMVRT_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_MVRT_t));
   { MVRT_t *p; p=(MVRT_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->v_id)-(long)(p)),105,0,0,-1,-1,-1,1,"v_id=",0,"info about track ids");
   G__memvar_setup((void*)((long)(&p->ntrk)-(long)(p)),105,0,0,-1,-1,-1,1,"ntrk=",0,"number of tracks used to make vertex");
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"x vector3_t vert{x,y,z}");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y ");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z");
   G__memvar_setup((void*)((long)(&p->chi2)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2=",0,"chi2");
   G__memvar_setup((void*)((long)(&p->cxx)-(long)(p)),102,0,0,-1,-1,-1,1,"cxx=",0,"Covariance matrix array element");
   G__memvar_setup((void*)((long)(&p->cxy)-(long)(p)),102,0,0,-1,-1,-1,1,"cxy=",0,"Covariance matrix array element");
   G__memvar_setup((void*)((long)(&p->cxz)-(long)(p)),102,0,0,-1,-1,-1,1,"cxz=",0,"Covariance matrix array element");
   G__memvar_setup((void*)((long)(&p->cyy)-(long)(p)),102,0,0,-1,-1,-1,1,"cyy=",0,"Covariance matrix array element");
   G__memvar_setup((void*)((long)(&p->cyz)-(long)(p)),102,0,0,-1,-1,-1,1,"cyz=",0,"Covariance matrix array element");
   G__memvar_setup((void*)((long)(&p->czz)-(long)(p)),102,0,0,-1,-1,-1,1,"czz=",0,"Covariance matrix array element");
   G__memvar_setup((void*)((long)(&p->stat)-(long)(p)),105,0,0,-1,-1,-1,1,"stat=",0,"status integer, not used yet");
   }
   G__tag_memvar_reset();
}


   /* PART_t */
static void G__setup_memvarPART_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PART_t));
   { PART_t *p; p=(PART_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->pid)-(long)(p)),105,0,0,-1,-1,-1,1,"pid=",0,"particle id (GEANT)");
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"vector3_t vert; Vertex position {x,y,z} ");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z");
   G__memvar_setup((void*)((long)(&p->E)-(long)(p)),102,0,0,-1,-1,-1,1,"E=",0,"vector4_t p; Energy");
   G__memvar_setup((void*)((long)(&p->px)-(long)(p)),102,0,0,-1,-1,-1,1,"px=",0,"momentum {x,y,z}");
   G__memvar_setup((void*)((long)(&p->py)-(long)(p)),102,0,0,-1,-1,-1,1,"py=",0,"py");
   G__memvar_setup((void*)((long)(&p->pz)-(long)(p)),102,0,0,-1,-1,-1,1,"pz=",0,"pz");
   G__memvar_setup((void*)((long)(&p->q)-(long)(p)),102,0,0,-1,-1,-1,1,"q=",0,"charge");
   G__memvar_setup((void*)((long)(&p->trkid)-(long)(p)),105,0,0,-1,-1,-1,1,"trkid=",0,"index to TBID bank, counting from 1");
   G__memvar_setup((void*)((long)(&p->qpid)-(long)(p)),102,0,0,-1,-1,-1,1,"qpid=",0,"quality factor for the pid");
   G__memvar_setup((void*)((long)(&p->qtrk)-(long)(p)),102,0,0,-1,-1,-1,1,"qtrk=",0,"quality factor for the trk");
   G__memvar_setup((void*)((long)(&p->flags)-(long)(p)),105,0,0,-1,-1,-1,1,"flags=",0,"set of flags defining track (ie, BEAM)");
   }
   G__tag_memvar_reset();
}


   /* PCO_t */
static void G__setup_memvarPCO_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PCO_t));
   { PCO_t *p; p=(PCO_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->TIME)-(long)(p)),102,0,0,-1,-1,-1,1,"TIME=",0,"TDC time ");
   G__memvar_setup((void*)((long)(&p->ELT)-(long)(p)),102,0,0,-1,-1,-1,1,"ELT=",0,"energy deposit PC = left top");
   G__memvar_setup((void*)((long)(&p->ERB)-(long)(p)),102,0,0,-1,-1,-1,1,"ERB=",0,"energy deposit PC = right bottom");
   G__memvar_setup((void*)((long)(&p->ELB)-(long)(p)),102,0,0,-1,-1,-1,1,"ELB=",0,"energy deposit PC = left bottom ");
   G__memvar_setup((void*)((long)(&p->ERT)-(long)(p)),102,0,0,-1,-1,-1,1,"ERT=",0,"energy deposit PC = right top");
   G__memvar_setup((void*)((long)(&p->EMAIN)-(long)(p)),102,0,0,-1,-1,-1,1,"EMAIN=",0,"energy deposit PC = MAIN");
   G__memvar_setup((void*)((long)(&p->EVETO)-(long)(p)),102,0,0,-1,-1,-1,1,"EVETO=",0,"energy deposit PC = veto");
   G__memvar_setup((void*)((long)(&p->TID)-(long)(p)),105,0,0,-1,-1,-1,1,"TID=",0,"T id of the corresponding T");
   }
   G__tag_memvar_reset();
}


   /* PHTM_t */
static void G__setup_memvarPHTM_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PHTM_t));
   { PHTM_t *p; p=(PHTM_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->EVID)-(long)(p)),104,0,0,-1,-1,-1,1,"EVID=",0,"Event ID (number of triggers)");
   G__memvar_setup((void*)((long)(&p->Nsprot)-(long)(p)),104,0,0,-1,-1,-1,1,"Nsprot=",0,"Number of single proton events");
   G__memvar_setup((void*)((long)(&p->Npip)-(long)(p)),104,0,0,-1,-1,-1,1,"Npip=",0,"Number of single pi+ events");
   G__memvar_setup((void*)((long)(&p->Npim)-(long)(p)),104,0,0,-1,-1,-1,1,"Npim=",0,"Number of single pi- events");
   G__memvar_setup((void*)((long)(&p->Nppippim)-(long)(p)),104,0,0,-1,-1,-1,1,"Nppippim=",0,"Number of single proton pi+ pi- events");
   G__memvar_setup((void*)((long)(&p->Nppip)-(long)(p)),104,0,0,-1,-1,-1,1,"Nppip=",0,"Number of single proton pi+ events");
   G__memvar_setup((void*)((long)(&p->Npippim)-(long)(p)),104,0,0,-1,-1,-1,1,"Npippim=",0,"Number of single pi+ pi- events");
   G__memvar_setup((void*)((long)(&p->Nppim)-(long)(p)),104,0,0,-1,-1,-1,1,"Nppim=",0,"Number of single proton pi- events");
   G__memvar_setup((void*)((long)(&p->Nkp)-(long)(p)),104,0,0,-1,-1,-1,1,"Nkp=",0,"Number of single K+ events");
   G__memvar_setup((void*)((long)(&p->Npkp)-(long)(p)),104,0,0,-1,-1,-1,1,"Npkp=",0,"Number of single proton K+ events");
   G__memvar_setup((void*)((long)(&p->tag_pi_v)-(long)(p)),102,0,0,-1,-1,-1,1,"tag_pi_v=",0,"Mean of (tagger_time - pion_vertex_time)");
   }
   G__tag_memvar_reset();
}


   /* PID1_t */
static void G__setup_memvarPID1_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PID1_t));
   { PID1_t *p; p=(PID1_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->NHBpos_1)-(long)(p)),104,0,0,-1,-1,-1,1,"NHBpos_1=",0,"Number of pos Hit-Based tracks for sec=1");
   G__memvar_setup((void*)((long)(&p->NHBneg_1)-(long)(p)),104,0,0,-1,-1,-1,1,"NHBneg_1=",0,"Number of neg Hit-Based tracks for sec=1");
   G__memvar_setup((void*)((long)(&p->NTBpos_1)-(long)(p)),104,0,0,-1,-1,-1,1,"NTBpos_1=",0,"Number of pos Time-Based tracks  for sec=1");
   G__memvar_setup((void*)((long)(&p->NTBneg_1)-(long)(p)),104,0,0,-1,-1,-1,1,"NTBneg_1=",0,"Number of neg Time-Based tracks for sec=1");
   G__memvar_setup((void*)((long)(&p->chi2pos_1)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2pos_1=",0,"Chi^2 for positive tracks for sec=1");
   G__memvar_setup((void*)((long)(&p->chi2neg_1)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2neg_1=",0,"Chi^2 for negative tracks for sec=1");
   G__memvar_setup((void*)((long)(&p->Nunknown_1)-(long)(p)),104,0,0,-1,-1,-1,1,"Nunknown_1=",0,"Number of unknown particles for sec=1");
   G__memvar_setup((void*)((long)(&p->Ngamma_1)-(long)(p)),104,0,0,-1,-1,-1,1,"Ngamma_1=",0,"Number of photons for sec=1");
   G__memvar_setup((void*)((long)(&p->Nelec_1)-(long)(p)),104,0,0,-1,-1,-1,1,"Nelec_1=",0,"Number of electrons for sec=1");
   G__memvar_setup((void*)((long)(&p->Npiplus_1)-(long)(p)),104,0,0,-1,-1,-1,1,"Npiplus_1=",0,"Number of pi+ for sec=1");
   G__memvar_setup((void*)((long)(&p->Npiminus_1)-(long)(p)),104,0,0,-1,-1,-1,1,"Npiminus_1=",0,"Number of pi- for sec=1");
   G__memvar_setup((void*)((long)(&p->Nprot_1)-(long)(p)),104,0,0,-1,-1,-1,1,"Nprot_1=",0,"Number of proton for sec=1");
   G__memvar_setup((void*)((long)(&p->Nkplus_1)-(long)(p)),104,0,0,-1,-1,-1,1,"Nkplus_1=",0,"Number of K+ for sec=1");
   G__memvar_setup((void*)((long)(&p->Nkminus_1)-(long)(p)),104,0,0,-1,-1,-1,1,"Nkminus_1=",0,"Number of K- for sec=1");
   G__memvar_setup((void*)((long)(&p->Ndeuteron_1)-(long)(p)),104,0,0,-1,-1,-1,1,"Ndeuteron_1=",0,"Number of deuterons for sec=1");
   G__memvar_setup((void*)((long)(&p->Nneutron_1)-(long)(p)),104,0,0,-1,-1,-1,1,"Nneutron_1=",0,"Number of neutrons for sec=1 ");
   }
   G__tag_memvar_reset();
}


   /* PID2_t */
static void G__setup_memvarPID2_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PID2_t));
   { PID2_t *p; p=(PID2_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->NHBpos_2)-(long)(p)),104,0,0,-1,-1,-1,1,"NHBpos_2=",0,"Number of pos Hit-Based tracks for sec=2");
   G__memvar_setup((void*)((long)(&p->NHBneg_2)-(long)(p)),104,0,0,-1,-1,-1,1,"NHBneg_2=",0,"Number of neg Hit-Based tracks for sec=2");
   G__memvar_setup((void*)((long)(&p->NTBpos_2)-(long)(p)),104,0,0,-1,-1,-1,1,"NTBpos_2=",0,"Number of pos Time-Based tracks  for sec=2");
   G__memvar_setup((void*)((long)(&p->NTBneg_2)-(long)(p)),104,0,0,-1,-1,-1,1,"NTBneg_2=",0,"Number of neg Time-Based tracks for sec=2");
   G__memvar_setup((void*)((long)(&p->chi2pos_2)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2pos_2=",0,"Chi^2 for positive tracks for sec=2");
   G__memvar_setup((void*)((long)(&p->chi2neg_2)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2neg_2=",0,"Chi^2 for negative tracks for sec=2");
   G__memvar_setup((void*)((long)(&p->Nunknown_2)-(long)(p)),104,0,0,-1,-1,-1,1,"Nunknown_2=",0,"Number of unknown particles for sec=2");
   G__memvar_setup((void*)((long)(&p->Ngamma_2)-(long)(p)),104,0,0,-1,-1,-1,1,"Ngamma_2=",0,"Number of photons for sec=2");
   G__memvar_setup((void*)((long)(&p->Nelec_2)-(long)(p)),104,0,0,-1,-1,-1,1,"Nelec_2=",0,"Number of electrons for sec=2");
   G__memvar_setup((void*)((long)(&p->Npiplus_2)-(long)(p)),104,0,0,-1,-1,-1,1,"Npiplus_2=",0,"Number of pi+ for sec=2");
   G__memvar_setup((void*)((long)(&p->Npiminus_2)-(long)(p)),104,0,0,-1,-1,-1,1,"Npiminus_2=",0,"Number of pi- for sec=2");
   G__memvar_setup((void*)((long)(&p->Nprot_2)-(long)(p)),104,0,0,-1,-1,-1,1,"Nprot_2=",0,"Number of proton for sec=2");
   G__memvar_setup((void*)((long)(&p->Nkplus_2)-(long)(p)),104,0,0,-1,-1,-1,1,"Nkplus_2=",0,"Number of K+ for sec=2");
   G__memvar_setup((void*)((long)(&p->Nkminus_2)-(long)(p)),104,0,0,-1,-1,-1,1,"Nkminus_2=",0,"Number of K- for sec=2");
   G__memvar_setup((void*)((long)(&p->Ndeuteron_2)-(long)(p)),104,0,0,-1,-1,-1,1,"Ndeuteron_2=",0,"Number of deuterons for sec=2");
   G__memvar_setup((void*)((long)(&p->Nneutron_2)-(long)(p)),104,0,0,-1,-1,-1,1,"Nneutron_2=",0,"Number of neutrons for sec=2");
   }
   G__tag_memvar_reset();
}


   /* PID3_t */
static void G__setup_memvarPID3_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PID3_t));
   { PID3_t *p; p=(PID3_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->NHBpos_3)-(long)(p)),104,0,0,-1,-1,-1,1,"NHBpos_3=",0,"Number of pos Hit-Based tracks for sec=3");
   G__memvar_setup((void*)((long)(&p->NHBneg_3)-(long)(p)),104,0,0,-1,-1,-1,1,"NHBneg_3=",0,"Number of neg Hit-Based tracks for sec=3");
   G__memvar_setup((void*)((long)(&p->NTBpos_3)-(long)(p)),104,0,0,-1,-1,-1,1,"NTBpos_3=",0,"Number of pos Time-Based tracks  for sec=3");
   G__memvar_setup((void*)((long)(&p->NTBneg_3)-(long)(p)),104,0,0,-1,-1,-1,1,"NTBneg_3=",0,"Number of neg Time-Based tracks for sec=3");
   G__memvar_setup((void*)((long)(&p->chi2pos_3)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2pos_3=",0,"Chi^2 for positive tracks for sec=3");
   G__memvar_setup((void*)((long)(&p->chi2neg_3)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2neg_3=",0,"Chi^2 for negative tracks for sec=3");
   G__memvar_setup((void*)((long)(&p->Nunknown_3)-(long)(p)),104,0,0,-1,-1,-1,1,"Nunknown_3=",0,"Number of unknown particles for sec=3");
   G__memvar_setup((void*)((long)(&p->Ngamma_3)-(long)(p)),104,0,0,-1,-1,-1,1,"Ngamma_3=",0,"Number of photons for sec=3");
   G__memvar_setup((void*)((long)(&p->Nelec_3)-(long)(p)),104,0,0,-1,-1,-1,1,"Nelec_3=",0,"Number of electrons for sec=3");
   G__memvar_setup((void*)((long)(&p->Npiplus_3)-(long)(p)),104,0,0,-1,-1,-1,1,"Npiplus_3=",0,"Number of pi+ for sec=3");
   G__memvar_setup((void*)((long)(&p->Npiminus_3)-(long)(p)),104,0,0,-1,-1,-1,1,"Npiminus_3=",0,"Number of pi- for sec=3");
   G__memvar_setup((void*)((long)(&p->Nprot_3)-(long)(p)),104,0,0,-1,-1,-1,1,"Nprot_3=",0,"Number of proton for sec=3");
   G__memvar_setup((void*)((long)(&p->Nkplus_3)-(long)(p)),104,0,0,-1,-1,-1,1,"Nkplus_3=",0,"Number of K+ for sec=3");
   G__memvar_setup((void*)((long)(&p->Nkminus_3)-(long)(p)),104,0,0,-1,-1,-1,1,"Nkminus_3=",0,"Number of K- for sec=3");
   G__memvar_setup((void*)((long)(&p->Ndeuteron_3)-(long)(p)),104,0,0,-1,-1,-1,1,"Ndeuteron_3=",0,"Number of deuterons for sec=3");
   G__memvar_setup((void*)((long)(&p->Nneutron_3)-(long)(p)),104,0,0,-1,-1,-1,1,"Nneutron_3=",0,"Number of neutrons for sec=3");
   }
   G__tag_memvar_reset();
}


   /* PID4_t */
static void G__setup_memvarPID4_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PID4_t));
   { PID4_t *p; p=(PID4_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->NHBpos_4)-(long)(p)),104,0,0,-1,-1,-1,1,"NHBpos_4=",0,"Number of pos Hit-Based tracks for sec=4");
   G__memvar_setup((void*)((long)(&p->NHBneg_4)-(long)(p)),104,0,0,-1,-1,-1,1,"NHBneg_4=",0,"Number of neg Hit-Based tracks for sec=4");
   G__memvar_setup((void*)((long)(&p->NTBpos_4)-(long)(p)),104,0,0,-1,-1,-1,1,"NTBpos_4=",0,"Number of pos Time-Based tracks  for sec=4");
   G__memvar_setup((void*)((long)(&p->NTBneg_4)-(long)(p)),104,0,0,-1,-1,-1,1,"NTBneg_4=",0,"Number of neg Time-Based tracks for sec=4");
   G__memvar_setup((void*)((long)(&p->chi2pos_4)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2pos_4=",0,"Chi^2 for positive tracks for sec=4");
   G__memvar_setup((void*)((long)(&p->chi2neg_4)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2neg_4=",0,"Chi^2 for negative tracks for sec=4");
   G__memvar_setup((void*)((long)(&p->Nunknown_4)-(long)(p)),104,0,0,-1,-1,-1,1,"Nunknown_4=",0,"Number of unknown particles for sec=4");
   G__memvar_setup((void*)((long)(&p->Ngamma_4)-(long)(p)),104,0,0,-1,-1,-1,1,"Ngamma_4=",0,"Number of photons for sec=4");
   G__memvar_setup((void*)((long)(&p->Nelec_4)-(long)(p)),104,0,0,-1,-1,-1,1,"Nelec_4=",0,"Number of electrons for sec=4");
   G__memvar_setup((void*)((long)(&p->Npiplus_4)-(long)(p)),104,0,0,-1,-1,-1,1,"Npiplus_4=",0,"Number of pi+ for sec=4");
   G__memvar_setup((void*)((long)(&p->Npiminus_4)-(long)(p)),104,0,0,-1,-1,-1,1,"Npiminus_4=",0,"Number of pi- for sec=4");
   G__memvar_setup((void*)((long)(&p->Nprot_4)-(long)(p)),104,0,0,-1,-1,-1,1,"Nprot_4=",0,"Number of proton for sec=4");
   G__memvar_setup((void*)((long)(&p->Nkplus_4)-(long)(p)),104,0,0,-1,-1,-1,1,"Nkplus_4=",0,"Number of K+ for sec=4");
   G__memvar_setup((void*)((long)(&p->Nkminus_4)-(long)(p)),104,0,0,-1,-1,-1,1,"Nkminus_4=",0,"Number of K- for sec=4");
   G__memvar_setup((void*)((long)(&p->Ndeuteron_4)-(long)(p)),104,0,0,-1,-1,-1,1,"Ndeuteron_4=",0,"Number of deuterons for sec=4");
   G__memvar_setup((void*)((long)(&p->Nneutron_4)-(long)(p)),104,0,0,-1,-1,-1,1,"Nneutron_4=",0,"Number of neutrons for sec=4   ");
   }
   G__tag_memvar_reset();
}


   /* PID5_t */
static void G__setup_memvarPID5_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PID5_t));
   { PID5_t *p; p=(PID5_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->NHBpos_5)-(long)(p)),104,0,0,-1,-1,-1,1,"NHBpos_5=",0,"Number of pos Hit-Based tracks for sec=5");
   G__memvar_setup((void*)((long)(&p->NHBneg_5)-(long)(p)),104,0,0,-1,-1,-1,1,"NHBneg_5=",0,"Number of neg Hit-Based tracks for sec=5");
   G__memvar_setup((void*)((long)(&p->NTBpos_5)-(long)(p)),104,0,0,-1,-1,-1,1,"NTBpos_5=",0,"Number of pos Time-Based tracks  for sec=5");
   G__memvar_setup((void*)((long)(&p->NTBneg_5)-(long)(p)),104,0,0,-1,-1,-1,1,"NTBneg_5=",0,"Number of neg Time-Based tracks for sec=5");
   G__memvar_setup((void*)((long)(&p->chi2pos_5)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2pos_5=",0,"Chi^2 for positive tracks for sec=5");
   G__memvar_setup((void*)((long)(&p->chi2neg_5)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2neg_5=",0,"Chi^2 for negative tracks for sec=5");
   G__memvar_setup((void*)((long)(&p->Nunknown_5)-(long)(p)),104,0,0,-1,-1,-1,1,"Nunknown_5=",0,"Number of unknown particles for sec=5");
   G__memvar_setup((void*)((long)(&p->Ngamma_5)-(long)(p)),104,0,0,-1,-1,-1,1,"Ngamma_5=",0,"Number of photons for sec=5");
   G__memvar_setup((void*)((long)(&p->Nelec_5)-(long)(p)),104,0,0,-1,-1,-1,1,"Nelec_5=",0,"Number of electrons for sec=5");
   G__memvar_setup((void*)((long)(&p->Npiplus_5)-(long)(p)),104,0,0,-1,-1,-1,1,"Npiplus_5=",0,"Number of pi+ for sec=5");
   G__memvar_setup((void*)((long)(&p->Npiminus_5)-(long)(p)),104,0,0,-1,-1,-1,1,"Npiminus_5=",0,"Number of pi- for sec=5");
   G__memvar_setup((void*)((long)(&p->Nprot_5)-(long)(p)),104,0,0,-1,-1,-1,1,"Nprot_5=",0,"Number of proton for sec=5");
   G__memvar_setup((void*)((long)(&p->Nkplus_5)-(long)(p)),104,0,0,-1,-1,-1,1,"Nkplus_5=",0,"Number of K+ for sec=5");
   G__memvar_setup((void*)((long)(&p->Nkminus_5)-(long)(p)),104,0,0,-1,-1,-1,1,"Nkminus_5=",0,"Number of K- for sec=5");
   G__memvar_setup((void*)((long)(&p->Ndeuteron_5)-(long)(p)),104,0,0,-1,-1,-1,1,"Ndeuteron_5=",0,"Number of deuterons for sec=5");
   G__memvar_setup((void*)((long)(&p->Nneutron_5)-(long)(p)),104,0,0,-1,-1,-1,1,"Nneutron_5=",0,"Number of neutrons for sec=5 ");
   }
   G__tag_memvar_reset();
}


   /* PID6_t */
static void G__setup_memvarPID6_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PID6_t));
   { PID6_t *p; p=(PID6_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->NHBpos_6)-(long)(p)),104,0,0,-1,-1,-1,1,"NHBpos_6=",0,"Number of pos Hit-Based tracks for sec=6");
   G__memvar_setup((void*)((long)(&p->NHBneg_6)-(long)(p)),104,0,0,-1,-1,-1,1,"NHBneg_6=",0,"Number of neg Hit-Based tracks for sec=6");
   G__memvar_setup((void*)((long)(&p->NTBpos_6)-(long)(p)),104,0,0,-1,-1,-1,1,"NTBpos_6=",0,"Number of pos Time-Based tracks  for sec=6");
   G__memvar_setup((void*)((long)(&p->NTBneg_6)-(long)(p)),104,0,0,-1,-1,-1,1,"NTBneg_6=",0,"Number of neg Time-Based tracks for sec=6");
   G__memvar_setup((void*)((long)(&p->chi2pos_6)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2pos_6=",0,"Chi^2 for positive tracks for sec=6");
   G__memvar_setup((void*)((long)(&p->chi2neg_6)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2neg_6=",0,"Chi^2 for negative tracks for sec=6");
   G__memvar_setup((void*)((long)(&p->Nunknown_6)-(long)(p)),104,0,0,-1,-1,-1,1,"Nunknown_6=",0,"Number of unknown particles for sec=6");
   G__memvar_setup((void*)((long)(&p->Ngamma_6)-(long)(p)),104,0,0,-1,-1,-1,1,"Ngamma_6=",0,"Number of photons for sec=6");
   G__memvar_setup((void*)((long)(&p->Nelec_6)-(long)(p)),104,0,0,-1,-1,-1,1,"Nelec_6=",0,"Number of electrons for sec=6");
   G__memvar_setup((void*)((long)(&p->Npiplus_6)-(long)(p)),104,0,0,-1,-1,-1,1,"Npiplus_6=",0,"Number of pi+ for sec=6");
   G__memvar_setup((void*)((long)(&p->Npiminus_6)-(long)(p)),104,0,0,-1,-1,-1,1,"Npiminus_6=",0,"Number of pi- for sec=6");
   G__memvar_setup((void*)((long)(&p->Nprot_6)-(long)(p)),104,0,0,-1,-1,-1,1,"Nprot_6=",0,"Number of proton for sec=6");
   G__memvar_setup((void*)((long)(&p->Nkplus_6)-(long)(p)),104,0,0,-1,-1,-1,1,"Nkplus_6=",0,"Number of K+ for sec=6");
   G__memvar_setup((void*)((long)(&p->Nkminus_6)-(long)(p)),104,0,0,-1,-1,-1,1,"Nkminus_6=",0,"Number of K- for sec=6");
   G__memvar_setup((void*)((long)(&p->Ndeuteron_6)-(long)(p)),104,0,0,-1,-1,-1,1,"Ndeuteron_6=",0,"Number of deuterons for sec=6");
   G__memvar_setup((void*)((long)(&p->Nneutron_6)-(long)(p)),104,0,0,-1,-1,-1,1,"Nneutron_6=",0,"Number of neutrons for sec=6 ");
   }
   G__tag_memvar_reset();
}


   /* PIDT_t */
static void G__setup_memvarPIDT_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PIDT_t));
   { PIDT_t *p; p=(PIDT_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->Nunknown)-(long)(p)),104,0,0,-1,-1,-1,1,"Nunknown=",0,"Number of particles labelled unknown");
   G__memvar_setup((void*)((long)(&p->Ngamma)-(long)(p)),104,0,0,-1,-1,-1,1,"Ngamma=",0,"Number of photons");
   G__memvar_setup((void*)((long)(&p->Nelec)-(long)(p)),104,0,0,-1,-1,-1,1,"Nelec=",0,"Number of electrons");
   G__memvar_setup((void*)((long)(&p->Npiplus)-(long)(p)),104,0,0,-1,-1,-1,1,"Npiplus=",0,"Number of pi+ ");
   G__memvar_setup((void*)((long)(&p->Npiminus)-(long)(p)),104,0,0,-1,-1,-1,1,"Npiminus=",0,"Number of pi-");
   G__memvar_setup((void*)((long)(&p->Nprot)-(long)(p)),104,0,0,-1,-1,-1,1,"Nprot=",0,"Number of proton");
   G__memvar_setup((void*)((long)(&p->Nkplus)-(long)(p)),104,0,0,-1,-1,-1,1,"Nkplus=",0,"Number of K+");
   G__memvar_setup((void*)((long)(&p->Nkminus)-(long)(p)),104,0,0,-1,-1,-1,1,"Nkminus=",0,"Number of K-");
   G__memvar_setup((void*)((long)(&p->Ndeuteron)-(long)(p)),104,0,0,-1,-1,-1,1,"Ndeuteron=",0,"Number of deuterons");
   G__memvar_setup((void*)((long)(&p->Nneutron)-(long)(p)),104,0,0,-1,-1,-1,1,"Nneutron=",0,"Number of neutrons");
   }
   G__tag_memvar_reset();
}


   /* PRTM_t */
static void G__setup_memvarPRTM_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PRTM_t));
   { PRTM_t *p; p=(PRTM_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->time)-(long)(p)),105,0,0,-1,-1,-1,1,"time=",0,"time of pretrig calibration");
   }
   G__tag_memvar_reset();
}


   /* PSO_t */
static void G__setup_memvarPSO_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PSO_t));
   { PSO_t *p; p=(PSO_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"Counter Id ()");
   G__memvar_setup((void*)((long)(&p->TIME)-(long)(p)),102,0,0,-1,-1,-1,1,"TIME=",0,"TDC time ");
   G__memvar_setup((void*)((long)(&p->ENER)-(long)(p)),102,0,0,-1,-1,-1,1,"ENER=",0,"energy deposit");
   G__memvar_setup((void*)((long)(&p->TID)-(long)(p)),105,0,0,-1,-1,-1,1,"TID=",0,"T id of the corresponding T");
   }
   G__tag_memvar_reset();
}


   /* PTDB_t */
static void G__setup_memvarPTDB_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PTDB_t));
   { PTDB_t *p; p=(PTDB_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->PBeam)-(long)(p)),105,0,0,-1,-1,-1,1,"PBeam=",0,"beam polarization (% x 100)");
   G__memvar_setup((void*)((long)(&p->PB_DATE)-(long)(p)),105,0,0,-1,-1,-1,1,"PB_DATE=",0,"date of measurement");
   G__memvar_setup((void*)((long)(&p->TTYPE)-(long)(p)),105,0,0,-1,-1,-1,1,"TTYPE=",0,"Target Type ");
   G__memvar_setup((void*)((long)(&p->B_TARG)-(long)(p)),105,0,0,-1,-1,-1,1,"B_TARG=",0,"Target holding field (Tesla x100)");
   G__memvar_setup((void*)((long)(&p->PTarg)-(long)(p)),105,0,0,-1,-1,-1,1,"PTarg=",0,"Target polarization");
   G__memvar_setup((void*)((long)(&p->PT_time)-(long)(p)),105,0,0,-1,-1,-1,1,"PT_time=",0,"Time measured (according to PC)");
   G__memvar_setup((void*)((long)(&p->HE_Level)-(long)(p)),105,0,0,-1,-1,-1,1,"HE_Level=",0,"Liquid Helium Level(% x 100)");
   G__memvar_setup((void*)((long)(&p->EIOF)-(long)(p)),105,0,0,-1,-1,-1,1,"EIOF=",0,"EIO microwave tube frequency (MHz)");
   G__memvar_setup((void*)((long)(&p->TTempH)-(long)(p)),105,0,0,-1,-1,-1,1,"TTempH=",0,"Target temp measured by He Cell (K x100)");
   G__memvar_setup((void*)((long)(&p->TTempC)-(long)(p)),105,0,0,-1,-1,-1,1,"TTempC=",0,"Target temp measured by Cernox (K x100)");
   G__memvar_setup((void*)((long)(&p->AnealT)-(long)(p)),105,0,0,-1,-1,-1,1,"AnealT=",0,"Date of last target anealing");
   }
   G__tag_memvar_reset();
}


   /* RCST_t */
static void G__setup_memvarRCST_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RCST_t));
   { RCST_t *p; p=(RCST_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->down_count)-(long)(p)),105,0,0,-1,-1,-1,1,"down_count=",0,"download count");
   G__memvar_setup((void*)((long)(&p->prestart_count)-(long)(p)),105,0,0,-1,-1,-1,1,"prestart_count=",0,"prestart count");
   G__memvar_setup((void*)((long)(&p->go_count)-(long)(p)),105,0,0,-1,-1,-1,1,"go_count=",0,"go count");
   G__memvar_setup((void*)((long)(&p->trig_count)-(long)(p)),105,0,0,-1,-1,-1,1,"trig_count=",0,"total trigger count");
   G__memvar_setup((void*)((long)(&p->event_count)-(long)(p)),105,0,0,-1,-1,-1,1,"event_count=",0,"phys event count");
   G__memvar_setup((void*)((long)(&p->sync_count)-(long)(p)),105,0,0,-1,-1,-1,1,"sync_count=",0,"force-sync event count");
   G__memvar_setup((void*)((long)(&p->run_trig_count)-(long)(p)),105,0,0,-1,-1,-1,1,"run_trig_count=",0,"trigger count current run");
   G__memvar_setup((void*)((long)(&p->run_event_count)-(long)(p)),105,0,0,-1,-1,-1,1,"run_event_count=",0,"phys event count current run");
   G__memvar_setup((void*)((long)(&p->run_sync_count)-(long)(p)),105,0,0,-1,-1,-1,1,"run_sync_count=",0,"force-sync event count current run");
   G__memvar_setup((void*)((long)(&p->pause_count)-(long)(p)),105,0,0,-1,-1,-1,1,"pause_count=",0,"coda pause count");
   G__memvar_setup((void*)((long)(&p->end_count)-(long)(p)),105,0,0,-1,-1,-1,1,"end_count=",0,"end count");
   G__memvar_setup((void*)((long)(&p->illegal_count)-(long)(p)),105,0,0,-1,-1,-1,1,"illegal_count=",0,"illegal count");
   G__memvar_setup((void*)((long)(&p->run_illegal_count)-(long)(p)),105,0,0,-1,-1,-1,1,"run_illegal_count=",0,"illegal count current run");
   G__memvar_setup((void*)((long)(&p->phys_sync_count)-(long)(p)),105,0,0,-1,-1,-1,1,"phys_sync_count=",0,"physics-sync event count");
   G__memvar_setup((void*)((long)(&p->run_phys_sync_count)-(long)(p)),105,0,0,-1,-1,-1,1,"run_phys_sync_count=",0,"physics-sync event count current run");
   }
   G__tag_memvar_reset();
}


   /* REF_t */
static void G__setup_memvarREF_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_REF_t));
   { REF_t *p; p=(REF_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"roc id (high byte) & slot number (low byte)");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* RF_t */
static void G__setup_memvarRF_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RF_t));
   { RF_t *p; p=(RF_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->RF)-(long)(p)),102,0,0,-1,-1,-1,1,"RF=",0,"Best RF value in ns");
   G__memvar_setup((void*)((long)(&p->RF1)-(long)(p)),102,0,0,-1,-1,-1,1,"RF1=",0,"RF1 in ns");
   G__memvar_setup((void*)((long)(&p->RF2)-(long)(p)),102,0,0,-1,-1,-1,1,"RF2=",0,"RF2 in ns");
   }
   G__tag_memvar_reset();
}


   /* RFT_t */
static void G__setup_memvarRFT_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RFT_t));
   { RFT_t *p; p=(RFT_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"id");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* RGLK_t */
static void G__setup_memvarRGLK_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RGLK_t));
   { RGLK_t *p; p=(RGLK_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->IREGION)-(long)(p)),105,0,0,-1,-1,-1,1,"IREGION=",0,"region");
   G__memvar_setup((void*)((long)(&p->X)-(long)(p)),102,0,0,-1,-1,-1,1,"X=",0,"X pos. of hit in CLAS (cm)");
   G__memvar_setup((void*)((long)(&p->Y)-(long)(p)),102,0,0,-1,-1,-1,1,"Y=",0,"Y pos. of hit in CLAS (cm)");
   G__memvar_setup((void*)((long)(&p->Z)-(long)(p)),102,0,0,-1,-1,-1,1,"Z=",0,"Z pos. of hit in CLAS (cm)");
   G__memvar_setup((void*)((long)(&p->THETA0)-(long)(p)),102,0,0,-1,-1,-1,1,"THETA0=",0,"polar angle of the link position (deg)");
   G__memvar_setup((void*)((long)(&p->PHI0)-(long)(p)),102,0,0,-1,-1,-1,1,"PHI0=",0,"azim. angle of the link position (deg)");
   G__memvar_setup((void*)((long)(&p->RTHETA)-(long)(p)),102,0,0,-1,-1,-1,1,"RTHETA=",0,"polar angle of the link direction (deg)");
   G__memvar_setup((void*)((long)(&p->RPHI)-(long)(p)),102,0,0,-1,-1,-1,1,"RPHI=",0,"azim. angle of the link direction (deg)");
   G__memvar_setup((void*)((long)(&p->CHI2)-(long)(p)),102,0,0,-1,-1,-1,1,"CHI2=",0,"fit chi2        ");
   G__memvar_setup((void*)((long)(&p->STATUS)-(long)(p)),105,0,0,-1,-1,-1,1,"STATUS=",0,"MINUIT fit status (from 0=bad to 3=ok)");
   }
   G__tag_memvar_reset();
}


   /* RNLG_t */
static void G__setup_memvarRNLG_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RNLG_t));
   { RNLG_t *p; p=(RNLG_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->sql)-(long)(p)),99,0,0,-1,-1,-1,1,"sql[4]=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* RNPE_t */
static void G__setup_memvarRNPE_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RNPE_t));
   { RNPE_t *p; p=(RNPE_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->run)-(long)(p)),105,0,0,-1,-1,-1,1,"run=",0,"calibration run number");
   G__memvar_setup((void*)((long)(&p->bank)-(long)(p)),99,0,0,-1,-1,-1,1,"bank[4]=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* RTSL_t */
static void G__setup_memvarRTSL_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RTSL_t));
   { RTSL_t *p; p=(RTSL_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->RAWT1)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT2)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT3)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT3=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT4)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT4=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT5)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT5=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT6)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT6=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT7)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT7=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT8)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT8=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT9)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT9=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT10)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT10=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT11)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT11=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT12)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT12=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT13)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT13=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT14)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT14=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT15)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT15=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT16)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT16=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT17)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT17=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT18)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT18=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT19)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT19=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT20)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT20=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT21)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT21=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT22)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT22=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT23)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT23=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT24)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT24=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT25)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT25=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT26)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT26=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT27)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT27=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT28)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT28=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT29)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT29=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT30)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT30=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT31)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT31=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT32)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT32=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT33)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT33=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT34)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT34=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT35)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT35=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT36)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT36=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT37)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT37=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT38)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT38=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT39)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT39=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT40)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT40=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT41)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT41=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT42)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT42=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT43)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT43=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT44)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT44=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT45)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT45=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT46)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT46=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT47)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT47=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT48)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT48=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT49)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT49=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT50)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT50=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT51)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT51=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT52)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT52=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT53)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT53=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT54)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT54=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT55)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT55=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT56)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT56=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT57)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT57=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT58)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT58=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT59)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT59=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT60)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT60=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT61)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT61=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT62)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT62=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT63)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT63=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT64)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT64=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* RUNC_t */
static void G__setup_memvarRUNC_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RUNC_t));
   { RUNC_t *p; p=(RUNC_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->runno)-(long)(p)),105,0,0,-1,-1,-1,1,"runno=",0,"Run number extracted from map");
   G__memvar_setup((void*)((long)(&p->beam_e)-(long)(p)),102,0,0,-1,-1,-1,1,"beam_e=",0,"beam energy in MeV");
   G__memvar_setup((void*)((long)(&p->b_first)-(long)(p)),105,0,0,-1,-1,-1,1,"b_first=",0,"firsttime");
   G__memvar_setup((void*)((long)(&p->q_live)-(long)(p)),102,0,0,-1,-1,-1,1,"q_live=",0,"Fcup * live time (1*E-10C)");
   G__memvar_setup((void*)((long)(&p->ql_first)-(long)(p)),105,0,0,-1,-1,-1,1,"ql_first=",0,"firsttime	");
   G__memvar_setup((void*)((long)(&p->q_all)-(long)(p)),102,0,0,-1,-1,-1,1,"q_all=",0,"Fcup (1*E-10C)");
   G__memvar_setup((void*)((long)(&p->qa_first)-(long)(p)),105,0,0,-1,-1,-1,1,"qa_first=",0,"firsttime	");
   G__memvar_setup((void*)((long)(&p->tor_curr)-(long)(p)),102,0,0,-1,-1,-1,1,"tor_curr=",0,"Torus Current (A)");
   G__memvar_setup((void*)((long)(&p->t_first)-(long)(p)),105,0,0,-1,-1,-1,1,"t_first=",0,"firsttime	");
   G__memvar_setup((void*)((long)(&p->mtor_curr)-(long)(p)),102,0,0,-1,-1,-1,1,"mtor_curr=",0,"Minitorus Current (A)");
   G__memvar_setup((void*)((long)(&p->mt_first)-(long)(p)),105,0,0,-1,-1,-1,1,"mt_first=",0,"firsttime	");
   G__memvar_setup((void*)((long)(&p->tag_curr)-(long)(p)),102,0,0,-1,-1,-1,1,"tag_curr=",0,"Tagger Current (A)");
   G__memvar_setup((void*)((long)(&p->tag_first)-(long)(p)),105,0,0,-1,-1,-1,1,"tag_first=",0,"firsttime	");
   }
   G__tag_memvar_reset();
}


   /* S1ST_t */
static void G__setup_memvarS1ST_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_S1ST_t));
   { S1ST_t *p; p=(S1ST_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->latch1_bit1_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch1_bit1_count=",0,"Count trigger bit 1  latched events");
   G__memvar_setup((void*)((long)(&p->latch1_bit2_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch1_bit2_count=",0,"Count trigger bit 2  latched events");
   G__memvar_setup((void*)((long)(&p->latch1_bit3_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch1_bit3_count=",0,"Count trigger bit 3  latched events");
   G__memvar_setup((void*)((long)(&p->latch1_bit4_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch1_bit4_count=",0,"Count trigger bit 4  latched events");
   G__memvar_setup((void*)((long)(&p->latch1_bit5_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch1_bit5_count=",0,"Count trigger bit 5  latched events");
   G__memvar_setup((void*)((long)(&p->latch1_bit6_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch1_bit6_count=",0,"Count trigger bit 6  latched events");
   G__memvar_setup((void*)((long)(&p->latch1_bit7_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch1_bit7_count=",0,"Count trigger bit 7  latched events");
   G__memvar_setup((void*)((long)(&p->latch1_bit8_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch1_bit8_count=",0,"Count trigger bit 8  latched events");
   G__memvar_setup((void*)((long)(&p->latch1_bit9_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch1_bit9_count=",0,"Count trigger bit 9  latched events");
   G__memvar_setup((void*)((long)(&p->latch1_bit10_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch1_bit10_count=",0,"Count trigger bit 10 latched events");
   G__memvar_setup((void*)((long)(&p->latch1_bit11_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch1_bit11_count=",0,"Count trigger bit 11 latched events");
   G__memvar_setup((void*)((long)(&p->latch1_bit12_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch1_bit12_count=",0,"Count trigger bit 12 latched events");
   G__memvar_setup((void*)((long)(&p->event_count)-(long)(p)),105,0,0,-1,-1,-1,1,"event_count=",0,"Latched event count this run");
   G__memvar_setup((void*)((long)(&p->latch1_zero_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch1_zero_count=",0,"Latch1 zero count (illegal)");
   G__memvar_setup((void*)((long)(&p->latch1_empty_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch1_empty_count=",0,"Latch1 empty count (illegal)");
   G__memvar_setup((void*)((long)(&p->latch1_not_empty_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch1_not_empty_count=",0,"Latch1 not empty on sync event (illegal)");
   G__memvar_setup((void*)((long)(&p->latch1_ok_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch1_ok_count=",0,"Latch1 ok");
   G__memvar_setup((void*)((long)(&p->level2_sector1)-(long)(p)),105,0,0,-1,-1,-1,1,"level2_sector1=",0,"Level2 sector1 count");
   G__memvar_setup((void*)((long)(&p->level2_sector2)-(long)(p)),105,0,0,-1,-1,-1,1,"level2_sector2=",0,"Level2 sector2 count");
   G__memvar_setup((void*)((long)(&p->level2_sector3)-(long)(p)),105,0,0,-1,-1,-1,1,"level2_sector3=",0,"Level2 sector3 count");
   G__memvar_setup((void*)((long)(&p->level2_sector4)-(long)(p)),105,0,0,-1,-1,-1,1,"level2_sector4=",0,"Level2 sector4 count");
   G__memvar_setup((void*)((long)(&p->level2_sector5)-(long)(p)),105,0,0,-1,-1,-1,1,"level2_sector5=",0,"Level2 sector5 count");
   G__memvar_setup((void*)((long)(&p->level2_sector6)-(long)(p)),105,0,0,-1,-1,-1,1,"level2_sector6=",0,"Level2 sector6 count");
   G__memvar_setup((void*)((long)(&p->level2_pass)-(long)(p)),105,0,0,-1,-1,-1,1,"level2_pass=",0,"Level2 pass count");
   G__memvar_setup((void*)((long)(&p->level2_fail)-(long)(p)),105,0,0,-1,-1,-1,1,"level2_fail=",0,"Level2 fail count");
   G__memvar_setup((void*)((long)(&p->latch2_zero_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch2_zero_count=",0,"Latch2 zero count (illegal)");
   G__memvar_setup((void*)((long)(&p->latch2_empty_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch2_empty_count=",0,"Latch2 empty count (illegal)");
   G__memvar_setup((void*)((long)(&p->latch2_not_empty_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch2_not_empty_count=",0,"Latch2 not empty on sync event (illegal)");
   G__memvar_setup((void*)((long)(&p->latch2_ok_count)-(long)(p)),105,0,0,-1,-1,-1,1,"latch2_ok_count=",0,"Latch2 ok");
   G__memvar_setup((void*)((long)(&p->roc_13_count)-(long)(p)),105,0,0,-1,-1,-1,1,"roc_13_count=",0,"Roc code 13 count (zero latch)");
   G__memvar_setup((void*)((long)(&p->roc_15_count)-(long)(p)),105,0,0,-1,-1,-1,1,"roc_15_count=",0,"Roc code 15 count (illegal)");
   G__memvar_setup((void*)((long)(&p->l1l2_zero_count)-(long)(p)),105,0,0,-1,-1,-1,1,"l1l2_zero_count=",0,"(latch1==0)&&(latch2==0)");
   G__memvar_setup((void*)((long)(&p->l1zero_13_count)-(long)(p)),105,0,0,-1,-1,-1,1,"l1zero_13_count=",0,"(latch1==0)&&(roc_code==13)");
   G__memvar_setup((void*)((long)(&p->l2zero_13_count)-(long)(p)),105,0,0,-1,-1,-1,1,"l2zero_13_count=",0,"(latch2==0)&&(roc_code==13)");
   G__memvar_setup((void*)((long)(&p->l1l2zero_13_count)-(long)(p)),105,0,0,-1,-1,-1,1,"l1l2zero_13_count=",0,"(latch1==0)&&(latch2==0)&&(roc_code==13)");
   }
   G__tag_memvar_reset();
}


   /* SC1_t */
static void G__setup_memvarSC1_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SC1_t));
   { SC1_t *p; p=(SC1_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->time_l)-(long)(p)),102,0,0,-1,-1,-1,1,"time_l=",0,"time for left paddle(ns) ");
   G__memvar_setup((void*)((long)(&p->energy_l)-(long)(p)),102,0,0,-1,-1,-1,1,"energy_l=",0,"energy in left paddle(MeV) ");
   G__memvar_setup((void*)((long)(&p->time_r)-(long)(p)),102,0,0,-1,-1,-1,1,"time_r=",0,"time for right paddle(ns) ");
   G__memvar_setup((void*)((long)(&p->energy_r)-(long)(p)),102,0,0,-1,-1,-1,1,"energy_r=",0,"energy in right paddle(MeV) ");
   G__memvar_setup((void*)((long)(&p->dtime_l)-(long)(p)),102,0,0,-1,-1,-1,1,"dtime_l=",0,"uncertainty in time for left paddle(ns) ");
   G__memvar_setup((void*)((long)(&p->denergy_l)-(long)(p)),102,0,0,-1,-1,-1,1,"denergy_l=",0,"uncertainty in energy in left paddle(MeV) ");
   G__memvar_setup((void*)((long)(&p->dtime_r)-(long)(p)),102,0,0,-1,-1,-1,1,"dtime_r=",0,"uncertainty in time for right paddle(ns) ");
   G__memvar_setup((void*)((long)(&p->denergy_r)-(long)(p)),102,0,0,-1,-1,-1,1,"denergy_r=",0,"uncertainty in energy in right paddle(MeV) ");
   }
   G__tag_memvar_reset();
}


   /* SCC_t */
static void G__setup_memvarSCC_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCC_t));
   { SCC_t *p; p=(SCC_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->id)-(long)(p)),105,0,0,-1,-1,-1,1,"id=",0,"paddle id# ");
   G__memvar_setup((void*)((long)(&p->date)-(long)(p)),105,0,0,-1,-1,-1,1,"date=",0,"UNIX univiersal time of calibraton (32 bits) ");
   G__memvar_setup((void*)((long)(&p->version)-(long)(p)),105,0,0,-1,-1,-1,1,"version=",0,"sequential version# of calibration ");
   G__memvar_setup((void*)((long)(&p->status)-(long)(p)),105,0,0,-1,-1,-1,1,"status=",0,"4 byte status word (see details) ");
   G__memvar_setup((void*)((long)(&p->TD0L)-(long)(p)),102,0,0,-1,-1,-1,1,"TD0L=",0,"(Left) gives 0 time at center for tube (ns) ");
   G__memvar_setup((void*)((long)(&p->TD0Lu)-(long)(p)),102,0,0,-1,-1,-1,1,"TD0Lu=",0,"(Left) uncertainty (ns) ");
   G__memvar_setup((void*)((long)(&p->TD0R)-(long)(p)),102,0,0,-1,-1,-1,1,"TD0R=",0,"(Right) gives 0 time at center for tube (ns) ");
   G__memvar_setup((void*)((long)(&p->TD0Ru)-(long)(p)),102,0,0,-1,-1,-1,1,"TD0Ru=",0,"(Right) uncertainty (ns) ");
   G__memvar_setup((void*)((long)(&p->TD1L)-(long)(p)),102,0,0,-1,-1,-1,1,"TD1L=",0,"(Left) TDC**1 coefficient (ns/ch) ");
   G__memvar_setup((void*)((long)(&p->TD1Lu)-(long)(p)),102,0,0,-1,-1,-1,1,"TD1Lu=",0,"(Left) uncertainty (ns/ch) ");
   G__memvar_setup((void*)((long)(&p->TD1R)-(long)(p)),102,0,0,-1,-1,-1,1,"TD1R=",0,"(Right) TDC**1 coefficient (ns/ch) ");
   G__memvar_setup((void*)((long)(&p->TD1Ru)-(long)(p)),102,0,0,-1,-1,-1,1,"TD1Ru=",0,"(Right) uncertainty (ns/ch) ");
   G__memvar_setup((void*)((long)(&p->TD2L)-(long)(p)),102,0,0,-1,-1,-1,1,"TD2L=",0,"(Left) TDC**2 coefficient ");
   G__memvar_setup((void*)((long)(&p->TD2Lu)-(long)(p)),102,0,0,-1,-1,-1,1,"TD2Lu=",0,"(Left) uncertainty (ns/ch) ");
   G__memvar_setup((void*)((long)(&p->TD2R)-(long)(p)),102,0,0,-1,-1,-1,1,"TD2R=",0,"(Right)TDC**2 coefficient ");
   G__memvar_setup((void*)((long)(&p->TD2Ru)-(long)(p)),102,0,0,-1,-1,-1,1,"TD2Ru=",0,"(Right) uncertainty (ns/ch) ");
   G__memvar_setup((void*)((long)(&p->TW0L)-(long)(p)),102,0,0,-1,-1,-1,1,"TW0L=",0,"(Left) time walk constant (ns) ");
   G__memvar_setup((void*)((long)(&p->TW0Lu)-(long)(p)),102,0,0,-1,-1,-1,1,"TW0Lu=",0,"(Left) uncertainty (ns) ");
   G__memvar_setup((void*)((long)(&p->TW0R)-(long)(p)),102,0,0,-1,-1,-1,1,"TW0R=",0,"(Right) time walk constant (ns) ");
   G__memvar_setup((void*)((long)(&p->TW0Ru)-(long)(p)),102,0,0,-1,-1,-1,1,"TW0Ru=",0,"(Right) uncertainty (ns) ");
   G__memvar_setup((void*)((long)(&p->TW1L)-(long)(p)),102,0,0,-1,-1,-1,1,"TW1L=",0,"(Left) time walk 1st factor ");
   G__memvar_setup((void*)((long)(&p->TW1Lu)-(long)(p)),102,0,0,-1,-1,-1,1,"TW1Lu=",0,"(Left) uncertainty ");
   G__memvar_setup((void*)((long)(&p->TW1R)-(long)(p)),102,0,0,-1,-1,-1,1,"TW1R=",0,"(Right) time walk 1st factor ");
   G__memvar_setup((void*)((long)(&p->TW1Ru)-(long)(p)),102,0,0,-1,-1,-1,1,"TW1Ru=",0,"(Right) uncertainty ");
   G__memvar_setup((void*)((long)(&p->TW2L)-(long)(p)),102,0,0,-1,-1,-1,1,"TW2L=",0,"(Left) time walk 2nd factor ");
   G__memvar_setup((void*)((long)(&p->TW2Lu)-(long)(p)),102,0,0,-1,-1,-1,1,"TW2Lu=",0,"(Left) uncertainty ");
   G__memvar_setup((void*)((long)(&p->TW2R)-(long)(p)),102,0,0,-1,-1,-1,1,"TW2R=",0,"(Right) time walk 2nd factor ");
   G__memvar_setup((void*)((long)(&p->TW2Ru)-(long)(p)),102,0,0,-1,-1,-1,1,"TW2Ru=",0,"(Right) uncertainty ");
   G__memvar_setup((void*)((long)(&p->ADPL)-(long)(p)),102,0,0,-1,-1,-1,1,"ADPL=",0,"(Left) ADC pedestal (ch) ");
   G__memvar_setup((void*)((long)(&p->ADPLu)-(long)(p)),102,0,0,-1,-1,-1,1,"ADPLu=",0,"(Left) uncertainty ");
   G__memvar_setup((void*)((long)(&p->ADPR)-(long)(p)),102,0,0,-1,-1,-1,1,"ADPR=",0,"(Right) ADC pedestal (ch) ");
   G__memvar_setup((void*)((long)(&p->ADPRu)-(long)(p)),102,0,0,-1,-1,-1,1,"ADPRu=",0,"(Right) uncertainty ");
   G__memvar_setup((void*)((long)(&p->M0L)-(long)(p)),102,0,0,-1,-1,-1,1,"M0L=",0,"(Left) nmip adc channel ");
   G__memvar_setup((void*)((long)(&p->M0Lu)-(long)(p)),102,0,0,-1,-1,-1,1,"M0Lu=",0,"(Left) uncertainty (ch) ");
   G__memvar_setup((void*)((long)(&p->M0R)-(long)(p)),102,0,0,-1,-1,-1,1,"M0R=",0,"(Right)nmip adc channel ");
   G__memvar_setup((void*)((long)(&p->M0Ru)-(long)(p)),102,0,0,-1,-1,-1,1,"M0Ru=",0,"(Right) uncertainty(ch) ");
   G__memvar_setup((void*)((long)(&p->VEFL)-(long)(p)),102,0,0,-1,-1,-1,1,"VEFL=",0,"(Left) effective velocity of light (cm/ns) ");
   G__memvar_setup((void*)((long)(&p->VEFLu)-(long)(p)),102,0,0,-1,-1,-1,1,"VEFLu=",0,"(Left) uncertainty (cm/ns) ");
   G__memvar_setup((void*)((long)(&p->VEFR)-(long)(p)),102,0,0,-1,-1,-1,1,"VEFR=",0,"(Right) effective velocity of light (cm/ns) ");
   G__memvar_setup((void*)((long)(&p->VEFRu)-(long)(p)),102,0,0,-1,-1,-1,1,"VEFRu=",0,"(Right) uncertainty (cm/ns) ");
   G__memvar_setup((void*)((long)(&p->ATNL)-(long)(p)),102,0,0,-1,-1,-1,1,"ATNL=",0,"(Left) attenuation length (cm) ");
   G__memvar_setup((void*)((long)(&p->ATNLu)-(long)(p)),102,0,0,-1,-1,-1,1,"ATNLu=",0,"(Left) uncertainty (cm) ");
   G__memvar_setup((void*)((long)(&p->ATNR)-(long)(p)),102,0,0,-1,-1,-1,1,"ATNR=",0,"(Right) attenuation length (cm) ");
   G__memvar_setup((void*)((long)(&p->ATNRu)-(long)(p)),102,0,0,-1,-1,-1,1,"ATNRu=",0,"(Right) uncertainty (cm) ");
   G__memvar_setup((void*)((long)(&p->TSIG0L)-(long)(p)),102,0,0,-1,-1,-1,1,"TSIG0L=",0,"(Left) 1st parameter of measured resolution (ns) ");
   G__memvar_setup((void*)((long)(&p->TSIG0R)-(long)(p)),102,0,0,-1,-1,-1,1,"TSIG0R=",0,"(Right) 1st parameter of measured resolution (ns) ");
   G__memvar_setup((void*)((long)(&p->TSIG1L)-(long)(p)),102,0,0,-1,-1,-1,1,"TSIG1L=",0,"(Left) 2nd parameter of measured resolution ");
   G__memvar_setup((void*)((long)(&p->TSIG1R)-(long)(p)),102,0,0,-1,-1,-1,1,"TSIG1R=",0,"(Right) 2nd parameter of measured resolution ");
   }
   G__tag_memvar_reset();
}


   /* SC_t */
static void G__setup_memvarSC_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SC_t));
   { SC_t *p; p=(SC_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDCL)-(long)(p)),114,0,0,-1,-1,-1,1,"TDCL=",0,"tdc information (channels)");
   G__memvar_setup((void*)((long)(&p->ADCL)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCL=",0,"adc information (channels)");
   G__memvar_setup((void*)((long)(&p->TDCR)-(long)(p)),114,0,0,-1,-1,-1,1,"TDCR=",0,"tdc information (channels)");
   G__memvar_setup((void*)((long)(&p->ADCR)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCR=",0,"adc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* SCDI_t */
static void G__setup_memvarSCDI_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCDI_t));
   { SCDI_t *p; p=(SCDI_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->crate)-(long)(p)),105,0,0,-1,-1,-1,1,"crate=",0,"CAMAC crate number");
   G__memvar_setup((void*)((long)(&p->slot)-(long)(p)),105,0,0,-1,-1,-1,1,"slot=",0,"slot");
   G__memvar_setup((void*)((long)(&p->mask)-(long)(p)),105,0,0,-1,-1,-1,1,"mask=",0,"mask");
   G__memvar_setup((void*)((long)(&p->threshold)-(long)(p)),105,0,0,-1,-1,-1,1,"threshold=",0,"actual threshold value (mV)");
   G__memvar_setup((void*)((long)(&p->width)-(long)(p)),105,0,0,-1,-1,-1,1,"width=",0,"actual width value");
   }
   G__tag_memvar_reset();
}


   /* SCGD_t */
static void G__setup_memvarSCGD_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCGD_t));
   { SCGD_t *p; p=(SCGD_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"paddle # inside the plane (1-23(max))");
   G__memvar_setup((void*)((long)(&p->NORM_Z)-(long)(p)),102,0,0,-1,-1,-1,1,"NORM_Z=",0,"Z(X') coordinate of unit normal to plane");
   G__memvar_setup((void*)((long)(&p->NORM_X)-(long)(p)),102,0,0,-1,-1,-1,1,"NORM_X=",0,"Z(X') coordinate of unit normal to plane");
   G__memvar_setup((void*)((long)(&p->NORM_D)-(long)(p)),102,0,0,-1,-1,-1,1,"NORM_D=",0,"distance to plane along unit vector");
   G__memvar_setup((void*)((long)(&p->ALON_Z)-(long)(p)),102,0,0,-1,-1,-1,1,"ALON_Z=",0,"half width in X direction (along id's)");
   G__memvar_setup((void*)((long)(&p->ALON_X)-(long)(p)),102,0,0,-1,-1,-1,1,"ALON_X=",0,"half length of SC in Y direction");
   G__memvar_setup((void*)((long)(&p->BEG_PD)-(long)(p)),102,0,0,-1,-1,-1,1,"BEG_PD=",0,"begin point of the paddle along id");
   G__memvar_setup((void*)((long)(&p->END_PD)-(long)(p)),102,0,0,-1,-1,-1,1,"END_PD=",0,"end point of the paddle along id");
   G__memvar_setup((void*)((long)(&p->PDL_SH)-(long)(p)),102,0,0,-1,-1,-1,1,"PDL_SH=",0,"shift of the paddle in respect to the Mid Plane");
   G__memvar_setup((void*)((long)(&p->R_BEAM)-(long)(p)),102,0,0,-1,-1,-1,1,"R_BEAM=",0,"distance from the beam to the counte center in M.P.");
   }
   G__tag_memvar_reset();
}


   /* SCG_t */
static void G__setup_memvarSCG_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCG_t));
   { SCG_t *p; p=(SCG_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->id)-(long)(p)),105,0,0,-1,-1,-1,1,"id=",0,"paddle id#");
   G__memvar_setup((void*)((long)(&p->panel)-(long)(p)),105,0,0,-1,-1,-1,1,"panel=",0,"panel number - to which plane (panel) the paddle belongs");
   G__memvar_setup((void*)((long)(&p->Xccw)-(long)(p)),102,0,0,-1,-1,-1,1,"Xccw=",0,"X center of CCW end of paddle in CLAS system");
   G__memvar_setup((void*)((long)(&p->Yccw)-(long)(p)),102,0,0,-1,-1,-1,1,"Yccw=",0,"Y center of CCW end ");
   G__memvar_setup((void*)((long)(&p->Zccw)-(long)(p)),102,0,0,-1,-1,-1,1,"Zccw=",0,"- Z center of CCW end");
   G__memvar_setup((void*)((long)(&p->Xcw)-(long)(p)),102,0,0,-1,-1,-1,1,"Xcw=",0,"X center of CW end ");
   G__memvar_setup((void*)((long)(&p->Ycw)-(long)(p)),102,0,0,-1,-1,-1,1,"Ycw=",0,"Y center of CW end");
   G__memvar_setup((void*)((long)(&p->Zcw)-(long)(p)),102,0,0,-1,-1,-1,1,"Zcw=",0,"- Z center of CW end ");
   G__memvar_setup((void*)((long)(&p->WIDTH)-(long)(p)),102,0,0,-1,-1,-1,1,"WIDTH=",0,"width (cm) (~|| CLAS theta) ");
   G__memvar_setup((void*)((long)(&p->THICK)-(long)(p)),102,0,0,-1,-1,-1,1,"THICK=",0,"thickness (cm) (~|| CLAS r) ");
   G__memvar_setup((void*)((long)(&p->DELTA)-(long)(p)),102,0,0,-1,-1,-1,1,"DELTA=",0,"the difference in length of the higher-theta slab minus the lower-theta slab divided by 4 (cm) ");
   }
   G__tag_memvar_reset();
}


   /* SCH_t */
static void G__setup_memvarSCH_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCH_t));
   { SCH_t *p; p=(SCH_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"x of hit");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y of hit");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z of hit");
   G__memvar_setup((void*)((long)(&p->cx)-(long)(p)),102,0,0,-1,-1,-1,1,"cx=",0,"track x dir cosine");
   G__memvar_setup((void*)((long)(&p->cy)-(long)(p)),102,0,0,-1,-1,-1,1,"cy=",0,"track y dir cosine");
   G__memvar_setup((void*)((long)(&p->cz)-(long)(p)),102,0,0,-1,-1,-1,1,"cz=",0,"track z dir cosine");
   G__memvar_setup((void*)((long)(&p->pmom)-(long)(p)),102,0,0,-1,-1,-1,1,"pmom=",0,"track momentum");
   G__memvar_setup((void*)((long)(&p->track)-(long)(p)),105,0,0,-1,-1,-1,1,"track=",0,"track number");
   G__memvar_setup((void*)((long)(&p->id)-(long)(p)),105,0,0,-1,-1,-1,1,"id=",0,"track PDG id");
   }
   G__tag_memvar_reset();
}


   /* SCMD_t */
static void G__setup_memvarSCMD_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCMD_t));
   { SCMD_t *p; p=(SCMD_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"paddle # ");
   G__memvar_setup((void*)((long)(&p->STATUS)-(long)(p)),105,0,0,-1,-1,-1,1,"STATUS=",0,"general status information ");
   G__memvar_setup((void*)((long)(&p->X_NORM)-(long)(p)),102,0,0,-1,-1,-1,1,"X_NORM=",0,"X of unit vector normal to paddle");
   G__memvar_setup((void*)((long)(&p->Y_NORM)-(long)(p)),102,0,0,-1,-1,-1,1,"Y_NORM=",0,"Y of unit vector normal to paddle");
   G__memvar_setup((void*)((long)(&p->D_NORM)-(long)(p)),102,0,0,-1,-1,-1,1,"D_NORM=",0,"normal distance to paddle plane");
   G__memvar_setup((void*)((long)(&p->X_PANEL)-(long)(p)),102,0,0,-1,-1,-1,1,"X_PANEL=",0,"X of unit vector along the panel");
   G__memvar_setup((void*)((long)(&p->Y_PANEL)-(long)(p)),102,0,0,-1,-1,-1,1,"Y_PANEL=",0,"Y of unit vector along the panel");
   G__memvar_setup((void*)((long)(&p->B_PAD)-(long)(p)),102,0,0,-1,-1,-1,1,"B_PAD=",0,"Begin of paddle along the panel");
   G__memvar_setup((void*)((long)(&p->E_PAD)-(long)(p)),102,0,0,-1,-1,-1,1,"E_PAD=",0,"End of paddle along the panel");
   G__memvar_setup((void*)((long)(&p->TOF)-(long)(p)),102,0,0,-1,-1,-1,1,"TOF=",0,"time of flight (nS)");
   G__memvar_setup((void*)((long)(&p->EDP)-(long)(p)),102,0,0,-1,-1,-1,1,"EDP=",0,"energy deposited (GeV) ");
   G__memvar_setup((void*)((long)(&p->P_TIME)-(long)(p)),102,0,0,-1,-1,-1,1,"P_TIME=",0,"position i.r.t. mid.plane from time");
   G__memvar_setup((void*)((long)(&p->P_ATLN)-(long)(p)),102,0,0,-1,-1,-1,1,"P_ATLN=",0,"position i.r.t. mid.plane from atten.");
   }
   G__tag_memvar_reset();
}


   /* SCMT_t */
static void G__setup_memvarSCMT_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCMT_t));
   { SCMT_t *p; p=(SCMT_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->mean_thr)-(long)(p)),105,0,0,-1,-1,-1,1,"mean_thr=",0,"mean threshold (mV)");
   }
   G__tag_memvar_reset();
}


   /* SCMW_t */
static void G__setup_memvarSCMW_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCMW_t));
   { SCMW_t *p; p=(SCMW_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->mean_width)-(long)(p)),105,0,0,-1,-1,-1,1,"mean_width=",0,"mean threshold width");
   }
   G__tag_memvar_reset();
}


   /* SCPB_t */
static void G__setup_memvarSCPB_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCPB_t));
   { SCPB_t *p; p=(SCPB_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ScPdHt)-(long)(p)),105,0,0,-1,-1,-1,1,"ScPdHt=",0,"10000*sector+100*SC_PD_ID+Hit_ID in SCR ");
   G__memvar_setup((void*)((long)(&p->Edep)-(long)(p)),102,0,0,-1,-1,-1,1,"Edep=",0,"Deposited energy (dE/dX)");
   G__memvar_setup((void*)((long)(&p->Time)-(long)(p)),102,0,0,-1,-1,-1,1,"Time=",0,"measured time ");
   G__memvar_setup((void*)((long)(&p->Path)-(long)(p)),102,0,0,-1,-1,-1,1,"Path=",0,"Path lenght from target");
   G__memvar_setup((void*)((long)(&p->Chi2SC)-(long)(p)),102,0,0,-1,-1,-1,1,"Chi2SC=",0,"Quality measure of geometrical matching");
   G__memvar_setup((void*)((long)(&p->Status)-(long)(p)),105,0,0,-1,-1,-1,1,"Status=",0,"Status word (not defined yet)");
   }
   G__tag_memvar_reset();
}


   /* SCP_t */
static void G__setup_memvarSCP_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCP_t));
   { SCP_t *p; p=(SCP_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->N1x)-(long)(p)),102,0,0,-1,-1,-1,1,"N1x=",0,"x component of outward normal to panel 1");
   G__memvar_setup((void*)((long)(&p->N1y)-(long)(p)),102,0,0,-1,-1,-1,1,"N1y=",0,"y component of outward normal to panel 1");
   G__memvar_setup((void*)((long)(&p->N1z)-(long)(p)),102,0,0,-1,-1,-1,1,"N1z=",0,"z component of outward normal to panel 1");
   G__memvar_setup((void*)((long)(&p->R1n)-(long)(p)),102,0,0,-1,-1,-1,1,"R1n=",0,"min.dist.inner(cm)from origin to panel 1");
   G__memvar_setup((void*)((long)(&p->N2x)-(long)(p)),102,0,0,-1,-1,-1,1,"N2x=",0,"x component of outward normal to panel 2");
   G__memvar_setup((void*)((long)(&p->N2y)-(long)(p)),102,0,0,-1,-1,-1,1,"N2y=",0,"y component of outward normal to panel 2");
   G__memvar_setup((void*)((long)(&p->N2z)-(long)(p)),102,0,0,-1,-1,-1,1,"N2z=",0,"z component of outward normal to panel 2");
   G__memvar_setup((void*)((long)(&p->R2n)-(long)(p)),102,0,0,-1,-1,-1,1,"R2n=",0,"min.dist.inner(cm)from origin to panel 2");
   G__memvar_setup((void*)((long)(&p->N3x)-(long)(p)),102,0,0,-1,-1,-1,1,"N3x=",0,"x component of outward normal to panel 3");
   G__memvar_setup((void*)((long)(&p->N3y)-(long)(p)),102,0,0,-1,-1,-1,1,"N3y=",0,"y component of outward normal to panel 3");
   G__memvar_setup((void*)((long)(&p->N3z)-(long)(p)),102,0,0,-1,-1,-1,1,"N3z=",0,"z component of outward normal to panel 3");
   G__memvar_setup((void*)((long)(&p->R3n)-(long)(p)),102,0,0,-1,-1,-1,1,"R3n=",0,"min.dist.inner(cm)from origin to panel 3");
   G__memvar_setup((void*)((long)(&p->N4x)-(long)(p)),102,0,0,-1,-1,-1,1,"N4x=",0,"x component of outward normal to panel 4");
   G__memvar_setup((void*)((long)(&p->N4y)-(long)(p)),102,0,0,-1,-1,-1,1,"N4y=",0,"y component of outward normal to panel 4");
   G__memvar_setup((void*)((long)(&p->N4z)-(long)(p)),102,0,0,-1,-1,-1,1,"N4z=",0,"z component of outward normal to panel 4");
   G__memvar_setup((void*)((long)(&p->R4n)-(long)(p)),102,0,0,-1,-1,-1,1,"R4n=",0,"min.dist.inner(cm)from origin to panel 4");
   }
   G__tag_memvar_reset();
}


   /* SCPE_t */
static void G__setup_memvarSCPE_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCPE_t));
   { SCPE_t *p; p=(SCPE_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->mean_left)-(long)(p)),105,0,0,-1,-1,-1,1,"mean_left=",0,"left adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->sigma_left)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma_left=",0,"sigma of the pedestal distribution for left adc (channel)");
   G__memvar_setup((void*)((long)(&p->mean_right)-(long)(p)),105,0,0,-1,-1,-1,1,"mean_right=",0,"right adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->sigma_right)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma_right=",0,"sigma of the pedestal distribution for right adc (channel");
   }
   G__tag_memvar_reset();
}


   /* SCPS_t */
static void G__setup_memvarSCPS_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCPS_t));
   { SCPS_t *p; p=(SCPS_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"Plane #(1-6):1-23,24-34,35-39,40-42,43-46,47-48");
   G__memvar_setup((void*)((long)(&p->FIRSTPNUM)-(long)(p)),105,0,0,-1,-1,-1,1,"FIRSTPNUM=",0,"The first paddle number in the plane");
   G__memvar_setup((void*)((long)(&p->LASTPNUM)-(long)(p)),105,0,0,-1,-1,-1,1,"LASTPNUM=",0,"The last paddle number in the plane");
   G__memvar_setup((void*)((long)(&p->DISTANCE)-(long)(p)),102,0,0,-1,-1,-1,1,"DISTANCE=",0,"distance to the center of the plane");
   G__memvar_setup((void*)((long)(&p->BEGALONSHFT)-(long)(p)),102,0,0,-1,-1,-1,1,"BEGALONSHFT=",0,"X-shift of Begin Plane poin along id of SC");
   G__memvar_setup((void*)((long)(&p->ENDALONSHFT)-(long)(p)),102,0,0,-1,-1,-1,1,"ENDALONSHFT=",0,"X-shift of End of Plane poin along id of SC");
   G__memvar_setup((void*)((long)(&p->LENGTHSHFT)-(long)(p)),102,0,0,-1,-1,-1,1,"LENGTHSHFT=",0,"Y-shift of Plane SYS along the SC length");
   G__memvar_setup((void*)((long)(&p->ALONGIDX)-(long)(p)),102,0,0,-1,-1,-1,1,"ALONGIDX=",0,"XP.x direction for width in Sector System");
   G__memvar_setup((void*)((long)(&p->ALONGIDY)-(long)(p)),102,0,0,-1,-1,-1,1,"ALONGIDY=",0,"XP.y direction for width in Sector System");
   G__memvar_setup((void*)((long)(&p->ALONGIDZ)-(long)(p)),102,0,0,-1,-1,-1,1,"ALONGIDZ=",0,"XP.z direction for width in Sector System");
   G__memvar_setup((void*)((long)(&p->SLENGTHX)-(long)(p)),102,0,0,-1,-1,-1,1,"SLENGTHX=",0,"YP.x direction for length in Sector System");
   G__memvar_setup((void*)((long)(&p->SLENGTHY)-(long)(p)),102,0,0,-1,-1,-1,1,"SLENGTHY=",0,"YP.y direction for length in Sector System");
   G__memvar_setup((void*)((long)(&p->SLENGTHZ)-(long)(p)),102,0,0,-1,-1,-1,1,"SLENGTHZ=",0,"YP.z direction for length in Sector System");
   G__memvar_setup((void*)((long)(&p->UNORMALX)-(long)(p)),102,0,0,-1,-1,-1,1,"UNORMALX=",0,"ZP.x direction for thickness in Sector System");
   G__memvar_setup((void*)((long)(&p->UNORMALY)-(long)(p)),102,0,0,-1,-1,-1,1,"UNORMALY=",0,"ZP.y direction for thickness in Sector System");
   G__memvar_setup((void*)((long)(&p->UNORMALZ)-(long)(p)),102,0,0,-1,-1,-1,1,"UNORMALZ=",0,"ZP.z direction for thickness in Sector System");
   }
   G__tag_memvar_reset();
}


   /* SCRC_t */
static void G__setup_memvarSCRC_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCRC_t));
   { SCRC_t *p; p=(SCRC_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->id)-(long)(p)),105,0,0,-1,-1,-1,1,"id=",0,"cluster id   ");
   G__memvar_setup((void*)((long)(&p->energy)-(long)(p)),102,0,0,-1,-1,-1,1,"energy=",0,"cluster Energy (MeV) ");
   G__memvar_setup((void*)((long)(&p->denergy)-(long)(p)),102,0,0,-1,-1,-1,1,"denergy=",0,"error in cluster energy (ns)");
   G__memvar_setup((void*)((long)(&p->time)-(long)(p)),102,0,0,-1,-1,-1,1,"time=",0,"cluster (energy-weighted) time(ns) ");
   G__memvar_setup((void*)((long)(&p->dtime)-(long)(p)),102,0,0,-1,-1,-1,1,"dtime=",0,"error in cluster time (ns)");
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"x position in sector coordinate system ");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y position in sector coordinate system ");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z position in sector coordinate system ");
   G__memvar_setup((void*)((long)(&p->dx)-(long)(p)),102,0,0,-1,-1,-1,1,"dx=",0,"x error in sector coordinate system ");
   G__memvar_setup((void*)((long)(&p->dy)-(long)(p)),102,0,0,-1,-1,-1,1,"dy=",0,"y error in sector coordinate system ");
   G__memvar_setup((void*)((long)(&p->dz)-(long)(p)),102,0,0,-1,-1,-1,1,"dz=",0,"z error in sector coordinate system ");
   G__memvar_setup((void*)((long)(&p->status)-(long)(p)),105,0,0,-1,-1,-1,1,"status=",0,"status word defined in sc.h");
   }
   G__tag_memvar_reset();
}


   /* SCR_t */
static void G__setup_memvarSCR_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCR_t));
   { SCR_t *p; p=(SCR_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->id)-(long)(p)),105,0,0,-1,-1,-1,1,"id=",0,"paddle id  ");
   G__memvar_setup((void*)((long)(&p->energy)-(long)(p)),102,0,0,-1,-1,-1,1,"energy=",0,"Energy (MeV) ");
   G__memvar_setup((void*)((long)(&p->time)-(long)(p)),102,0,0,-1,-1,-1,1,"time=",0,"time(ns)");
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"x position in sector coodinate system ");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y position in sector coodinate system ");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z position in sector coodinate system ");
   G__memvar_setup((void*)((long)(&p->dx)-(long)(p)),102,0,0,-1,-1,-1,1,"dx=",0,"x error in sector coodinate system ");
   G__memvar_setup((void*)((long)(&p->dy)-(long)(p)),102,0,0,-1,-1,-1,1,"dy=",0,"y error in sector coodinate system ");
   G__memvar_setup((void*)((long)(&p->dz)-(long)(p)),102,0,0,-1,-1,-1,1,"dz=",0,"z error in sector coodinate system ");
   G__memvar_setup((void*)((long)(&p->status)-(long)(p)),105,0,0,-1,-1,-1,1,"status=",0,"status word defined in sc.h");
   G__memvar_setup((void*)((long)(&p->denergy)-(long)(p)),102,0,0,-1,-1,-1,1,"denergy=",0,"uncertainty in Energy (MeV) ");
   G__memvar_setup((void*)((long)(&p->dtime)-(long)(p)),102,0,0,-1,-1,-1,1,"dtime=",0,"uncertainty in time (ns) ");
   }
   G__tag_memvar_reset();
}


   /* SCS_t */
static void G__setup_memvarSCS_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCS_t));
   { SCS_t *p; p=(SCS_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->SCS1)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS1=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS2)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS2=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS3)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS3=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS4)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS4=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS5)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS5=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS6)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS6=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS7)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS7=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS8)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS8=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS9)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS9=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS10)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS10=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS11)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS11=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS12)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS12=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS13)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS13=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS14)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS14=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS15)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS15=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS16)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS16=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS17)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS17=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS18)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS18=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS19)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS19=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS20)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS20=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS21)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS21=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS22)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS22=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS23)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS23=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS24)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS24=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS25)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS25=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS26)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS26=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS27)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS27=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS28)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS28=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS29)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS29=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS30)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS30=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS31)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS31=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS32)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS32=",0,"scaler sector 1");
   G__memvar_setup((void*)((long)(&p->SCS33)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS33=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS34)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS34=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS35)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS35=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS36)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS36=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS37)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS37=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS38)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS38=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS39)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS39=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS40)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS40=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS41)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS41=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS42)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS42=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS43)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS43=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS44)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS44=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS45)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS45=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS46)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS46=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS47)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS47=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS48)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS48=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS49)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS49=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS50)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS50=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS51)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS51=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS52)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS52=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS53)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS53=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS54)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS54=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS55)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS55=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS56)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS56=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS57)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS57=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS58)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS58=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS59)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS59=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS60)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS60=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS61)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS61=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS62)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS62=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS63)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS63=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS64)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS64=",0,"scaler sector 2");
   G__memvar_setup((void*)((long)(&p->SCS65)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS65=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS66)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS66=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS67)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS67=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS68)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS68=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS69)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS69=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS70)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS70=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS71)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS71=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS72)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS72=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS73)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS73=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS74)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS74=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS75)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS75=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS76)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS76=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS77)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS77=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS78)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS78=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS79)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS79=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS80)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS80=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS81)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS81=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS82)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS82=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS83)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS83=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS84)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS84=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS85)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS85=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS86)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS86=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS87)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS87=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS88)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS88=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS89)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS89=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS90)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS90=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS91)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS91=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS92)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS92=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS93)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS93=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS94)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS94=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS95)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS95=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS96)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS96=",0,"scaler sector 3");
   G__memvar_setup((void*)((long)(&p->SCS97)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS97=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS98)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS98=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS99)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS99=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS100)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS100=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS101)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS101=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS102)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS102=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS103)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS103=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS104)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS104=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS105)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS105=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS106)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS106=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS107)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS107=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS108)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS108=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS109)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS109=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS110)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS110=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS111)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS111=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS112)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS112=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS113)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS113=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS114)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS114=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS115)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS115=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS116)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS116=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS117)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS117=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS118)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS118=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS119)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS119=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS120)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS120=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS121)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS121=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS122)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS122=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS123)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS123=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS124)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS124=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS125)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS125=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS126)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS126=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS127)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS127=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS128)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS128=",0,"scaler sector 4");
   G__memvar_setup((void*)((long)(&p->SCS129)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS129=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS130)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS130=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS131)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS131=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS132)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS132=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS133)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS133=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS134)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS134=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS135)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS135=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS136)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS136=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS137)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS137=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS138)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS138=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS139)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS139=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS140)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS140=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS141)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS141=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS142)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS142=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS143)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS143=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS144)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS144=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS145)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS145=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS146)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS146=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS147)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS147=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS148)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS148=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS149)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS149=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS150)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS150=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS151)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS151=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS152)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS152=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS153)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS153=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS154)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS154=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS155)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS155=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS156)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS156=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS157)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS157=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS158)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS158=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS159)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS159=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS160)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS160=",0,"scaler sector 5");
   G__memvar_setup((void*)((long)(&p->SCS161)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS161=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS162)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS162=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS163)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS163=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS164)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS164=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS165)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS165=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS166)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS166=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS167)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS167=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS168)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS168=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS169)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS169=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS170)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS170=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS171)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS171=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS172)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS172=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS173)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS173=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS174)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS174=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS175)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS175=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS176)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS176=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS177)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS177=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS178)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS178=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS179)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS179=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS180)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS180=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS181)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS181=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS182)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS182=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS183)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS183=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS184)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS184=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS185)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS185=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS186)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS186=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS187)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS187=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS188)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS188=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS189)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS189=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS190)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS190=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS191)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS191=",0,"scaler sector 6");
   G__memvar_setup((void*)((long)(&p->SCS192)-(long)(p)),105,0,0,-1,-1,-1,1,"SCS192=",0,"scaler sector 6");
   }
   G__tag_memvar_reset();
}


   /* SCT_t */
static void G__setup_memvarSCT_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCT_t));
   { SCT_t *p; p=(SCT_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* SGMP_t */
static void G__setup_memvarSGMP_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SGMP_t));
   { SGMP_t *p; p=(SGMP_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->is)-(long)(p)),105,0,0,-1,-1,-1,1,"is=",0,"superlayer number of the segment");
   G__memvar_setup((void*)((long)(&p->sgm1)-(long)(p)),105,0,0,-1,-1,-1,1,"sgm1=",0,"data structure see: include/bosddl.h, wire_t");
   G__memvar_setup((void*)((long)(&p->sgm2)-(long)(p)),105,0,0,-1,-1,-1,1,"sgm2=",0,"wire_t");
   G__memvar_setup((void*)((long)(&p->sgm3)-(long)(p)),105,0,0,-1,-1,-1,1,"sgm3=",0,"wire_t");
   G__memvar_setup((void*)((long)(&p->sgm4)-(long)(p)),105,0,0,-1,-1,-1,1,"sgm4=",0,"wire_t");
   G__memvar_setup((void*)((long)(&p->sgm5)-(long)(p)),105,0,0,-1,-1,-1,1,"sgm5=",0,"wire_t");
   G__memvar_setup((void*)((long)(&p->sgm6)-(long)(p)),105,0,0,-1,-1,-1,1,"sgm6=",0,"wire_t");
   }
   G__tag_memvar_reset();
}


   /* SPAR_t */
static void G__setup_memvarSPAR_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SPAR_t));
   { SPAR_t *p; p=(SPAR_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->slot)-(long)(p)),105,0,0,-1,-1,-1,1,"slot=",0,"ADC slot");
   G__memvar_setup((void*)((long)(&p->channel)-(long)(p)),105,0,0,-1,-1,-1,1,"channel=",0,"ADC channel");
   G__memvar_setup((void*)((long)(&p->spar)-(long)(p)),105,0,0,-1,-1,-1,1,"spar=",0,"sparsification threshold (channel)");
   G__memvar_setup((void*)((long)(&p->pedmean)-(long)(p)),105,0,0,-1,-1,-1,1,"pedmean=",0,"pedestal mean value measured, using internal 500ns gate (channel)");
   }
   G__tag_memvar_reset();
}


   /* SPIN_t */
static void G__setup_memvarSPIN_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SPIN_t));
   { SPIN_t *p; p=(SPIN_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->xspin)-(long)(p)),105,0,0,-1,-1,-1,1,"xspin=",0,"x component of spin");
   G__memvar_setup((void*)((long)(&p->yspin)-(long)(p)),105,0,0,-1,-1,-1,1,"yspin=",0,"y component of spin");
   G__memvar_setup((void*)((long)(&p->zspin)-(long)(p)),105,0,0,-1,-1,-1,1,"zspin=",0,"z component of spin");
   }
   G__tag_memvar_reset();
}


   /* ST1_t */
static void G__setup_memvarST1_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ST1_t));
   { ST1_t *p; p=(ST1_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"Pair id");
   G__memvar_setup((void*)((long)(&p->status)-(long)(p)),105,0,0,-1,-1,-1,1,"status=",0,"status word");
   G__memvar_setup((void*)((long)(&p->TIME_1)-(long)(p)),102,0,0,-1,-1,-1,1,"TIME_1=",0,"Time (ns) for side 1");
   G__memvar_setup((void*)((long)(&p->ADC_1)-(long)(p)),102,0,0,-1,-1,-1,1,"ADC_1=",0,"Pedestal-subtracted adc for side 1");
   G__memvar_setup((void*)((long)(&p->TIME_2)-(long)(p)),102,0,0,-1,-1,-1,1,"TIME_2=",0,"Time (ns) for side 2");
   G__memvar_setup((void*)((long)(&p->ADC_2)-(long)(p)),102,0,0,-1,-1,-1,1,"ADC_2=",0,"Pedestal-subtracted ADC  for side 2");
   }
   G__tag_memvar_reset();
}


   /* ST_t */
static void G__setup_memvarST_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ST_t));
   { ST_t *p; p=(ST_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels)");
   G__memvar_setup((void*)((long)(&p->ADC)-(long)(p)),114,0,0,-1,-1,-1,1,"ADC=",0,"adc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* STG_t */
static void G__setup_memvarSTG_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STG_t));
   { STG_t *p; p=(STG_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->id)-(long)(p)),105,0,0,-1,-1,-1,1,"id=",0,"sector id");
   G__memvar_setup((void*)((long)(&p->leg_x_max)-(long)(p)),102,0,0,-1,-1,-1,1,"leg_x_max=",0,"distance from beam axis to inner face of leg ");
   G__memvar_setup((void*)((long)(&p->leg_x_min)-(long)(p)),102,0,0,-1,-1,-1,1,"leg_x_min=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->leg_y_max)-(long)(p)),102,0,0,-1,-1,-1,1,"leg_y_max=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->leg_y_min)-(long)(p)),102,0,0,-1,-1,-1,1,"leg_y_min=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->leg_z_max)-(long)(p)),102,0,0,-1,-1,-1,1,"leg_z_max=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->let_z_min)-(long)(p)),102,0,0,-1,-1,-1,1,"let_z_min=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->nose_x_max)-(long)(p)),102,0,0,-1,-1,-1,1,"nose_x_max=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->nose_x_min)-(long)(p)),102,0,0,-1,-1,-1,1,"nose_x_min=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->nose_y_max)-(long)(p)),102,0,0,-1,-1,-1,1,"nose_y_max=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->nose_y_min)-(long)(p)),102,0,0,-1,-1,-1,1,"nose_y_min=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->nose_z_max)-(long)(p)),102,0,0,-1,-1,-1,1,"nose_z_max=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->nose_z_min)-(long)(p)),102,0,0,-1,-1,-1,1,"nose_z_min=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->noseAngle)-(long)(p)),102,0,0,-1,-1,-1,1,"noseAngle=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->lleg)-(long)(p)),102,0,0,-1,-1,-1,1,"lleg=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->lnose)-(long)(p)),102,0,0,-1,-1,-1,1,"lnose=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* STH_t */
static void G__setup_memvarSTH_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STH_t));
   { STH_t *p; p=(STH_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"x of hit");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y of hit");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z of hit");
   G__memvar_setup((void*)((long)(&p->cx)-(long)(p)),102,0,0,-1,-1,-1,1,"cx=",0,"track x dir cosine");
   G__memvar_setup((void*)((long)(&p->cy)-(long)(p)),102,0,0,-1,-1,-1,1,"cy=",0,"track y dir cosine");
   G__memvar_setup((void*)((long)(&p->cz)-(long)(p)),102,0,0,-1,-1,-1,1,"cz=",0,"track z dir cosine");
   G__memvar_setup((void*)((long)(&p->pmom)-(long)(p)),102,0,0,-1,-1,-1,1,"pmom=",0,"track momentum");
   G__memvar_setup((void*)((long)(&p->track)-(long)(p)),105,0,0,-1,-1,-1,1,"track=",0,"track number");
   G__memvar_setup((void*)((long)(&p->id)-(long)(p)),105,0,0,-1,-1,-1,1,"id=",0,"track PDG id");
   G__memvar_setup((void*)((long)(&p->tof)-(long)(p)),102,0,0,-1,-1,-1,1,"tof=",0,"flight time");
   }
   G__tag_memvar_reset();
}


   /* STN0_t */
static void G__setup_memvarSTN0_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STN0_t));
   { STN0_t *p; p=(STN0_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"detector element");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* STN1_t */
static void G__setup_memvarSTN1_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STN1_t));
   { STN1_t *p; p=(STN1_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"detector element ");
   G__memvar_setup((void*)((long)(&p->ADC)-(long)(p)),114,0,0,-1,-1,-1,1,"ADC=",0,"adc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* STPB_t */
static void G__setup_memvarSTPB_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STPB_t));
   { STPB_t *p; p=(STPB_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->SThid)-(long)(p)),105,0,0,-1,-1,-1,1,"SThid=",0,"100*sector+Hit_ID  ");
   G__memvar_setup((void*)((long)(&p->Time)-(long)(p)),102,0,0,-1,-1,-1,1,"Time=",0,"Flight time relative to the evnt start time");
   G__memvar_setup((void*)((long)(&p->Path)-(long)(p)),102,0,0,-1,-1,-1,1,"Path=",0,"Path lenght from target");
   G__memvar_setup((void*)((long)(&p->charge)-(long)(p)),105,0,0,-1,-1,-1,1,"charge=",0,"charge (get from tracking)");
   G__memvar_setup((void*)((long)(&p->Status)-(long)(p)),105,0,0,-1,-1,-1,1,"Status=",0,"Status word (not defined yet)");
   }
   G__tag_memvar_reset();
}


   /* STPE_t */
static void G__setup_memvarSTPE_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STPE_t));
   { STPE_t *p; p=(STPE_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->mean)-(long)(p)),105,0,0,-1,-1,-1,1,"mean=",0,"adc pedestal mean value (channel)");
   G__memvar_setup((void*)((long)(&p->sigma)-(long)(p)),102,0,0,-1,-1,-1,1,"sigma=",0,"sigma of the pedestal distribution (channel)");
   }
   G__tag_memvar_reset();
}


   /* STR_t */
static void G__setup_memvarSTR_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STR_t));
   { STR_t *p; p=(STR_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"sector");
   G__memvar_setup((void*)((long)(&p->Trk_no)-(long)(p)),105,0,0,-1,-1,-1,1,"Trk_no=",0,"Pointer to track in HBTR");
   G__memvar_setup((void*)((long)(&p->ST_TIME)-(long)(p)),102,0,0,-1,-1,-1,1,"ST_TIME=",0,"flight time from ST (ns)");
   G__memvar_setup((void*)((long)(&p->ST_L)-(long)(p)),102,0,0,-1,-1,-1,1,"ST_L=",0,"flight path from ST (cm)");
   G__memvar_setup((void*)((long)(&p->st_pos)-(long)(p)),102,0,0,-1,-1,-1,1,"st_pos=",0,"position within the start counter");
   G__memvar_setup((void*)((long)(&p->status)-(long)(p)),105,0,0,-1,-1,-1,1,"status=",0,"Status word");
   }
   G__tag_memvar_reset();
}


   /* STS_t */
static void G__setup_memvarSTS_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STS_t));
   { STS_t *p; p=(STS_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->STS1)-(long)(p)),105,0,0,-1,-1,-1,1,"STS1=",0,"trigger rate sector 1-2");
   G__memvar_setup((void*)((long)(&p->STS2)-(long)(p)),105,0,0,-1,-1,-1,1,"STS2=",0,"trigger rate sector 3-4");
   G__memvar_setup((void*)((long)(&p->STS3)-(long)(p)),105,0,0,-1,-1,-1,1,"STS3=",0,"trigger rate sector 5-6");
   G__memvar_setup((void*)((long)(&p->STS4)-(long)(p)),105,0,0,-1,-1,-1,1,"STS4=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STS5)-(long)(p)),105,0,0,-1,-1,-1,1,"STS5=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STS6)-(long)(p)),105,0,0,-1,-1,-1,1,"STS6=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STS7)-(long)(p)),105,0,0,-1,-1,-1,1,"STS7=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STS8)-(long)(p)),105,0,0,-1,-1,-1,1,"STS8=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STS9)-(long)(p)),105,0,0,-1,-1,-1,1,"STS9=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STS10)-(long)(p)),105,0,0,-1,-1,-1,1,"STS10=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STS11)-(long)(p)),105,0,0,-1,-1,-1,1,"STS11=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STS12)-(long)(p)),105,0,0,-1,-1,-1,1,"STS12=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STS13)-(long)(p)),105,0,0,-1,-1,-1,1,"STS13=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STS14)-(long)(p)),105,0,0,-1,-1,-1,1,"STS14=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STS15)-(long)(p)),105,0,0,-1,-1,-1,1,"STS15=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STS16)-(long)(p)),105,0,0,-1,-1,-1,1,"STS16=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* STSN_t */
static void G__setup_memvarSTSN_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STSN_t));
   { STSN_t *p; p=(STSN_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->STSN1)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN2)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN3)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN3=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN4)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN4=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN5)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN5=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN6)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN6=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN7)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN7=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN8)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN8=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN9)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN9=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN10)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN10=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN11)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN11=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN12)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN12=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN13)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN13=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN14)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN14=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN15)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN15=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN16)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN16=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN17)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN17=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN18)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN18=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN19)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN19=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN20)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN20=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN21)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN21=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN22)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN22=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN23)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN23=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STSN24)-(long)(p)),105,0,0,-1,-1,-1,1,"STSN24=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STOR)-(long)(p)),105,0,0,-1,-1,-1,1,"STOR=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STMULT)-(long)(p)),105,0,0,-1,-1,-1,1,"STMULT=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->STANDMOR)-(long)(p)),105,0,0,-1,-1,-1,1,"STANDMOR=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->MULTANDMOR)-(long)(p)),105,0,0,-1,-1,-1,1,"MULTANDMOR=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RES1)-(long)(p)),105,0,0,-1,-1,-1,1,"RES1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RES2)-(long)(p)),105,0,0,-1,-1,-1,1,"RES2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RES3)-(long)(p)),105,0,0,-1,-1,-1,1,"RES3=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RES4)-(long)(p)),105,0,0,-1,-1,-1,1,"RES4=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* SYNC_t */
static void G__setup_memvarSYNC_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SYNC_t));
   { SYNC_t *p; p=(SYNC_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"slot number");
   G__memvar_setup((void*)((long)(&p->TDCL)-(long)(p)),114,0,0,-1,-1,-1,1,"TDCL=",0,"count of missing responses");
   G__memvar_setup((void*)((long)(&p->ADCL)-(long)(p)),114,0,0,-1,-1,-1,1,"ADCL=",0,"count of extra buffers");
   }
   G__tag_memvar_reset();
}


   /* TACO_t */
static void G__setup_memvarTACO_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TACO_t));
   { TACO_t *p; p=(TACO_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"ID  1= TAC, 2 = USLG");
   G__memvar_setup((void*)((long)(&p->TIME)-(long)(p)),102,0,0,-1,-1,-1,1,"TIME=",0,"TDC time ");
   G__memvar_setup((void*)((long)(&p->ELT)-(long)(p)),102,0,0,-1,-1,-1,1,"ELT=",0,"energy deposit TAC = left top");
   G__memvar_setup((void*)((long)(&p->ERT)-(long)(p)),102,0,0,-1,-1,-1,1,"ERT=",0,"energy deposit TAC = right top");
   G__memvar_setup((void*)((long)(&p->ELB)-(long)(p)),102,0,0,-1,-1,-1,1,"ELB=",0,"energy deposit TAC = left bottom");
   G__memvar_setup((void*)((long)(&p->ERB)-(long)(p)),102,0,0,-1,-1,-1,1,"ERB=",0,"energy deposit TAC = right bottom");
   G__memvar_setup((void*)((long)(&p->ESUM)-(long)(p)),102,0,0,-1,-1,-1,1,"ESUM=",0,"energy deposit TAC = sum1");
   G__memvar_setup((void*)((long)(&p->ESUM2)-(long)(p)),102,0,0,-1,-1,-1,1,"ESUM2=",0,"energy deposit TAC = sum2");
   G__memvar_setup((void*)((long)(&p->ESUM3)-(long)(p)),102,0,0,-1,-1,-1,1,"ESUM3=",0,"energy deposit TAC = sum3");
   G__memvar_setup((void*)((long)(&p->TID)-(long)(p)),105,0,0,-1,-1,-1,1,"TID=",0,"T id of the corresponding T");
   }
   G__tag_memvar_reset();
}


   /* TAGE_t */
static void G__setup_memvarTAGE_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TAGE_t));
   { TAGE_t *p; p=(TAGE_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels) [multihit tdc]");
   }
   G__tag_memvar_reset();
}


   /* TAGI_t */
static void G__setup_memvarTAGI_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TAGI_t));
   { TAGI_t *p; p=(TAGI_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->IDT)-(long)(p)),105,0,0,-1,-1,-1,1,"IDT=",0,"T id");
   G__memvar_setup((void*)((long)(&p->TIMEL)-(long)(p)),102,0,0,-1,-1,-1,1,"TIMEL=",0,"time information (Left counters channels)");
   G__memvar_setup((void*)((long)(&p->TIMER)-(long)(p)),102,0,0,-1,-1,-1,1,"TIMER=",0,"time information (Right counters channels)");
   G__memvar_setup((void*)((long)(&p->IDE)-(long)(p)),105,0,0,-1,-1,-1,1,"IDE=",0,"E id");
   G__memvar_setup((void*)((long)(&p->TIMEE)-(long)(p)),102,0,0,-1,-1,-1,1,"TIMEE=",0,"time information (E counters)");
   G__memvar_setup((void*)((long)(&p->TIMEMEAN)-(long)(p)),102,0,0,-1,-1,-1,1,"TIMEMEAN=",0,"time information (left/right mean value | after alignement)");
   G__memvar_setup((void*)((long)(&p->TRF)-(long)(p)),102,0,0,-1,-1,-1,1,"TRF=",0,"time information (mean val - RF | after alignement)");
   G__memvar_setup((void*)((long)(&p->NEXTTIME)-(long)(p)),102,0,0,-1,-1,-1,1,"NEXTTIME=",0,"time difference with the next T when in coincidence | after alignment)");
   }
   G__tag_memvar_reset();
}


   /* TAGM_t */
static void G__setup_memvarTAGM_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TAGM_t));
   { TAGM_t *p; p=(TAGM_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->energy)-(long)(p)),102,0,0,-1,-1,-1,1,"energy=",0,"Energy of the photon in GeV");
   G__memvar_setup((void*)((long)(&p->t)-(long)(p)),102,0,0,-1,-1,-1,1,"t=",0,"T-counter time (ns)");
   G__memvar_setup((void*)((long)(&p->e_t)-(long)(p)),102,0,0,-1,-1,-1,1,"e_t=",0,"E-counter time (ns)");
   G__memvar_setup((void*)((long)(&p->status)-(long)(p)),105,0,0,-1,-1,-1,1,"status=",0,"Status (not yet used) ");
   G__memvar_setup((void*)((long)(&p->tid)-(long)(p)),105,0,0,-1,-1,-1,1,"tid=",0,"T channel Id");
   G__memvar_setup((void*)((long)(&p->eid)-(long)(p)),105,0,0,-1,-1,-1,1,"eid=",0,"E channel Id");
   }
   G__tag_memvar_reset();
}


   /* TAGR_t */
static void G__setup_memvarTAGR_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TAGR_t));
   { TAGR_t *p; p=(TAGR_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ERG)-(long)(p)),102,0,0,-1,-1,-1,1,"ERG=",0,"Energy of the photon in GeV");
   G__memvar_setup((void*)((long)(&p->TTAG)-(long)(p)),102,0,0,-1,-1,-1,1,"TTAG=",0,"Time of the photon has reconstructed in the Tagger");
   G__memvar_setup((void*)((long)(&p->TPHO)-(long)(p)),102,0,0,-1,-1,-1,1,"TPHO=",0,"Time of the photon after RF correction");
   G__memvar_setup((void*)((long)(&p->STAT)-(long)(p)),105,0,0,-1,-1,-1,1,"STAT=",0,"Status ( 7 or 15 are Good) other values have problems (see tag_process_TAGR.F) ");
   G__memvar_setup((void*)((long)(&p->T_id)-(long)(p)),105,0,0,-1,-1,-1,1,"T_id=",0,"T counter Id");
   G__memvar_setup((void*)((long)(&p->E_id)-(long)(p)),105,0,0,-1,-1,-1,1,"E_id=",0,"E counter Id");
   }
   G__tag_memvar_reset();
}


   /* TAGT_t */
static void G__setup_memvarTAGT_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TAGT_t));
   { TAGT_t *p; p=(TAGT_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDCL)-(long)(p)),114,0,0,-1,-1,-1,1,"TDCL=",0,"tdc information (Left counters channels)");
   G__memvar_setup((void*)((long)(&p->TDCR)-(long)(p)),114,0,0,-1,-1,-1,1,"TDCR=",0,"tdc information (Right counters channels)");
   }
   G__tag_memvar_reset();
}


   /* TATL_t */
static void G__setup_memvarTATL_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TATL_t));
   { TATL_t *p; p=(TATL_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),105,0,0,-1,-1,-1,1,"TDC=",0,"tdc information");
   }
   G__tag_memvar_reset();
}


   /* TATR_t */
static void G__setup_memvarTATR_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TATR_t));
   { TATR_t *p; p=(TATR_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),105,0,0,-1,-1,-1,1,"TDC=",0,"tdc information");
   }
   G__tag_memvar_reset();
}


   /* TBER_t */
static void G__setup_memvarTBER_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TBER_t));
   { TBER_t *p; p=(TBER_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->q_over_p)-(long)(p)),102,0,0,-1,-1,-1,1,"q_over_p=",0,"q/p");
   G__memvar_setup((void*)((long)(&p->lambda)-(long)(p)),102,0,0,-1,-1,-1,1,"lambda=",0,"dip angle (pi/2 - theta)");
   G__memvar_setup((void*)((long)(&p->phi)-(long)(p)),102,0,0,-1,-1,-1,1,"phi=",0,"phi");
   G__memvar_setup((void*)((long)(&p->d0)-(long)(p)),102,0,0,-1,-1,-1,1,"d0=",0,"min.distance from (x=0,y=0,z=?)  [cm]");
   G__memvar_setup((void*)((long)(&p->z0)-(long)(p)),102,0,0,-1,-1,-1,1,"z0=",0,"z position of starting point     [cm] ");
   G__memvar_setup((void*)((long)(&p->c11)-(long)(p)),102,0,0,-1,-1,-1,1,"c11=",0,"element C{1,1}");
   G__memvar_setup((void*)((long)(&p->c12)-(long)(p)),102,0,0,-1,-1,-1,1,"c12=",0,"element C{1,2}");
   G__memvar_setup((void*)((long)(&p->c13)-(long)(p)),102,0,0,-1,-1,-1,1,"c13=",0,"element C{1,3}");
   G__memvar_setup((void*)((long)(&p->c14)-(long)(p)),102,0,0,-1,-1,-1,1,"c14=",0,"element C{1,4}");
   G__memvar_setup((void*)((long)(&p->c15)-(long)(p)),102,0,0,-1,-1,-1,1,"c15=",0,"element C{1,5}");
   G__memvar_setup((void*)((long)(&p->c22)-(long)(p)),102,0,0,-1,-1,-1,1,"c22=",0,"element C{2,2}");
   G__memvar_setup((void*)((long)(&p->c23)-(long)(p)),102,0,0,-1,-1,-1,1,"c23=",0,"element C{2,3}");
   G__memvar_setup((void*)((long)(&p->c24)-(long)(p)),102,0,0,-1,-1,-1,1,"c24=",0,"element C{2,4}");
   G__memvar_setup((void*)((long)(&p->c25)-(long)(p)),102,0,0,-1,-1,-1,1,"c25=",0,"element C{2,5}");
   G__memvar_setup((void*)((long)(&p->c33)-(long)(p)),102,0,0,-1,-1,-1,1,"c33=",0,"element C{3,3}");
   G__memvar_setup((void*)((long)(&p->c34)-(long)(p)),102,0,0,-1,-1,-1,1,"c34=",0,"element C{3,4}");
   G__memvar_setup((void*)((long)(&p->c35)-(long)(p)),102,0,0,-1,-1,-1,1,"c35=",0,"element C{3,5}");
   G__memvar_setup((void*)((long)(&p->c44)-(long)(p)),102,0,0,-1,-1,-1,1,"c44=",0,"element C{4,4}");
   G__memvar_setup((void*)((long)(&p->c45)-(long)(p)),102,0,0,-1,-1,-1,1,"c45=",0,"element C{4,5}");
   G__memvar_setup((void*)((long)(&p->c55)-(long)(p)),102,0,0,-1,-1,-1,1,"c55=",0,"element C{5,5}");
   G__memvar_setup((void*)((long)(&p->chi2)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2=",0,"Chisquare for this Track");
   G__memvar_setup((void*)((long)(&p->layinfo1)-(long)(p)),105,0,0,-1,-1,-1,1,"layinfo1=",0,"layerhit info");
   G__memvar_setup((void*)((long)(&p->layinfo2)-(long)(p)),105,0,0,-1,-1,-1,1,"layinfo2=",0,"layerhit info&sector&track#in hber");
   }
   G__tag_memvar_reset();
}


   /* TBID_t */
static void G__setup_memvarTBID_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TBID_t));
   { TBID_t *p; p=(TBID_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->track)-(long)(p)),105,0,0,-1,-1,-1,1,"track=",0,"Track (index to TBTR) or zero if neutral");
   G__memvar_setup((void*)((long)(&p->sec)-(long)(p)),105,0,0,-1,-1,-1,1,"sec=",0,"Sector track is in");
   G__memvar_setup((void*)((long)(&p->beta)-(long)(p)),102,0,0,-1,-1,-1,1,"beta=",0,"Beta of the track in units of c");
   G__memvar_setup((void*)((long)(&p->vtime)-(long)(p)),102,0,0,-1,-1,-1,1,"vtime=",0,"vertex time of track");
   G__memvar_setup((void*)((long)(&p->sc_stat)-(long)(p)),105,0,0,-1,-1,-1,1,"sc_stat=",0,"status of hit matching to SC: see sc.h");
   G__memvar_setup((void*)((long)(&p->sc_id)-(long)(p)),105,0,0,-1,-1,-1,1,"sc_id=",0,"Pointer to SCRC bank");
   G__memvar_setup((void*)((long)(&p->sc_time)-(long)(p)),102,0,0,-1,-1,-1,1,"sc_time=",0,"SC calibrated time for this track (ns)");
   G__memvar_setup((void*)((long)(&p->sc_qual)-(long)(p)),102,0,0,-1,-1,-1,1,"sc_qual=",0,"quality of match for SC");
   G__memvar_setup((void*)((long)(&p->sc_vtime)-(long)(p)),102,0,0,-1,-1,-1,1,"sc_vtime=",0,"time at vertex for SC(ns)");
   G__memvar_setup((void*)((long)(&p->sc_beta)-(long)(p)),102,0,0,-1,-1,-1,1,"sc_beta=",0,"Beta calculated from TOF from SC");
   G__memvar_setup((void*)((long)(&p->cc_stat)-(long)(p)),105,0,0,-1,-1,-1,1,"cc_stat=",0,"status of hit matching to CC: see sc.h");
   G__memvar_setup((void*)((long)(&p->cc_id)-(long)(p)),105,0,0,-1,-1,-1,1,"cc_id=",0,"pointer to CC01 bank");
   G__memvar_setup((void*)((long)(&p->cc_time)-(long)(p)),102,0,0,-1,-1,-1,1,"cc_time=",0,"CC calibrated time for this track (ns)");
   G__memvar_setup((void*)((long)(&p->cc_qual)-(long)(p)),102,0,0,-1,-1,-1,1,"cc_qual=",0,"quality of match for CC");
   G__memvar_setup((void*)((long)(&p->cc_vtime)-(long)(p)),102,0,0,-1,-1,-1,1,"cc_vtime=",0,"time at vertex for CC(ns)");
   G__memvar_setup((void*)((long)(&p->cc_beta)-(long)(p)),102,0,0,-1,-1,-1,1,"cc_beta=",0,"Beta as calculated by the EC");
   G__memvar_setup((void*)((long)(&p->ec_stat)-(long)(p)),105,0,0,-1,-1,-1,1,"ec_stat=",0,"status of hit matching to ec: see sc.h");
   G__memvar_setup((void*)((long)(&p->ec_id)-(long)(p)),105,0,0,-1,-1,-1,1,"ec_id=",0,"Pointer to ECHB bank");
   G__memvar_setup((void*)((long)(&p->ec_time)-(long)(p)),102,0,0,-1,-1,-1,1,"ec_time=",0,"EC calibrated time for this track (ns)");
   G__memvar_setup((void*)((long)(&p->ec_qual)-(long)(p)),102,0,0,-1,-1,-1,1,"ec_qual=",0,"EC quality factor");
   G__memvar_setup((void*)((long)(&p->ec_vtime)-(long)(p)),102,0,0,-1,-1,-1,1,"ec_vtime=",0,"time at vertex for EC(ns)");
   G__memvar_setup((void*)((long)(&p->ec_beta)-(long)(p)),102,0,0,-1,-1,-1,1,"ec_beta=",0,"Beta as calculated by the EC");
   G__memvar_setup((void*)((long)(&p->st_stat)-(long)(p)),105,0,0,-1,-1,-1,1,"st_stat=",0,"status of hit matching to ST");
   G__memvar_setup((void*)((long)(&p->st_id)-(long)(p)),105,0,0,-1,-1,-1,1,"st_id=",0,"Pointer to STR bank");
   G__memvar_setup((void*)((long)(&p->st_time)-(long)(p)),102,0,0,-1,-1,-1,1,"st_time=",0,"ST calibrated time for this track (ns)");
   G__memvar_setup((void*)((long)(&p->st_qual)-(long)(p)),102,0,0,-1,-1,-1,1,"st_qual=",0,"ST quality factor");
   G__memvar_setup((void*)((long)(&p->st_vtime)-(long)(p)),102,0,0,-1,-1,-1,1,"st_vtime=",0,"time at vertex for ST(ns)");
   G__memvar_setup((void*)((long)(&p->st_beta)-(long)(p)),102,0,0,-1,-1,-1,1,"st_beta=",0,"Beta as calculated by the ST");
   G__memvar_setup((void*)((long)(&p->lac_stat)-(long)(p)),105,0,0,-1,-1,-1,1,"lac_stat=",0,"status of hit matching to LAC");
   G__memvar_setup((void*)((long)(&p->lac_id)-(long)(p)),105,0,0,-1,-1,-1,1,"lac_id=",0,"Pointer to EC1R bank");
   G__memvar_setup((void*)((long)(&p->lac_time)-(long)(p)),102,0,0,-1,-1,-1,1,"lac_time=",0,"LAC calibrated time for this track (ns)");
   G__memvar_setup((void*)((long)(&p->lac_qual)-(long)(p)),102,0,0,-1,-1,-1,1,"lac_qual=",0,"LAC quality factor");
   G__memvar_setup((void*)((long)(&p->lac_vtime)-(long)(p)),102,0,0,-1,-1,-1,1,"lac_vtime=",0,"time at vertex for LAC(ns)");
   G__memvar_setup((void*)((long)(&p->lac_beta)-(long)(p)),102,0,0,-1,-1,-1,1,"lac_beta=",0,"Beta as calculated by the LAC");
   }
   G__tag_memvar_reset();
}


   /* TBLA_t */
static void G__setup_memvarTBLA_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TBLA_t));
   { TBLA_t *p; p=(TBLA_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->trk_pln)-(long)(p)),105,0,0,-1,-1,-1,1,"trk_pln=",0,"(track_number) *100 + Trk_plane_number");
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"z coord [cm]  for track in this plane");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y coord [cm]  for track in this plane");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z coord [cm]  for track in this plane");
   G__memvar_setup((void*)((long)(&p->Bx)-(long)(p)),102,0,0,-1,-1,-1,1,"Bx=",0,"B-field in x [kG] at coord.{x,y,z}");
   G__memvar_setup((void*)((long)(&p->By)-(long)(p)),102,0,0,-1,-1,-1,1,"By=",0,"B-field in y [kG] at coord.{x,y,z}");
   G__memvar_setup((void*)((long)(&p->Bz)-(long)(p)),102,0,0,-1,-1,-1,1,"Bz=",0,"B-field in z [kG] at coord.{x,y,z}");
   G__memvar_setup((void*)((long)(&p->tlen)-(long)(p)),102,0,0,-1,-1,-1,1,"tlen=",0,"track length [cm] from origin to this plane");
   G__memvar_setup((void*)((long)(&p->dc1)-(long)(p)),105,0,0,-1,-1,-1,1,"dc1=",0,"Pointer to DC1 bank");
   G__memvar_setup((void*)((long)(&p->stat)-(long)(p)),105,0,0,-1,-1,-1,1,"stat=",0,"Status of the hit");
   G__memvar_setup((void*)((long)(&p->wire)-(long)(p)),105,0,0,-1,-1,-1,1,"wire=",0,"Wire number ");
   G__memvar_setup((void*)((long)(&p->dtime)-(long)(p)),102,0,0,-1,-1,-1,1,"dtime=",0,"drift time  [ns]");
   G__memvar_setup((void*)((long)(&p->alpha)-(long)(p)),102,0,0,-1,-1,-1,1,"alpha=",0,"track angle (relative to R of SL) [deg]");
   G__memvar_setup((void*)((long)(&p->wlen)-(long)(p)),102,0,0,-1,-1,-1,1,"wlen=",0,"Wire length (hit pos. to preamp)  [cm]");
   G__memvar_setup((void*)((long)(&p->sgdoca)-(long)(p)),102,0,0,-1,-1,-1,1,"sgdoca=",0,"sigma DOCA  [cm]");
   G__memvar_setup((void*)((long)(&p->fitdoca)-(long)(p)),102,0,0,-1,-1,-1,1,"fitdoca=",0,"Fitted DOCA [cm]");
   G__memvar_setup((void*)((long)(&p->calcdoca)-(long)(p)),102,0,0,-1,-1,-1,1,"calcdoca=",0,"calculated DOCA (via dtime)  [cm]");
   }
   G__tag_memvar_reset();
}


   /* TBTR_t */
static void G__setup_memvarTBTR_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TBTR_t));
   { TBTR_t *p; p=(TBTR_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"x");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y 'Vertex' position {x,y,z}");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z");
   G__memvar_setup((void*)((long)(&p->px)-(long)(p)),102,0,0,-1,-1,-1,1,"px=",0,"Px");
   G__memvar_setup((void*)((long)(&p->py)-(long)(p)),102,0,0,-1,-1,-1,1,"py=",0,"Py  momentum at 'vertex' {Px,Py,Pz}");
   G__memvar_setup((void*)((long)(&p->pz)-(long)(p)),102,0,0,-1,-1,-1,1,"pz=",0,"Pz");
   G__memvar_setup((void*)((long)(&p->q)-(long)(p)),102,0,0,-1,-1,-1,1,"q=",0,"charge   (straight tracks: set q=0.) ");
   G__memvar_setup((void*)((long)(&p->chi2)-(long)(p)),102,0,0,-1,-1,-1,1,"chi2=",0,"Chisquare for this Track");
   G__memvar_setup((void*)((long)(&p->itr_sec)-(long)(p)),105,0,0,-1,-1,-1,1,"itr_sec=",0,"Trackno_in_Sector + Sector*100");
   G__memvar_setup((void*)((long)(&p->itr_hbt)-(long)(p)),105,0,0,-1,-1,-1,1,"itr_hbt=",0,"Trackno in HBTR for this track");
   }
   G__tag_memvar_reset();
}


   /* TCSB_t */
static void G__setup_memvarTCSB_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TCSB_t));
   { TCSB_t *p; p=(TCSB_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->xpos)-(long)(p)),102,0,0,-1,-1,-1,1,"xpos=",0,"x misalignment of TCS in HCS 		 ");
   G__memvar_setup((void*)((long)(&p->ypos)-(long)(p)),102,0,0,-1,-1,-1,1,"ypos=",0,"y misalignment of TCS in HCS	 ");
   G__memvar_setup((void*)((long)(&p->zpos)-(long)(p)),102,0,0,-1,-1,-1,1,"zpos=",0,"z misalignment of TCS in HCS	 ");
   G__memvar_setup((void*)((long)(&p->sxpos)-(long)(p)),102,0,0,-1,-1,-1,1,"sxpos=",0,"sx sine of x-axis misorientation of TCS vs HCS		 ");
   G__memvar_setup((void*)((long)(&p->sypos)-(long)(p)),102,0,0,-1,-1,-1,1,"sypos=",0,"sy sine of y-axis misorientation of TCS vs HCS");
   G__memvar_setup((void*)((long)(&p->szpos)-(long)(p)),102,0,0,-1,-1,-1,1,"szpos=",0,"sz sine of z-axis misorientation of TCS vs HCS");
   }
   G__tag_memvar_reset();
}


   /* TCT_t */
static void G__setup_memvarTCT_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TCT_t));
   { TCT_t *p; p=(TCT_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"id");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information (channels)");
   }
   G__tag_memvar_reset();
}


   /* TDPL_t */
static void G__setup_memvarTDPL_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TDPL_t));
   { TDPL_t *p; p=(TDPL_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->trk_pln)-(long)(p)),105,0,0,-1,-1,-1,1,"trk_pln=",0,"(track_number) *100 + plane_number");
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"vector3_t pos;");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"(x, y, z coord. for track in on the plane)");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cx)-(long)(p)),102,0,0,-1,-1,-1,1,"cx=",0,"vector3_t dir;");
   G__memvar_setup((void*)((long)(&p->cy)-(long)(p)),102,0,0,-1,-1,-1,1,"cy=",0,"direction cosines (x,y,z) for track at coord.{x,y,z}");
   G__memvar_setup((void*)((long)(&p->cz)-(long)(p)),102,0,0,-1,-1,-1,1,"cz=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->tlen)-(long)(p)),102,0,0,-1,-1,-1,1,"tlen=",0,"track length [cm] from origin to this plane");
   }
   G__tag_memvar_reset();
}


   /* TESC_t */
static void G__setup_memvarTESC_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TESC_t));
   { TESC_t *p; p=(TESC_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->value)-(long)(p)),102,0,0,-1,-1,-1,1,"value=",0,"count rate per E-counter channel");
   }
   G__tag_memvar_reset();
}


   /* TGBI_t */
static void G__setup_memvarTGBI_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TGBI_t));
   { TGBI_t *p; p=(TGBI_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->latch1)-(long)(p)),104,0,0,-1,-1,-1,1,"latch1=",0,"level1 trigger latch word (16 bits)");
   G__memvar_setup((void*)((long)(&p->helicity_scaler)-(long)(p)),104,0,0,-1,-1,-1,1,"helicity_scaler=",0,"helicity interval count");
   G__memvar_setup((void*)((long)(&p->interrupt_time)-(long)(p)),104,0,0,-1,-1,-1,1,"interrupt_time=",0,"interrupt time from microsec clock");
   G__memvar_setup((void*)((long)(&p->latch2)-(long)(p)),104,0,0,-1,-1,-1,1,"latch2=",0,"level2 trigger latch word (16 bits)");
   G__memvar_setup((void*)((long)(&p->level3)-(long)(p)),104,0,0,-1,-1,-1,1,"level3=",0,"level3 trigger word (32 bits)");
   }
   G__tag_memvar_reset();
}


   /* TGEO_t */
static void G__setup_memvarTGEO_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TGEO_t));
   { TGEO_t *p; p=(TGEO_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"X position of target");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"Y position of target");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"Z position of target");
   G__memvar_setup((void*)((long)(&p->radius)-(long)(p)),102,0,0,-1,-1,-1,1,"radius=",0,"radius of target");
   G__memvar_setup((void*)((long)(&p->length)-(long)(p)),102,0,0,-1,-1,-1,1,"length=",0,"lenght of target");
   G__memvar_setup((void*)((long)(&p->material)-(long)(p)),105,0,0,-1,-1,-1,1,"material=",0,"material of target: 0=empty; 1=Hydrogen; ");
   }
   G__tag_memvar_reset();
}


   /* TGPB_t */
static void G__setup_memvarTGPB_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TGPB_t));
   { TGPB_t *p; p=(TGPB_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->pointer)-(long)(p)),105,0,0,-1,-1,-1,1,"pointer=",0,"1000*i+tagstat where \"i\" is the pointer to the TAGR bank. Negative for trigger photon  ");
   G__memvar_setup((void*)((long)(&p->Time)-(long)(p)),102,0,0,-1,-1,-1,1,"Time=",0,"starttime_TAG at interaction point(ns)");
   G__memvar_setup((void*)((long)(&p->Energy)-(long)(p)),102,0,0,-1,-1,-1,1,"Energy=",0,"photon energy(GeV)");
   G__memvar_setup((void*)((long)(&p->dt)-(long)(p)),102,0,0,-1,-1,-1,1,"dt=",0,"starttime_ST - starttime_TAG (ns)");
   }
   G__tag_memvar_reset();
}


   /* TGS_t */
static void G__setup_memvarTGS_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TGS_t));
   { TGS_t *p; p=(TGS_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->RAWT1)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT2)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT3)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT3=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT4)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT4=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT5)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT5=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT6)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT6=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT7)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT7=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT8)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT8=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT9)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT9=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT10)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT10=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT11)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT11=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT12)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT12=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT13)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT13=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT14)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT14=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT15)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT15=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT16)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT16=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT17)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT17=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT18)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT18=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT19)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT19=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT20)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT20=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT21)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT21=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT22)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT22=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT23)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT23=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT24)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT24=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT25)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT25=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT26)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT26=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT27)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT27=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT28)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT28=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT29)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT29=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT30)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT30=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT31)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT31=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT32)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT32=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT33)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT33=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT34)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT34=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT35)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT35=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT36)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT36=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT37)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT37=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT38)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT38=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT39)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT39=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT40)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT40=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT41)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT41=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT42)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT42=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT43)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT43=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT44)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT44=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT45)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT45=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT46)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT46=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT47)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT47=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT48)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT48=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT49)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT49=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT50)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT50=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT51)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT51=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT52)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT52=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT53)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT53=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT54)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT54=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT55)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT55=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT56)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT56=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT57)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT57=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT58)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT58=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT59)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT59=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT60)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT60=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RAWT61)-(long)(p)),105,0,0,-1,-1,-1,1,"RAWT61=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->notused62)-(long)(p)),105,0,0,-1,-1,-1,1,"notused62=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->notused63)-(long)(p)),105,0,0,-1,-1,-1,1,"notused63=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->notused64)-(long)(p)),105,0,0,-1,-1,-1,1,"notused64=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T1)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T2)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T3)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T3=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T4)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T4=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T5)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T5=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T6)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T6=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T7)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T7=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T8)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T8=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T9)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T9=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T10)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T10=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T11)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T11=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T12)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T12=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T13)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T13=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T14)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T14=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T15)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T15=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T16)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T16=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T17)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T17=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T18)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T18=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T19)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T19=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T20)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T20=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T21)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T21=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T22)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T22=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T23)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T23=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T24)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T24=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T25)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T25=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T26)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T26=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T27)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T27=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T28)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T28=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T29)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T29=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T30)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T30=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T31)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T31=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T32)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T32=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T33)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T33=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T34)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T34=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T35)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T35=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T36)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T36=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T37)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T37=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T38)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T38=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T39)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T39=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T40)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T40=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T41)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T41=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T42)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T42=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T43)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T43=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T44)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T44=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T45)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T45=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T46)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T46=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T47)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T47=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T48)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T48=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T49)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T49=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T50)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T50=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T51)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T51=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T52)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T52=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T53)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T53=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T54)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T54=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T55)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T55=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T56)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T56=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T57)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T57=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T58)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T58=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T59)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T59=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T60)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T60=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK1T61)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK1T61=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->notused126)-(long)(p)),105,0,0,-1,-1,-1,1,"notused126=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->notused127)-(long)(p)),105,0,0,-1,-1,-1,1,"notused127=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->notused128)-(long)(p)),105,0,0,-1,-1,-1,1,"notused128=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T1)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T2)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T3)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T3=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T4)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T4=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T5)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T5=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T6)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T6=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T7)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T7=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T8)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T8=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T9)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T9=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T10)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T10=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T11)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T11=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T12)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T12=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T13)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T13=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T14)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T14=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T15)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T15=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T16)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T16=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T17)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T17=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T18)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T18=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T19)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T19=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T20)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T20=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T21)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T21=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T22)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T22=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T23)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T23=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T24)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T24=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T25)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T25=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T26)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T26=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T27)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T27=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T28)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T28=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T29)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T29=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T30)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T30=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T31)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T31=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T32)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T32=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T33)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T33=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T34)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T34=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T35)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T35=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T36)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T36=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T37)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T37=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T38)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T38=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T39)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T39=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T40)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T40=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T41)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T41=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T42)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T42=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T43)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T43=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T44)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T44=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T45)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T45=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T46)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T46=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T47)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T47=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T48)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T48=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T49)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T49=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T50)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T50=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T51)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T51=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T52)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T52=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T53)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T53=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T54)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T54=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T55)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T55=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T56)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T56=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T57)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T57=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T58)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T58=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T59)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T59=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T60)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T60=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BNK2T61)-(long)(p)),105,0,0,-1,-1,-1,1,"BNK2T61=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->notused190)-(long)(p)),105,0,0,-1,-1,-1,1,"notused190=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->notused191)-(long)(p)),105,0,0,-1,-1,-1,1,"notused191=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->notused192)-(long)(p)),105,0,0,-1,-1,-1,1,"notused192=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TGTL_t */
static void G__setup_memvarTGTL_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TGTL_t));
   { TGTL_t *p; p=(TGTL_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information");
   }
   G__tag_memvar_reset();
}


   /* TGTR_t */
static void G__setup_memvarTGTR_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TGTR_t));
   { TGTR_t *p; p=(TGTR_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),114,0,0,-1,-1,-1,1,"ID=",0,"the address of the hit detector element");
   G__memvar_setup((void*)((long)(&p->TDC)-(long)(p)),114,0,0,-1,-1,-1,1,"TDC=",0,"tdc information");
   }
   G__tag_memvar_reset();
}


   /* TLV1_t */
static void G__setup_memvarTLV1_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TLV1_t));
   { TLV1_t *p; p=(TLV1_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"id = Detector * 256 + channel");
   G__memvar_setup((void*)((long)(&p->time)-(long)(p)),102,0,0,-1,-1,-1,1,"time=",0,"time(ns) ");
   }
   G__tag_memvar_reset();
}


   /* TRCF_t */
static void G__setup_memvarTRCF_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TRCF_t));
   { TRCF_t *p; p=(TRCF_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->trigcfg)-(long)(p)),99,0,0,-1,-1,-1,1,"trigcfg[4]=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TRGS_t */
static void G__setup_memvarTRGS_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TRGS_t));
   { TRGS_t *p; p=(TRGS_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->CLOCK_UG)-(long)(p)),105,0,0,-1,-1,-1,1,"CLOCK_UG=",0,"Clock ungated");
   G__memvar_setup((void*)((long)(&p->FCUP_UG)-(long)(p)),105,0,0,-1,-1,-1,1,"FCUP_UG=",0,"FCUP ungated");
   G__memvar_setup((void*)((long)(&p->Microsec)-(long)(p)),105,0,0,-1,-1,-1,1,"Microsec=",0,"Microsecond clock (will overflow during normal run)");
   G__memvar_setup((void*)((long)(&p->random_ug)-(long)(p)),105,0,0,-1,-1,-1,1,"random_ug=",0,"Random pulser ungated");
   G__memvar_setup((void*)((long)(&p->MOR_ST)-(long)(p)),105,0,0,-1,-1,-1,1,"MOR_ST=",0,"MOR.ST");
   G__memvar_setup((void*)((long)(&p->MOR_PC)-(long)(p)),105,0,0,-1,-1,-1,1,"MOR_PC=",0,"MOR.PC");
   G__memvar_setup((void*)((long)(&p->MOR_PS)-(long)(p)),105,0,0,-1,-1,-1,1,"MOR_PS=",0,"MOR.PS");
   G__memvar_setup((void*)((long)(&p->MOR_TAC)-(long)(p)),105,0,0,-1,-1,-1,1,"MOR_TAC=",0,"MOR.TAC");
   G__memvar_setup((void*)((long)(&p->MOR)-(long)(p)),105,0,0,-1,-1,-1,1,"MOR=",0,"Master OR");
   G__memvar_setup((void*)((long)(&p->PC)-(long)(p)),105,0,0,-1,-1,-1,1,"PC=",0,"Pair Counter");
   G__memvar_setup((void*)((long)(&p->PS)-(long)(p)),105,0,0,-1,-1,-1,1,"PS=",0,"Pair Spectrometer");
   G__memvar_setup((void*)((long)(&p->TAC)-(long)(p)),105,0,0,-1,-1,-1,1,"TAC=",0,"Total Absorption Counter");
   G__memvar_setup((void*)((long)(&p->ST)-(long)(p)),105,0,0,-1,-1,-1,1,"ST=",0,"ST");
   G__memvar_setup((void*)((long)(&p->hel_sync)-(long)(p)),105,0,0,-1,-1,-1,1,"hel_sync=",0,"Helicity sync signal");
   G__memvar_setup((void*)((long)(&p->clock_ug_2)-(long)(p)),105,0,0,-1,-1,-1,1,"clock_ug_2=",0,"Duplicate of channel 1");
   G__memvar_setup((void*)((long)(&p->fcup_ug_2)-(long)(p)),105,0,0,-1,-1,-1,1,"fcup_ug_2=",0,"Duplicate of channel 2");
   G__memvar_setup((void*)((long)(&p->CLOCK_G1)-(long)(p)),105,0,0,-1,-1,-1,1,"CLOCK_G1=",0,"Clock with run gatei");
   G__memvar_setup((void*)((long)(&p->FCUP_G1)-(long)(p)),105,0,0,-1,-1,-1,1,"FCUP_G1=",0,"FCUP with Run Gate");
   G__memvar_setup((void*)((long)(&p->NotUsed19)-(long)(p)),105,0,0,-1,-1,-1,1,"NotUsed19=",0,"Currently not used");
   G__memvar_setup((void*)((long)(&p->random_g1)-(long)(p)),105,0,0,-1,-1,-1,1,"random_g1=",0,"Random pulser run gated");
   G__memvar_setup((void*)((long)(&p->MOR_ST_rg)-(long)(p)),105,0,0,-1,-1,-1,1,"MOR_ST_rg=",0,"MOR.ST  with run gate");
   G__memvar_setup((void*)((long)(&p->MOR_PC_rg)-(long)(p)),105,0,0,-1,-1,-1,1,"MOR_PC_rg=",0,"MOR.PC with run gate");
   G__memvar_setup((void*)((long)(&p->MOR_PS_rg)-(long)(p)),105,0,0,-1,-1,-1,1,"MOR_PS_rg=",0,"MOR.PS with run gate");
   G__memvar_setup((void*)((long)(&p->MOR_TAC_rg)-(long)(p)),105,0,0,-1,-1,-1,1,"MOR_TAC_rg=",0,"MOR.TAC with run gate");
   G__memvar_setup((void*)((long)(&p->MOR_rg)-(long)(p)),105,0,0,-1,-1,-1,1,"MOR_rg=",0,"MASTER_OR with run gate");
   G__memvar_setup((void*)((long)(&p->PC_rg)-(long)(p)),105,0,0,-1,-1,-1,1,"PC_rg=",0,"PC with run gate");
   G__memvar_setup((void*)((long)(&p->PS_rg)-(long)(p)),105,0,0,-1,-1,-1,1,"PS_rg=",0,"PS with run gate");
   G__memvar_setup((void*)((long)(&p->TAC_rg)-(long)(p)),105,0,0,-1,-1,-1,1,"TAC_rg=",0,"TAC with run gate");
   G__memvar_setup((void*)((long)(&p->ST_rg)-(long)(p)),105,0,0,-1,-1,-1,1,"ST_rg=",0,"ST  with run gate");
   G__memvar_setup((void*)((long)(&p->random_g1_2)-(long)(p)),105,0,0,-1,-1,-1,1,"random_g1_2=",0,"duplicate of channel 20");
   G__memvar_setup((void*)((long)(&p->clock_g1_2)-(long)(p)),105,0,0,-1,-1,-1,1,"clock_g1_2=",0,"duplicate of channel 17");
   G__memvar_setup((void*)((long)(&p->fcup_g1_2)-(long)(p)),105,0,0,-1,-1,-1,1,"fcup_g1_2=",0,"duplicate of channel 18");
   G__memvar_setup((void*)((long)(&p->CLOCK_G2)-(long)(p)),105,0,0,-1,-1,-1,1,"CLOCK_G2=",0,"CLOCK live gated");
   G__memvar_setup((void*)((long)(&p->FCUP_G2)-(long)(p)),105,0,0,-1,-1,-1,1,"FCUP_G2=",0,"FCUP live gated");
   G__memvar_setup((void*)((long)(&p->trig_or_g2)-(long)(p)),105,0,0,-1,-1,-1,1,"trig_or_g2=",0,"Trigger OR of 1-12 live gated");
   G__memvar_setup((void*)((long)(&p->random_g2)-(long)(p)),105,0,0,-1,-1,-1,1,"random_g2=",0,"Random pulser live gated");
   G__memvar_setup((void*)((long)(&p->NotUsed37)-(long)(p)),105,0,0,-1,-1,-1,1,"NotUsed37=",0,"Currently not used");
   G__memvar_setup((void*)((long)(&p->NotUsed38)-(long)(p)),105,0,0,-1,-1,-1,1,"NotUsed38=",0,"Currently not used");
   G__memvar_setup((void*)((long)(&p->NotUsed39)-(long)(p)),105,0,0,-1,-1,-1,1,"NotUsed39=",0,"Currently not used");
   G__memvar_setup((void*)((long)(&p->NotUsed40)-(long)(p)),105,0,0,-1,-1,-1,1,"NotUsed40=",0,"Currently not used");
   G__memvar_setup((void*)((long)(&p->MOR_lg)-(long)(p)),105,0,0,-1,-1,-1,1,"MOR_lg=",0,"MASTER_OR live gated");
   G__memvar_setup((void*)((long)(&p->NotUsed42)-(long)(p)),105,0,0,-1,-1,-1,1,"NotUsed42=",0,"Currently not used");
   G__memvar_setup((void*)((long)(&p->NotUsed43)-(long)(p)),105,0,0,-1,-1,-1,1,"NotUsed43=",0,"Currently not used");
   G__memvar_setup((void*)((long)(&p->NotUsed44)-(long)(p)),105,0,0,-1,-1,-1,1,"NotUsed44=",0,"Currently not used");
   G__memvar_setup((void*)((long)(&p->NotUsed45)-(long)(p)),105,0,0,-1,-1,-1,1,"NotUsed45=",0,"Currently not used");
   G__memvar_setup((void*)((long)(&p->random_g2_2)-(long)(p)),105,0,0,-1,-1,-1,1,"random_g2_2=",0,"duplicate of channel 36");
   G__memvar_setup((void*)((long)(&p->clock_g2_2)-(long)(p)),105,0,0,-1,-1,-1,1,"clock_g2_2=",0,"duplicate of channel 33");
   G__memvar_setup((void*)((long)(&p->fcup_g2_2)-(long)(p)),105,0,0,-1,-1,-1,1,"fcup_g2_2=",0,"duplicate of channel 34");
   G__memvar_setup((void*)((long)(&p->trig1_ug)-(long)(p)),105,0,0,-1,-1,-1,1,"trig1_ug=",0,"Trigger 1 ungated, prescaled");
   G__memvar_setup((void*)((long)(&p->trig2_ug)-(long)(p)),105,0,0,-1,-1,-1,1,"trig2_ug=",0,"Trigger 2 ungated, prescaled");
   G__memvar_setup((void*)((long)(&p->trig3_ug)-(long)(p)),105,0,0,-1,-1,-1,1,"trig3_ug=",0,"Trigger 3 ungated, prescaled");
   G__memvar_setup((void*)((long)(&p->trig4_ug)-(long)(p)),105,0,0,-1,-1,-1,1,"trig4_ug=",0,"Trigger 4 ungated, prescaled");
   G__memvar_setup((void*)((long)(&p->trig5_ug)-(long)(p)),105,0,0,-1,-1,-1,1,"trig5_ug=",0,"Trigger 5 ungated, prescaled");
   G__memvar_setup((void*)((long)(&p->trig6_ug)-(long)(p)),105,0,0,-1,-1,-1,1,"trig6_ug=",0,"Trigger 6 ungated, prescaled");
   G__memvar_setup((void*)((long)(&p->trig7_ug)-(long)(p)),105,0,0,-1,-1,-1,1,"trig7_ug=",0,"Trigger 7 ungated, prescaled");
   G__memvar_setup((void*)((long)(&p->trig8_ug)-(long)(p)),105,0,0,-1,-1,-1,1,"trig8_ug=",0,"Trigger 8 ungated, prescaled");
   G__memvar_setup((void*)((long)(&p->trig9_ug)-(long)(p)),105,0,0,-1,-1,-1,1,"trig9_ug=",0,"Trigger 9 ungated, prescaled");
   G__memvar_setup((void*)((long)(&p->trig10_ug)-(long)(p)),105,0,0,-1,-1,-1,1,"trig10_ug=",0,"Trigger 10 ungated, prescaled");
   G__memvar_setup((void*)((long)(&p->trig11_ug)-(long)(p)),105,0,0,-1,-1,-1,1,"trig11_ug=",0,"Trigger 11 ungated, prescaled");
   G__memvar_setup((void*)((long)(&p->trig12_ug)-(long)(p)),105,0,0,-1,-1,-1,1,"trig12_ug=",0,"Trigger 12 ungated, prescaled");
   G__memvar_setup((void*)((long)(&p->trig_or_ug)-(long)(p)),105,0,0,-1,-1,-1,1,"trig_or_ug=",0,"Trigger OR of 1-12 ungated,");
   G__memvar_setup((void*)((long)(&p->l1accept)-(long)(p)),105,0,0,-1,-1,-1,1,"l1accept=",0,"Level 1 accept");
   G__memvar_setup((void*)((long)(&p->notused63)-(long)(p)),105,0,0,-1,-1,-1,1,"notused63=",0,"Currently not used");
   G__memvar_setup((void*)((long)(&p->notused64)-(long)(p)),105,0,0,-1,-1,-1,1,"notused64=",0,"Currently not used");
   G__memvar_setup((void*)((long)(&p->l2fail)-(long)(p)),105,0,0,-1,-1,-1,1,"l2fail=",0,"Level2 fail");
   G__memvar_setup((void*)((long)(&p->l2pass)-(long)(p)),105,0,0,-1,-1,-1,1,"l2pass=",0,"Level2 pass");
   G__memvar_setup((void*)((long)(&p->l2start)-(long)(p)),105,0,0,-1,-1,-1,1,"l2start=",0,"Level2 start");
   G__memvar_setup((void*)((long)(&p->l2clear)-(long)(p)),105,0,0,-1,-1,-1,1,"l2clear=",0,"Level2 clear");
   G__memvar_setup((void*)((long)(&p->l2accept)-(long)(p)),105,0,0,-1,-1,-1,1,"l2accept=",0,"Level2 accept");
   G__memvar_setup((void*)((long)(&p->l3accept)-(long)(p)),105,0,0,-1,-1,-1,1,"l3accept=",0,"Level3 accept");
   G__memvar_setup((void*)((long)(&p->notused71)-(long)(p)),105,0,0,-1,-1,-1,1,"notused71=",0,"Currently not used");
   G__memvar_setup((void*)((long)(&p->notused72)-(long)(p)),105,0,0,-1,-1,-1,1,"notused72=",0,"Currently not used");
   G__memvar_setup((void*)((long)(&p->l2sec1_g)-(long)(p)),105,0,0,-1,-1,-1,1,"l2sec1_g=",0,"Level2 sec1 gated");
   G__memvar_setup((void*)((long)(&p->l2sec2_g)-(long)(p)),105,0,0,-1,-1,-1,1,"l2sec2_g=",0,"Level2 sec2 gated");
   G__memvar_setup((void*)((long)(&p->l2sec3_g)-(long)(p)),105,0,0,-1,-1,-1,1,"l2sec3_g=",0,"Level2 sec3 gated");
   G__memvar_setup((void*)((long)(&p->l2sec4_g)-(long)(p)),105,0,0,-1,-1,-1,1,"l2sec4_g=",0,"Level2 sec4 gated");
   G__memvar_setup((void*)((long)(&p->l2sec5_g)-(long)(p)),105,0,0,-1,-1,-1,1,"l2sec5_g=",0,"Level2 sec5 gated");
   G__memvar_setup((void*)((long)(&p->l2sec6_g)-(long)(p)),105,0,0,-1,-1,-1,1,"l2sec6_g=",0,"Level2 sec6 gated");
   G__memvar_setup((void*)((long)(&p->l2_or_g)-(long)(p)),105,0,0,-1,-1,-1,1,"l2_or_g=",0,"OR level2 gated");
   G__memvar_setup((void*)((long)(&p->l2_ok_g)-(long)(p)),105,0,0,-1,-1,-1,1,"l2_ok_g=",0,"Level 2 OK gated");
   G__memvar_setup((void*)((long)(&p->trig1_lg)-(long)(p)),105,0,0,-1,-1,-1,1,"trig1_lg=",0,"Trigger 1 live gated");
   G__memvar_setup((void*)((long)(&p->trig2_lg)-(long)(p)),105,0,0,-1,-1,-1,1,"trig2_lg=",0,"Trigger 2 live gated");
   G__memvar_setup((void*)((long)(&p->trig3_lg)-(long)(p)),105,0,0,-1,-1,-1,1,"trig3_lg=",0,"Trigger 3 live gated");
   G__memvar_setup((void*)((long)(&p->trig4_lg)-(long)(p)),105,0,0,-1,-1,-1,1,"trig4_lg=",0,"Trigger 4 live gated");
   G__memvar_setup((void*)((long)(&p->trig5_lg)-(long)(p)),105,0,0,-1,-1,-1,1,"trig5_lg=",0,"Trigger 5 live gated");
   G__memvar_setup((void*)((long)(&p->trig6_lg)-(long)(p)),105,0,0,-1,-1,-1,1,"trig6_lg=",0,"Trigger 6 live gated");
   G__memvar_setup((void*)((long)(&p->trig7_lg)-(long)(p)),105,0,0,-1,-1,-1,1,"trig7_lg=",0,"Trigger 7 live gated");
   G__memvar_setup((void*)((long)(&p->trig8_lg)-(long)(p)),105,0,0,-1,-1,-1,1,"trig8_lg=",0,"Trigger 8 live gated");
   G__memvar_setup((void*)((long)(&p->trig9_lg)-(long)(p)),105,0,0,-1,-1,-1,1,"trig9_lg=",0,"Trigger 9 live gated");
   G__memvar_setup((void*)((long)(&p->trig10_lg)-(long)(p)),105,0,0,-1,-1,-1,1,"trig10_lg=",0,"Trigger 10 live gated");
   G__memvar_setup((void*)((long)(&p->trig11_lg)-(long)(p)),105,0,0,-1,-1,-1,1,"trig11_lg=",0,"Trigger 11 live gated");
   G__memvar_setup((void*)((long)(&p->trig12_lg)-(long)(p)),105,0,0,-1,-1,-1,1,"trig12_lg=",0,"Trigger 12 live gated");
   G__memvar_setup((void*)((long)(&p->notused93)-(long)(p)),105,0,0,-1,-1,-1,1,"notused93=",0,"not used");
   G__memvar_setup((void*)((long)(&p->notused94)-(long)(p)),105,0,0,-1,-1,-1,1,"notused94=",0,"not used");
   G__memvar_setup((void*)((long)(&p->ignore95)-(long)(p)),105,0,0,-1,-1,-1,1,"ignore95=",0,"ignore");
   G__memvar_setup((void*)((long)(&p->ignore96)-(long)(p)),105,0,0,-1,-1,-1,1,"ignore96=",0,"ignore");
   }
   G__tag_memvar_reset();
}


   /* TRKS_t */
static void G__setup_memvarTRKS_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TRKS_t));
   { TRKS_t *p; p=(TRKS_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->trk_lev)-(long)(p)),105,0,0,-1,-1,-1,1,"trk_lev=",0,"Tracknr + analysis_level*100");
   G__memvar_setup((void*)((long)(&p->beta)-(long)(p)),102,0,0,-1,-1,-1,1,"beta=",0,"Beta of the track in unit of c");
   G__memvar_setup((void*)((long)(&p->st_time)-(long)(p)),102,0,0,-1,-1,-1,1,"st_time=",0,"Start time of the event (track: photon trigg)");
   G__memvar_setup((void*)((long)(&p->cc_time)-(long)(p)),102,0,0,-1,-1,-1,1,"cc_time=",0,"CC calibrated time for this track (ns)");
   G__memvar_setup((void*)((long)(&p->sc_time)-(long)(p)),102,0,0,-1,-1,-1,1,"sc_time=",0,"SC calibrated time for this track (ns)");
   G__memvar_setup((void*)((long)(&p->ec_time)-(long)(p)),102,0,0,-1,-1,-1,1,"ec_time=",0,"EC calibrated time for this track (ns)");
   G__memvar_setup((void*)((long)(&p->st_id)-(long)(p)),105,0,0,-1,-1,-1,1,"st_id=",0,"ST hit id (ptr. to STx: photon trigg)");
   G__memvar_setup((void*)((long)(&p->cc_id)-(long)(p)),105,0,0,-1,-1,-1,1,"cc_id=",0,"CC hit id (ptr. to CCRC)");
   G__memvar_setup((void*)((long)(&p->sc_id)-(long)(p)),105,0,0,-1,-1,-1,1,"sc_id=",0,"SC hit id (ptr. to SCRW)");
   G__memvar_setup((void*)((long)(&p->ec_id)-(long)(p)),105,0,0,-1,-1,-1,1,"ec_id=",0,"EC Cluster-id (ptr. to ECHB)");
   }
   G__tag_memvar_reset();
}


   /* TRL1_t */
static void G__setup_memvarTRL1_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TRL1_t));
   { TRL1_t *p; p=(TRL1_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fit_flags)-(long)(p)),105,0,0,-1,-1,-1,1,"fit_flags=",0,"flags used in track fitting");
   G__memvar_setup((void*)((long)(&p->hits_hbt)-(long)(p)),105,0,0,-1,-1,-1,1,"hits_hbt=",0,"hits used in HBT fit");
   G__memvar_setup((void*)((long)(&p->hits_tbt)-(long)(p)),105,0,0,-1,-1,-1,1,"hits_tbt=",0,"hits used in TBT fit");
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"x");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y   position in first DC layer ");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z");
   G__memvar_setup((void*)((long)(&p->cx)-(long)(p)),102,0,0,-1,-1,-1,1,"cx=",0,"cx");
   G__memvar_setup((void*)((long)(&p->cy)-(long)(p)),102,0,0,-1,-1,-1,1,"cy=",0,"cy  dir.cosine at first DC layer");
   G__memvar_setup((void*)((long)(&p->cz)-(long)(p)),102,0,0,-1,-1,-1,1,"cz=",0,"cz");
   G__memvar_setup((void*)((long)(&p->tlen)-(long)(p)),102,0,0,-1,-1,-1,1,"tlen=",0,"track length to this layer (starting");
   }
   G__tag_memvar_reset();
}


   /* TRPB_t */
static void G__setup_memvarTRPB_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TRPB_t));
   { TRPB_t *p; p=(TRPB_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->hits_tbt)-(long)(p)),105,0,0,-1,-1,-1,1,"hits_tbt=",0,"hits used in TBT fit");
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"x");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y   position in first DC layer ");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z");
   G__memvar_setup((void*)((long)(&p->cx)-(long)(p)),102,0,0,-1,-1,-1,1,"cx=",0,"cx");
   G__memvar_setup((void*)((long)(&p->cy)-(long)(p)),102,0,0,-1,-1,-1,1,"cy=",0,"cy  dir.cosine at first DC layer");
   G__memvar_setup((void*)((long)(&p->cz)-(long)(p)),102,0,0,-1,-1,-1,1,"cz=",0,"cz");
   G__memvar_setup((void*)((long)(&p->tlen)-(long)(p)),102,0,0,-1,-1,-1,1,"tlen=",0,"track length to this layer (starting");
   }
   G__tag_memvar_reset();
}


   /* TSPR_t */
static void G__setup_memvarTSPR_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TSPR_t));
   { TSPR_t *p; p=(TSPR_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->mem)-(long)(p)),104,0,0,-1,-1,-1,1,"mem=",0,"memory value");
   }
   G__tag_memvar_reset();
}


   /* TSRG_t */
static void G__setup_memvarTSRG_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TSRG_t));
   { TSRG_t *p; p=(TSRG_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->reg)-(long)(p)),104,0,0,-1,-1,-1,1,"reg=",0,"register value");
   }
   G__tag_memvar_reset();
}


   /* UNUS_t */
static void G__setup_memvarUNUS_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_UNUS_t));
   { UNUS_t *p; p=(UNUS_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->NDCUN)-(long)(p)),105,0,0,-1,-1,-1,1,"NDCUN=",0,"Number of unused DC tracks");
   G__memvar_setup((void*)((long)(&p->IDCUN)-(long)(p)),105,0,0,-1,-1,-1,1,"IDCUN=",0,"Trek ID  ");
   G__memvar_setup((void*)((long)(&p->NSCUN)-(long)(p)),105,0,0,-1,-1,-1,1,"NSCUN=",0,"Number of unused SC hits");
   G__memvar_setup((void*)((long)(&p->ISCUN)-(long)(p)),105,0,0,-1,-1,-1,1,"ISCUN=",0,"SC hit ID");
   G__memvar_setup((void*)((long)(&p->NCCUN)-(long)(p)),105,0,0,-1,-1,-1,1,"NCCUN=",0,"Number of unused CC hits");
   G__memvar_setup((void*)((long)(&p->ICCUN)-(long)(p)),105,0,0,-1,-1,-1,1,"ICCUN=",0,"CC hit ID");
   G__memvar_setup((void*)((long)(&p->NECUN)-(long)(p)),105,0,0,-1,-1,-1,1,"NECUN=",0,"Number of unused EC hits");
   G__memvar_setup((void*)((long)(&p->IECUN)-(long)(p)),105,0,0,-1,-1,-1,1,"IECUN=",0,"EC hit ID");
   }
   G__tag_memvar_reset();
}


   /* VERT_t */
static void G__setup_memvarVERT_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_VERT_t));
   { VERT_t *p; p=(VERT_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->vertex)-(long)(p)),105,0,0,-1,-1,-1,1,"vertex=",0,"vertex id");
   G__memvar_setup((void*)((long)(&p->trk1)-(long)(p)),105,0,0,-1,-1,-1,1,"trk1=",0,"track #1");
   G__memvar_setup((void*)((long)(&p->trk2)-(long)(p)),105,0,0,-1,-1,-1,1,"trk2=",0,"track #2");
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),102,0,0,-1,-1,-1,1,"x=",0,"x vector3_t vert{x,y,z}");
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),102,0,0,-1,-1,-1,1,"y=",0,"y ");
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),102,0,0,-1,-1,-1,1,"z=",0,"z");
   G__memvar_setup((void*)((long)(&p->sepd)-(long)(p)),102,0,0,-1,-1,-1,1,"sepd=",0,"seperation distance");
   }
   G__tag_memvar_reset();
}


   /* RC26_t */
static void G__setup_memvarRC26_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RC26_t));
   { RC26_t *p; p=(RC26_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->trigger_pattern)-(long)(p)),104,0,0,-1,-1,-1,1,"trigger_pattern=",0,"level1 trigger pattern from trigger supervisor");
   G__memvar_setup((void*)((long)(&p->gated_scaler)-(long)(p)),104,0,0,-1,-1,-1,1,"gated_scaler=",0,"gated scaler");
   G__memvar_setup((void*)((long)(&p->ungated_scaler)-(long)(p)),104,0,0,-1,-1,-1,1,"ungated_scaler=",0,"ungated scaler");
   }
   G__tag_memvar_reset();
}


   /* STRE_t */
static void G__setup_memvarSTRE_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STRE_t));
   { STRE_t *p; p=(STRE_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),105,0,0,-1,-1,-1,1,"ID=",0,"sector");
   G__memvar_setup((void*)((long)(&p->Trk_no)-(long)(p)),105,0,0,-1,-1,-1,1,"Trk_no=",0,"Pointer to track in HBTR");
   G__memvar_setup((void*)((long)(&p->ST_TIME)-(long)(p)),102,0,0,-1,-1,-1,1,"ST_TIME=",0,"flight time from ST (ns)");
   G__memvar_setup((void*)((long)(&p->ST_L)-(long)(p)),102,0,0,-1,-1,-1,1,"ST_L=",0,"flight path from ST (cm)");
   G__memvar_setup((void*)((long)(&p->st_pos)-(long)(p)),102,0,0,-1,-1,-1,1,"st_pos=",0,"position within the start counter");
   G__memvar_setup((void*)((long)(&p->status)-(long)(p)),105,0,0,-1,-1,-1,1,"status=",0,"Status word");
   G__memvar_setup((void*)((long)(&p->st_edep)-(long)(p)),102,0,0,-1,-1,-1,1,"st_edep=",0,"energy deposit in ST");
   G__memvar_setup((void*)((long)(&p->st_corr)-(long)(p)),102,0,0,-1,-1,-1,1,"st_corr=",0,"energy correction factor for angle");
   }
   G__tag_memvar_reset();
}


   /* addressBanks_t */
static void G__setup_memvaraddressBanks_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__bankvarsDictLN_addressBanks_t));
   { addressBanks_t *p; p=(addressBanks_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->name)-(long)(p)),99,0,0,-1,-1,-1,1,"name[8]=",0,"name of the bank");
   G__memvar_setup((void*)((long)(&p->address)-(long)(p)),89,2,0,-1,-1,-1,1,"address=",0,"address of array of structs (eg EVNT_t) for the bank");
   G__memvar_setup((void*)((long)(&p->nBank)-(long)(p)),73,0,0,-1,-1,-1,1,"nBank=",0,"address of variable with the no of sectors  / instances of BANK in the event ");
   G__memvar_setup((void*)((long)(&p->nRow)-(long)(p)),73,2,0,-1,-1,-1,1,"nRow=",0,"address of the array if hit nos for each sector which was present");
   G__memvar_setup((void*)((long)(&p->bankSec)-(long)(p)),73,2,0,-1,-1,-1,1,"bankSec=",0,"address if array of sector numbers for sectors which were present");
   G__memvar_setup((void*)((long)(&p->length)-(long)(p)),105,0,0,-1,-1,-1,1,"length=",0,"length of the struct relating to the bank");
   G__memvar_setup((void*)((long)(&p->pfunc)-(long)(p)),49,0,0,-1,G__defined_typename("void (*)()"),-1,1,"pfunc=",0,"-> print function for the bank");
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarbankvarsDict() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncBEAM_t(void) {
   /* BEAM_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_BEAM_t));
   // automatic default constructor
   G__memfunc_setup("BEAM_t", 488, G__bankvarsDict_168_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_BEAM_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("BEAM_t", 488, G__bankvarsDict_168_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_BEAM_t), -1, 0, 1, 1, 1, 0, "u 'BEAM_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~BEAM_t", 614, G__bankvarsDict_168_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_168_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_BEAM_t), -1, 1, 1, 1, 1, 0, "u 'BEAM_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncBMPR_t(void) {
   /* BMPR_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_BMPR_t));
   // automatic default constructor
   G__memfunc_setup("BMPR_t", 516, G__bankvarsDict_169_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_BMPR_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("BMPR_t", 516, G__bankvarsDict_169_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_BMPR_t), -1, 0, 1, 1, 1, 0, "u 'BMPR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~BMPR_t", 642, G__bankvarsDict_169_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_169_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_BMPR_t), -1, 1, 1, 1, 1, 0, "u 'BMPR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncBREP_t(void) {
   /* BREP_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_BREP_t));
   // automatic default constructor
   G__memfunc_setup("BREP_t", 508, G__bankvarsDict_170_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_BREP_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("BREP_t", 508, G__bankvarsDict_170_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_BREP_t), -1, 0, 1, 1, 1, 0, "u 'BREP_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~BREP_t", 634, G__bankvarsDict_170_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_170_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_BREP_t), -1, 1, 1, 1, 1, 0, "u 'BREP_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCALB_t(void) {
   /* CALB_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CALB_t));
   // automatic default constructor
   G__memfunc_setup("CALB_t", 485, G__bankvarsDict_171_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CALB_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CALB_t", 485, G__bankvarsDict_171_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CALB_t), -1, 0, 1, 1, 1, 0, "u 'CALB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CALB_t", 611, G__bankvarsDict_171_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_171_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CALB_t), -1, 1, 1, 1, 1, 0, "u 'CALB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCALL_t(void) {
   /* CALL_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CALL_t));
   // automatic default constructor
   G__memfunc_setup("CALL_t", 495, G__bankvarsDict_172_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CALL_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CALL_t", 495, G__bankvarsDict_172_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CALL_t), -1, 0, 1, 1, 1, 0, "u 'CALL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CALL_t", 621, G__bankvarsDict_172_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_172_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CALL_t), -1, 1, 1, 1, 1, 0, "u 'CALL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCC01_t(void) {
   /* CC01_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CC01_t));
   // automatic default constructor
   G__memfunc_setup("CC01_t", 442, G__bankvarsDict_173_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CC01_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CC01_t", 442, G__bankvarsDict_173_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CC01_t), -1, 0, 1, 1, 1, 0, "u 'CC01_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CC01_t", 568, G__bankvarsDict_173_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_173_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CC01_t), -1, 1, 1, 1, 1, 0, "u 'CC01_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCC1_t(void) {
   /* CC1_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CC1_t));
   // automatic default constructor
   G__memfunc_setup("CC1_t", 394, G__bankvarsDict_174_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CC1_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CC1_t", 394, G__bankvarsDict_174_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CC1_t), -1, 0, 1, 1, 1, 0, "u 'CC1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CC1_t", 520, G__bankvarsDict_174_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_174_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CC1_t), -1, 1, 1, 1, 1, 0, "u 'CC1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCC_t(void) {
   /* CC_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CC_t));
   // automatic default constructor
   G__memfunc_setup("CC_t", 345, G__bankvarsDict_175_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CC_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CC_t", 345, G__bankvarsDict_175_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CC_t), -1, 0, 1, 1, 1, 0, "u 'CC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CC_t", 471, G__bankvarsDict_175_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_175_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CC_t), -1, 1, 1, 1, 1, 0, "u 'CC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCCDI_t(void) {
   /* CCDI_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CCDI_t));
   // automatic default constructor
   G__memfunc_setup("CCDI_t", 486, G__bankvarsDict_176_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CCDI_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CCDI_t", 486, G__bankvarsDict_176_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CCDI_t), -1, 0, 1, 1, 1, 0, "u 'CCDI_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CCDI_t", 612, G__bankvarsDict_176_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_176_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CCDI_t), -1, 1, 1, 1, 1, 0, "u 'CCDI_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCCH_t(void) {
   /* CCH_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CCH_t));
   // automatic default constructor
   G__memfunc_setup("CCH_t", 417, G__bankvarsDict_177_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CCH_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CCH_t", 417, G__bankvarsDict_177_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CCH_t), -1, 0, 1, 1, 1, 0, "u 'CCH_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CCH_t", 543, G__bankvarsDict_177_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_177_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CCH_t), -1, 1, 1, 1, 1, 0, "u 'CCH_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCCMT_t(void) {
   /* CCMT_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CCMT_t));
   // automatic default constructor
   G__memfunc_setup("CCMT_t", 506, G__bankvarsDict_178_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CCMT_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CCMT_t", 506, G__bankvarsDict_178_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CCMT_t), -1, 0, 1, 1, 1, 0, "u 'CCMT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CCMT_t", 632, G__bankvarsDict_178_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_178_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CCMT_t), -1, 1, 1, 1, 1, 0, "u 'CCMT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCCPB_t(void) {
   /* CCPB_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CCPB_t));
   // automatic default constructor
   G__memfunc_setup("CCPB_t", 491, G__bankvarsDict_179_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CCPB_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CCPB_t", 491, G__bankvarsDict_179_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CCPB_t), -1, 0, 1, 1, 1, 0, "u 'CCPB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CCPB_t", 617, G__bankvarsDict_179_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_179_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CCPB_t), -1, 1, 1, 1, 1, 0, "u 'CCPB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCCPE_t(void) {
   /* CCPE_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CCPE_t));
   // automatic default constructor
   G__memfunc_setup("CCPE_t", 494, G__bankvarsDict_180_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CCPE_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CCPE_t", 494, G__bankvarsDict_180_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CCPE_t), -1, 0, 1, 1, 1, 0, "u 'CCPE_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CCPE_t", 620, G__bankvarsDict_180_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_180_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CCPE_t), -1, 1, 1, 1, 1, 0, "u 'CCPE_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCCRC_t(void) {
   /* CCRC_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CCRC_t));
   // automatic default constructor
   G__memfunc_setup("CCRC_t", 494, G__bankvarsDict_181_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CCRC_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CCRC_t", 494, G__bankvarsDict_181_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CCRC_t), -1, 0, 1, 1, 1, 0, "u 'CCRC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CCRC_t", 620, G__bankvarsDict_181_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_181_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CCRC_t), -1, 1, 1, 1, 1, 0, "u 'CCRC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCCS_t(void) {
   /* CCS_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CCS_t));
   // automatic default constructor
   G__memfunc_setup("CCS_t", 428, G__bankvarsDict_182_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CCS_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CCS_t", 428, G__bankvarsDict_182_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CCS_t), -1, 0, 1, 1, 1, 0, "u 'CCS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CCS_t", 554, G__bankvarsDict_182_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_182_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CCS_t), -1, 1, 1, 1, 1, 0, "u 'CCS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCCT_t(void) {
   /* CCT_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CCT_t));
   // automatic default constructor
   G__memfunc_setup("CCT_t", 429, G__bankvarsDict_183_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CCT_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CCT_t", 429, G__bankvarsDict_183_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CCT_t), -1, 0, 1, 1, 1, 0, "u 'CCT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CCT_t", 555, G__bankvarsDict_183_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_183_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CCT_t), -1, 1, 1, 1, 1, 0, "u 'CCT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCHI2_t(void) {
   /* CHI2_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CHI2_t));
   // automatic default constructor
   G__memfunc_setup("CHI2_t", 473, G__bankvarsDict_184_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CHI2_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CHI2_t", 473, G__bankvarsDict_184_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CHI2_t), -1, 0, 1, 1, 1, 0, "u 'CHI2_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CHI2_t", 599, G__bankvarsDict_184_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_184_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CHI2_t), -1, 1, 1, 1, 1, 0, "u 'CHI2_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCL01_t(void) {
   /* CL01_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CL01_t));
   // automatic default constructor
   G__memfunc_setup("CL01_t", 451, G__bankvarsDict_185_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CL01_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CL01_t", 451, G__bankvarsDict_185_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CL01_t), -1, 0, 1, 1, 1, 0, "u 'CL01_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CL01_t", 577, G__bankvarsDict_185_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_185_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CL01_t), -1, 1, 1, 1, 1, 0, "u 'CL01_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCLST_t(void) {
   /* CLST_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CLST_t));
   // automatic default constructor
   G__memfunc_setup("CLST_t", 521, G__bankvarsDict_186_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CLST_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CLST_t", 521, G__bankvarsDict_186_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CLST_t), -1, 0, 1, 1, 1, 0, "u 'CLST_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CLST_t", 647, G__bankvarsDict_186_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_186_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CLST_t), -1, 1, 1, 1, 1, 0, "u 'CLST_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCPED_t(void) {
   /* CPED_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CPED_t));
   // automatic default constructor
   G__memfunc_setup("CPED_t", 495, G__bankvarsDict_187_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CPED_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CPED_t", 495, G__bankvarsDict_187_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CPED_t), -1, 0, 1, 1, 1, 0, "u 'CPED_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CPED_t", 621, G__bankvarsDict_187_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_187_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CPED_t), -1, 1, 1, 1, 1, 0, "u 'CPED_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncCSQL_t(void) {
   /* CSQL_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_CSQL_t));
   // automatic default constructor
   G__memfunc_setup("CSQL_t", 518, G__bankvarsDict_188_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CSQL_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CSQL_t", 518, G__bankvarsDict_188_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_CSQL_t), -1, 0, 1, 1, 1, 0, "u 'CSQL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CSQL_t", 644, G__bankvarsDict_188_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_188_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_CSQL_t), -1, 1, 1, 1, 1, 0, "u 'CSQL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDC0_t(void) {
   /* DC0_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DC0_t));
   // automatic default constructor
   G__memfunc_setup("DC0_t", 394, G__bankvarsDict_189_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DC0_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DC0_t", 394, G__bankvarsDict_189_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DC0_t), -1, 0, 1, 1, 1, 0, "u 'DC0_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DC0_t", 520, G__bankvarsDict_189_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_189_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DC0_t), -1, 1, 1, 1, 1, 0, "u 'DC0_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDC1_t(void) {
   /* DC1_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DC1_t));
   // automatic default constructor
   G__memfunc_setup("DC1_t", 395, G__bankvarsDict_190_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DC1_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DC1_t", 395, G__bankvarsDict_190_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DC1_t), -1, 0, 1, 1, 1, 0, "u 'DC1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DC1_t", 521, G__bankvarsDict_190_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_190_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DC1_t), -1, 1, 1, 1, 1, 0, "u 'DC1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDCDW_t(void) {
   /* DCDW_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCDW_t));
   // automatic default constructor
   G__memfunc_setup("DCDW_t", 501, G__bankvarsDict_191_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCDW_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DCDW_t", 501, G__bankvarsDict_191_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCDW_t), -1, 0, 1, 1, 1, 0, "u 'DCDW_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DCDW_t", 627, G__bankvarsDict_191_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_191_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DCDW_t), -1, 1, 1, 1, 1, 0, "u 'DCDW_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDCGM_t(void) {
   /* DCGM_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCGM_t));
   // automatic default constructor
   G__memfunc_setup("DCGM_t", 494, G__bankvarsDict_192_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCGM_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DCGM_t", 494, G__bankvarsDict_192_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCGM_t), -1, 0, 1, 1, 1, 0, "u 'DCGM_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DCGM_t", 620, G__bankvarsDict_192_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_192_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DCGM_t), -1, 1, 1, 1, 1, 0, "u 'DCGM_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDCGW_t(void) {
   /* DCGW_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCGW_t));
   // automatic default constructor
   G__memfunc_setup("DCGW_t", 504, G__bankvarsDict_193_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCGW_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DCGW_t", 504, G__bankvarsDict_193_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCGW_t), -1, 0, 1, 1, 1, 0, "u 'DCGW_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DCGW_t", 630, G__bankvarsDict_193_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_193_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DCGW_t), -1, 1, 1, 1, 1, 0, "u 'DCGW_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDCH_t(void) {
   /* DCH_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCH_t));
   // automatic default constructor
   G__memfunc_setup("DCH_t", 418, G__bankvarsDict_194_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCH_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DCH_t", 418, G__bankvarsDict_194_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCH_t), -1, 0, 1, 1, 1, 0, "u 'DCH_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DCH_t", 544, G__bankvarsDict_194_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_194_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DCH_t), -1, 1, 1, 1, 1, 0, "u 'DCH_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDCMN_t(void) {
   /* DCMN_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCMN_t));
   // automatic default constructor
   G__memfunc_setup("DCMN_t", 501, G__bankvarsDict_195_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCMN_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DCMN_t", 501, G__bankvarsDict_195_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCMN_t), -1, 0, 1, 1, 1, 0, "u 'DCMN_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DCMN_t", 627, G__bankvarsDict_195_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_195_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DCMN_t), -1, 1, 1, 1, 1, 0, "u 'DCMN_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDCPB_t(void) {
   /* DCPB_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCPB_t));
   // automatic default constructor
   G__memfunc_setup("DCPB_t", 492, G__bankvarsDict_196_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCPB_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DCPB_t", 492, G__bankvarsDict_196_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCPB_t), -1, 0, 1, 1, 1, 0, "u 'DCPB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DCPB_t", 618, G__bankvarsDict_196_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_196_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DCPB_t), -1, 1, 1, 1, 1, 0, "u 'DCPB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDCV1_t(void) {
   /* DCV1_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCV1_t));
   // automatic default constructor
   G__memfunc_setup("DCV1_t", 481, G__bankvarsDict_197_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCV1_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DCV1_t", 481, G__bankvarsDict_197_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCV1_t), -1, 0, 1, 1, 1, 0, "u 'DCV1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DCV1_t", 607, G__bankvarsDict_197_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_197_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DCV1_t), -1, 1, 1, 1, 1, 0, "u 'DCV1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDCV2_t(void) {
   /* DCV2_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCV2_t));
   // automatic default constructor
   G__memfunc_setup("DCV2_t", 482, G__bankvarsDict_198_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCV2_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DCV2_t", 482, G__bankvarsDict_198_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCV2_t), -1, 0, 1, 1, 1, 0, "u 'DCV2_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DCV2_t", 608, G__bankvarsDict_198_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_198_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DCV2_t), -1, 1, 1, 1, 1, 0, "u 'DCV2_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDCV3_t(void) {
   /* DCV3_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DCV3_t));
   // automatic default constructor
   G__memfunc_setup("DCV3_t", 483, G__bankvarsDict_199_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCV3_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DCV3_t", 483, G__bankvarsDict_199_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DCV3_t), -1, 0, 1, 1, 1, 0, "u 'DCV3_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DCV3_t", 609, G__bankvarsDict_199_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_199_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DCV3_t), -1, 1, 1, 1, 1, 0, "u 'DCV3_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDDLY_t(void) {
   /* DDLY_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DDLY_t));
   // automatic default constructor
   G__memfunc_setup("DDLY_t", 512, G__bankvarsDict_200_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DDLY_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DDLY_t", 512, G__bankvarsDict_200_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DDLY_t), -1, 0, 1, 1, 1, 0, "u 'DDLY_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DDLY_t", 638, G__bankvarsDict_200_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_200_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DDLY_t), -1, 1, 1, 1, 1, 0, "u 'DDLY_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDGEO_t(void) {
   /* DGEO_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DGEO_t));
   // automatic default constructor
   G__memfunc_setup("DGEO_t", 498, G__bankvarsDict_201_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DGEO_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DGEO_t", 498, G__bankvarsDict_201_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DGEO_t), -1, 0, 1, 1, 1, 0, "u 'DGEO_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DGEO_t", 624, G__bankvarsDict_201_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_201_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DGEO_t), -1, 1, 1, 1, 1, 0, "u 'DGEO_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDHCL_t(void) {
   /* DHCL_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DHCL_t));
   // automatic default constructor
   G__memfunc_setup("DHCL_t", 494, G__bankvarsDict_202_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DHCL_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DHCL_t", 494, G__bankvarsDict_202_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DHCL_t), -1, 0, 1, 1, 1, 0, "u 'DHCL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DHCL_t", 620, G__bankvarsDict_202_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_202_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DHCL_t), -1, 1, 1, 1, 1, 0, "u 'DHCL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDITM_t(void) {
   /* DITM_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DITM_t));
   // automatic default constructor
   G__memfunc_setup("DITM_t", 513, G__bankvarsDict_203_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DITM_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DITM_t", 513, G__bankvarsDict_203_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DITM_t), -1, 0, 1, 1, 1, 0, "u 'DITM_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DITM_t", 639, G__bankvarsDict_203_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_203_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DITM_t), -1, 1, 1, 1, 1, 0, "u 'DITM_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDOCA_t(void) {
   /* DOCA_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DOCA_t));
   // automatic default constructor
   G__memfunc_setup("DOCA_t", 490, G__bankvarsDict_204_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DOCA_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DOCA_t", 490, G__bankvarsDict_204_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DOCA_t), -1, 0, 1, 1, 1, 0, "u 'DOCA_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DOCA_t", 616, G__bankvarsDict_204_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_204_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DOCA_t), -1, 1, 1, 1, 1, 0, "u 'DOCA_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDPCP_t(void) {
   /* DPCP_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DPCP_t));
   // automatic default constructor
   G__memfunc_setup("DPCP_t", 506, G__bankvarsDict_205_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DPCP_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DPCP_t", 506, G__bankvarsDict_205_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DPCP_t), -1, 0, 1, 1, 1, 0, "u 'DPCP_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DPCP_t", 632, G__bankvarsDict_205_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_205_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DPCP_t), -1, 1, 1, 1, 1, 0, "u 'DPCP_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDPSP_t(void) {
   /* DPSP_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DPSP_t));
   // automatic default constructor
   G__memfunc_setup("DPSP_t", 522, G__bankvarsDict_206_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DPSP_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DPSP_t", 522, G__bankvarsDict_206_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DPSP_t), -1, 0, 1, 1, 1, 0, "u 'DPSP_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DPSP_t", 648, G__bankvarsDict_206_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_206_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DPSP_t), -1, 1, 1, 1, 1, 0, "u 'DPSP_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDSPC_t(void) {
   /* DSPC_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DSPC_t));
   // automatic default constructor
   G__memfunc_setup("DSPC_t", 509, G__bankvarsDict_207_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DSPC_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DSPC_t", 509, G__bankvarsDict_207_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DSPC_t), -1, 0, 1, 1, 1, 0, "u 'DSPC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DSPC_t", 635, G__bankvarsDict_207_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_207_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DSPC_t), -1, 1, 1, 1, 1, 0, "u 'DSPC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDSPS_t(void) {
   /* DSPS_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DSPS_t));
   // automatic default constructor
   G__memfunc_setup("DSPS_t", 525, G__bankvarsDict_208_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DSPS_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DSPS_t", 525, G__bankvarsDict_208_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DSPS_t), -1, 0, 1, 1, 1, 0, "u 'DSPS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DSPS_t", 651, G__bankvarsDict_208_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_208_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DSPS_t), -1, 1, 1, 1, 1, 0, "u 'DSPS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDSTC_t(void) {
   /* DSTC_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DSTC_t));
   // automatic default constructor
   G__memfunc_setup("DSTC_t", 513, G__bankvarsDict_209_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DSTC_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DSTC_t", 513, G__bankvarsDict_209_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DSTC_t), -1, 0, 1, 1, 1, 0, "u 'DSTC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DSTC_t", 639, G__bankvarsDict_209_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_209_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DSTC_t), -1, 1, 1, 1, 1, 0, "u 'DSTC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDTCP_t(void) {
   /* DTCP_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DTCP_t));
   // automatic default constructor
   G__memfunc_setup("DTCP_t", 510, G__bankvarsDict_210_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DTCP_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DTCP_t", 510, G__bankvarsDict_210_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DTCP_t), -1, 0, 1, 1, 1, 0, "u 'DTCP_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DTCP_t", 636, G__bankvarsDict_210_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_210_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DTCP_t), -1, 1, 1, 1, 1, 0, "u 'DTCP_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDTRK_t(void) {
   /* DTRK_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_DTRK_t));
   // automatic default constructor
   G__memfunc_setup("DTRK_t", 520, G__bankvarsDict_211_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DTRK_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DTRK_t", 520, G__bankvarsDict_211_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_DTRK_t), -1, 0, 1, 1, 1, 0, "u 'DTRK_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DTRK_t", 646, G__bankvarsDict_211_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_211_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_DTRK_t), -1, 1, 1, 1, 1, 0, "u 'DTRK_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncEC01_t(void) {
   /* EC01_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_EC01_t));
   // automatic default constructor
   G__memfunc_setup("EC01_t", 444, G__bankvarsDict_212_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_EC01_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EC01_t", 444, G__bankvarsDict_212_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_EC01_t), -1, 0, 1, 1, 1, 0, "u 'EC01_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EC01_t", 570, G__bankvarsDict_212_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_212_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_EC01_t), -1, 1, 1, 1, 1, 0, "u 'EC01_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncEC1_t(void) {
   /* EC1_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_EC1_t));
   // automatic default constructor
   G__memfunc_setup("EC1_t", 396, G__bankvarsDict_213_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_EC1_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EC1_t", 396, G__bankvarsDict_213_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_EC1_t), -1, 0, 1, 1, 1, 0, "u 'EC1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EC1_t", 522, G__bankvarsDict_213_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_213_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_EC1_t), -1, 1, 1, 1, 1, 0, "u 'EC1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncEC1P_t(void) {
   /* EC1P_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_EC1P_t));
   // automatic default constructor
   G__memfunc_setup("EC1P_t", 476, G__bankvarsDict_214_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_EC1P_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EC1P_t", 476, G__bankvarsDict_214_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_EC1P_t), -1, 0, 1, 1, 1, 0, "u 'EC1P_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EC1P_t", 602, G__bankvarsDict_214_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_214_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_EC1P_t), -1, 1, 1, 1, 1, 0, "u 'EC1P_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncEC1R_t(void) {
   /* EC1R_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_EC1R_t));
   // automatic default constructor
   G__memfunc_setup("EC1R_t", 478, G__bankvarsDict_215_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_EC1R_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EC1R_t", 478, G__bankvarsDict_215_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_EC1R_t), -1, 0, 1, 1, 1, 0, "u 'EC1R_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EC1R_t", 604, G__bankvarsDict_215_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_215_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_EC1R_t), -1, 1, 1, 1, 1, 0, "u 'EC1R_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECCA_t(void) {
   /* ECCA_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECCA_t));
   // automatic default constructor
   G__memfunc_setup("ECCA_t", 479, G__bankvarsDict_216_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECCA_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECCA_t", 479, G__bankvarsDict_216_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECCA_t), -1, 0, 1, 1, 1, 0, "u 'ECCA_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECCA_t", 605, G__bankvarsDict_216_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_216_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECCA_t), -1, 1, 1, 1, 1, 0, "u 'ECCA_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECCL_t(void) {
   /* ECCL_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECCL_t));
   // automatic default constructor
   G__memfunc_setup("ECCL_t", 490, G__bankvarsDict_217_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECCL_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECCL_t", 490, G__bankvarsDict_217_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECCL_t), -1, 0, 1, 1, 1, 0, "u 'ECCL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECCL_t", 616, G__bankvarsDict_217_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_217_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECCL_t), -1, 1, 1, 1, 1, 0, "u 'ECCL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECCT_t(void) {
   /* ECCT_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECCT_t));
   // automatic default constructor
   G__memfunc_setup("ECCT_t", 498, G__bankvarsDict_218_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECCT_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECCT_t", 498, G__bankvarsDict_218_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECCT_t), -1, 0, 1, 1, 1, 0, "u 'ECCT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECCT_t", 624, G__bankvarsDict_218_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_218_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECCT_t), -1, 1, 1, 1, 1, 0, "u 'ECCT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncEC_t(void) {
   /* EC_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_EC_t));
   // automatic default constructor
   G__memfunc_setup("EC_t", 347, G__bankvarsDict_219_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_EC_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EC_t", 347, G__bankvarsDict_219_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_EC_t), -1, 0, 1, 1, 1, 0, "u 'EC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EC_t", 473, G__bankvarsDict_219_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_219_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_EC_t), -1, 1, 1, 1, 1, 0, "u 'EC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECDI_t(void) {
   /* ECDI_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECDI_t));
   // automatic default constructor
   G__memfunc_setup("ECDI_t", 488, G__bankvarsDict_220_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECDI_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECDI_t", 488, G__bankvarsDict_220_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECDI_t), -1, 0, 1, 1, 1, 0, "u 'ECDI_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECDI_t", 614, G__bankvarsDict_220_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_220_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECDI_t), -1, 1, 1, 1, 1, 0, "u 'ECDI_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECG_t(void) {
   /* ECG_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECG_t));
   // automatic default constructor
   G__memfunc_setup("ECG_t", 418, G__bankvarsDict_221_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECG_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECG_t", 418, G__bankvarsDict_221_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECG_t), -1, 0, 1, 1, 1, 0, "u 'ECG_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECG_t", 544, G__bankvarsDict_221_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_221_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECG_t), -1, 1, 1, 1, 1, 0, "u 'ECG_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECHB_t(void) {
   /* ECHB_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECHB_t));
   // automatic default constructor
   G__memfunc_setup("ECHB_t", 485, G__bankvarsDict_222_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECHB_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECHB_t", 485, G__bankvarsDict_222_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECHB_t), -1, 0, 1, 1, 1, 0, "u 'ECHB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECHB_t", 611, G__bankvarsDict_222_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_222_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECHB_t), -1, 1, 1, 1, 1, 0, "u 'ECHB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECH_t(void) {
   /* ECH_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECH_t));
   // automatic default constructor
   G__memfunc_setup("ECH_t", 419, G__bankvarsDict_223_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECH_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECH_t", 419, G__bankvarsDict_223_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECH_t), -1, 0, 1, 1, 1, 0, "u 'ECH_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECH_t", 545, G__bankvarsDict_223_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_223_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECH_t), -1, 1, 1, 1, 1, 0, "u 'ECH_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECMT_t(void) {
   /* ECMT_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECMT_t));
   // automatic default constructor
   G__memfunc_setup("ECMT_t", 508, G__bankvarsDict_224_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECMT_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECMT_t", 508, G__bankvarsDict_224_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECMT_t), -1, 0, 1, 1, 1, 0, "u 'ECMT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECMT_t", 634, G__bankvarsDict_224_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_224_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECMT_t), -1, 1, 1, 1, 1, 0, "u 'ECMT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECP1_t(void) {
   /* ECP1_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECP1_t));
   // automatic default constructor
   G__memfunc_setup("ECP1_t", 476, G__bankvarsDict_225_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECP1_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECP1_t", 476, G__bankvarsDict_225_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECP1_t), -1, 0, 1, 1, 1, 0, "u 'ECP1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECP1_t", 602, G__bankvarsDict_225_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_225_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECP1_t), -1, 1, 1, 1, 1, 0, "u 'ECP1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECPB_t(void) {
   /* ECPB_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECPB_t));
   // automatic default constructor
   G__memfunc_setup("ECPB_t", 493, G__bankvarsDict_226_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECPB_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECPB_t", 493, G__bankvarsDict_226_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECPB_t), -1, 0, 1, 1, 1, 0, "u 'ECPB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECPB_t", 619, G__bankvarsDict_226_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_226_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECPB_t), -1, 1, 1, 1, 1, 0, "u 'ECPB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECPC_t(void) {
   /* ECPC_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECPC_t));
   // automatic default constructor
   G__memfunc_setup("ECPC_t", 494, G__bankvarsDict_227_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECPC_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECPC_t", 494, G__bankvarsDict_227_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECPC_t), -1, 0, 1, 1, 1, 0, "u 'ECPC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECPC_t", 620, G__bankvarsDict_227_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_227_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECPC_t), -1, 1, 1, 1, 1, 0, "u 'ECPC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECP_t(void) {
   /* ECP_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECP_t));
   // automatic default constructor
   G__memfunc_setup("ECP_t", 427, G__bankvarsDict_228_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECP_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECP_t", 427, G__bankvarsDict_228_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECP_t), -1, 0, 1, 1, 1, 0, "u 'ECP_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECP_t", 553, G__bankvarsDict_228_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_228_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECP_t), -1, 1, 1, 1, 1, 0, "u 'ECP_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECPE_t(void) {
   /* ECPE_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECPE_t));
   // automatic default constructor
   G__memfunc_setup("ECPE_t", 496, G__bankvarsDict_229_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECPE_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECPE_t", 496, G__bankvarsDict_229_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECPE_t), -1, 0, 1, 1, 1, 0, "u 'ECPE_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECPE_t", 622, G__bankvarsDict_229_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_229_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECPE_t), -1, 1, 1, 1, 1, 0, "u 'ECPE_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECPI_t(void) {
   /* ECPI_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECPI_t));
   // automatic default constructor
   G__memfunc_setup("ECPI_t", 500, G__bankvarsDict_230_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECPI_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECPI_t", 500, G__bankvarsDict_230_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECPI_t), -1, 0, 1, 1, 1, 0, "u 'ECPI_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECPI_t", 626, G__bankvarsDict_230_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_230_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECPI_t), -1, 1, 1, 1, 1, 0, "u 'ECPI_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECPO_t(void) {
   /* ECPO_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECPO_t));
   // automatic default constructor
   G__memfunc_setup("ECPO_t", 506, G__bankvarsDict_231_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECPO_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECPO_t", 506, G__bankvarsDict_231_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECPO_t), -1, 0, 1, 1, 1, 0, "u 'ECPO_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECPO_t", 632, G__bankvarsDict_231_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_231_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECPO_t), -1, 1, 1, 1, 1, 0, "u 'ECPO_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECRB_t(void) {
   /* ECRB_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECRB_t));
   // automatic default constructor
   G__memfunc_setup("ECRB_t", 495, G__bankvarsDict_232_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECRB_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECRB_t", 495, G__bankvarsDict_232_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECRB_t), -1, 0, 1, 1, 1, 0, "u 'ECRB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECRB_t", 621, G__bankvarsDict_232_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_232_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECRB_t), -1, 1, 1, 1, 1, 0, "u 'ECRB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECS_t(void) {
   /* ECS_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECS_t));
   // automatic default constructor
   G__memfunc_setup("ECS_t", 430, G__bankvarsDict_233_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECS_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECS_t", 430, G__bankvarsDict_233_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECS_t), -1, 0, 1, 1, 1, 0, "u 'ECS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECS_t", 556, G__bankvarsDict_233_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_233_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECS_t), -1, 1, 1, 1, 1, 0, "u 'ECS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncECT_t(void) {
   /* ECT_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ECT_t));
   // automatic default constructor
   G__memfunc_setup("ECT_t", 431, G__bankvarsDict_234_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECT_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ECT_t", 431, G__bankvarsDict_234_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ECT_t), -1, 0, 1, 1, 1, 0, "u 'ECT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ECT_t", 557, G__bankvarsDict_234_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_234_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ECT_t), -1, 1, 1, 1, 1, 0, "u 'ECT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncEID0_t(void) {
   /* EID0_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_EID0_t));
   // automatic default constructor
   G__memfunc_setup("EID0_t", 469, G__bankvarsDict_235_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_EID0_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EID0_t", 469, G__bankvarsDict_235_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_EID0_t), -1, 0, 1, 1, 1, 0, "u 'EID0_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EID0_t", 595, G__bankvarsDict_235_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_235_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_EID0_t), -1, 1, 1, 1, 1, 0, "u 'EID0_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncEPIC_t(void) {
   /* EPIC_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_EPIC_t));
   // automatic default constructor
   G__memfunc_setup("EPIC_t", 500, G__bankvarsDict_236_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_EPIC_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EPIC_t", 500, G__bankvarsDict_236_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_EPIC_t), -1, 0, 1, 1, 1, 0, "u 'EPIC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EPIC_t", 626, G__bankvarsDict_236_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_236_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_EPIC_t), -1, 1, 1, 1, 1, 0, "u 'EPIC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncEVNT_t(void) {
   /* EVNT_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_EVNT_t));
   // automatic default constructor
   G__memfunc_setup("EVNT_t", 528, G__bankvarsDict_237_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_EVNT_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EVNT_t", 528, G__bankvarsDict_237_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_EVNT_t), -1, 0, 1, 1, 1, 0, "u 'EVNT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EVNT_t", 654, G__bankvarsDict_237_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_237_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_EVNT_t), -1, 1, 1, 1, 1, 0, "u 'EVNT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncFBPM_t(void) {
   /* FBPM_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_FBPM_t));
   // automatic default constructor
   G__memfunc_setup("FBPM_t", 504, G__bankvarsDict_238_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_FBPM_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("FBPM_t", 504, G__bankvarsDict_238_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_FBPM_t), -1, 0, 1, 1, 1, 0, "u 'FBPM_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~FBPM_t", 630, G__bankvarsDict_238_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_238_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_FBPM_t), -1, 1, 1, 1, 1, 0, "u 'FBPM_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncG1SL_t(void) {
   /* G1SL_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_G1SL_t));
   // automatic default constructor
   G__memfunc_setup("G1SL_t", 490, G__bankvarsDict_239_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_G1SL_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("G1SL_t", 490, G__bankvarsDict_239_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_G1SL_t), -1, 0, 1, 1, 1, 0, "u 'G1SL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~G1SL_t", 616, G__bankvarsDict_239_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_239_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_G1SL_t), -1, 1, 1, 1, 1, 0, "u 'G1SL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncG2SL_t(void) {
   /* G2SL_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_G2SL_t));
   // automatic default constructor
   G__memfunc_setup("G2SL_t", 491, G__bankvarsDict_240_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_G2SL_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("G2SL_t", 491, G__bankvarsDict_240_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_G2SL_t), -1, 0, 1, 1, 1, 0, "u 'G2SL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~G2SL_t", 617, G__bankvarsDict_240_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_240_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_G2SL_t), -1, 1, 1, 1, 1, 0, "u 'G2SL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncG3SL_t(void) {
   /* G3SL_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_G3SL_t));
   // automatic default constructor
   G__memfunc_setup("G3SL_t", 492, G__bankvarsDict_241_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_G3SL_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("G3SL_t", 492, G__bankvarsDict_241_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_G3SL_t), -1, 0, 1, 1, 1, 0, "u 'G3SL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~G3SL_t", 618, G__bankvarsDict_241_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_241_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_G3SL_t), -1, 1, 1, 1, 1, 0, "u 'G3SL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncG4SL_t(void) {
   /* G4SL_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_G4SL_t));
   // automatic default constructor
   G__memfunc_setup("G4SL_t", 493, G__bankvarsDict_242_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_G4SL_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("G4SL_t", 493, G__bankvarsDict_242_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_G4SL_t), -1, 0, 1, 1, 1, 0, "u 'G4SL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~G4SL_t", 619, G__bankvarsDict_242_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_242_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_G4SL_t), -1, 1, 1, 1, 1, 0, "u 'G4SL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncGPAR_t(void) {
   /* GPAR_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_GPAR_t));
   // automatic default constructor
   G__memfunc_setup("GPAR_t", 509, G__bankvarsDict_243_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_GPAR_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GPAR_t", 509, G__bankvarsDict_243_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_GPAR_t), -1, 0, 1, 1, 1, 0, "u 'GPAR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GPAR_t", 635, G__bankvarsDict_243_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_243_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_GPAR_t), -1, 1, 1, 1, 1, 0, "u 'GPAR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncGPID_t(void) {
   /* GPID_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_GPID_t));
   // automatic default constructor
   G__memfunc_setup("GPID_t", 503, G__bankvarsDict_244_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_GPID_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GPID_t", 503, G__bankvarsDict_244_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_GPID_t), -1, 0, 1, 1, 1, 0, "u 'GPID_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GPID_t", 629, G__bankvarsDict_244_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_244_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_GPID_t), -1, 1, 1, 1, 1, 0, "u 'GPID_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncGP_X_t(void) {
   /* GP_X_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_GP_X_t));
   // automatic default constructor
   G__memfunc_setup("GP_X_t", 545, G__bankvarsDict_245_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_GP_X_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GP_X_t", 545, G__bankvarsDict_245_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_GP_X_t), -1, 0, 1, 1, 1, 0, "u 'GP_X_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GP_X_t", 671, G__bankvarsDict_245_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_245_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_GP_X_t), -1, 1, 1, 1, 1, 0, "u 'GP_X_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncGP_Y_t(void) {
   /* GP_Y_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_GP_Y_t));
   // automatic default constructor
   G__memfunc_setup("GP_Y_t", 546, G__bankvarsDict_246_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_GP_Y_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GP_Y_t", 546, G__bankvarsDict_246_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_GP_Y_t), -1, 0, 1, 1, 1, 0, "u 'GP_Y_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GP_Y_t", 672, G__bankvarsDict_246_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_246_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_GP_Y_t), -1, 1, 1, 1, 1, 0, "u 'GP_Y_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncHBER_t(void) {
   /* HBER_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HBER_t));
   // automatic default constructor
   G__memfunc_setup("HBER_t", 500, G__bankvarsDict_247_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HBER_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("HBER_t", 500, G__bankvarsDict_247_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HBER_t), -1, 0, 1, 1, 1, 0, "u 'HBER_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~HBER_t", 626, G__bankvarsDict_247_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_247_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_HBER_t), -1, 1, 1, 1, 1, 0, "u 'HBER_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncHBID_t(void) {
   /* HBID_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HBID_t));
   // automatic default constructor
   G__memfunc_setup("HBID_t", 490, G__bankvarsDict_248_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HBID_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("HBID_t", 490, G__bankvarsDict_248_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HBID_t), -1, 0, 1, 1, 1, 0, "u 'HBID_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~HBID_t", 616, G__bankvarsDict_248_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_248_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_HBID_t), -1, 1, 1, 1, 1, 0, "u 'HBID_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncHBLA_t(void) {
   /* HBLA_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HBLA_t));
   // automatic default constructor
   G__memfunc_setup("HBLA_t", 490, G__bankvarsDict_249_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HBLA_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("HBLA_t", 490, G__bankvarsDict_249_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HBLA_t), -1, 0, 1, 1, 1, 0, "u 'HBLA_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~HBLA_t", 616, G__bankvarsDict_249_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_249_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_HBLA_t), -1, 1, 1, 1, 1, 0, "u 'HBLA_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncHBTB_t(void) {
   /* HBTB_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HBTB_t));
   // automatic default constructor
   G__memfunc_setup("HBTB_t", 499, G__bankvarsDict_250_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HBTB_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("HBTB_t", 499, G__bankvarsDict_250_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HBTB_t), -1, 0, 1, 1, 1, 0, "u 'HBTB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~HBTB_t", 625, G__bankvarsDict_250_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_250_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_HBTB_t), -1, 1, 1, 1, 1, 0, "u 'HBTB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncHBTR_t(void) {
   /* HBTR_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HBTR_t));
   // automatic default constructor
   G__memfunc_setup("HBTR_t", 515, G__bankvarsDict_251_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HBTR_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("HBTR_t", 515, G__bankvarsDict_251_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HBTR_t), -1, 0, 1, 1, 1, 0, "u 'HBTR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~HBTR_t", 641, G__bankvarsDict_251_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_251_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_HBTR_t), -1, 1, 1, 1, 1, 0, "u 'HBTR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncHCAL_t(void) {
   /* HCAL_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HCAL_t));
   // automatic default constructor
   G__memfunc_setup("HCAL_t", 491, G__bankvarsDict_252_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HCAL_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("HCAL_t", 491, G__bankvarsDict_252_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HCAL_t), -1, 0, 1, 1, 1, 0, "u 'HCAL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~HCAL_t", 617, G__bankvarsDict_252_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_252_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_HCAL_t), -1, 1, 1, 1, 1, 0, "u 'HCAL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncHDPL_t(void) {
   /* HDPL_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HDPL_t));
   // automatic default constructor
   G__memfunc_setup("HDPL_t", 507, G__bankvarsDict_253_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HDPL_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("HDPL_t", 507, G__bankvarsDict_253_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HDPL_t), -1, 0, 1, 1, 1, 0, "u 'HDPL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~HDPL_t", 633, G__bankvarsDict_253_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_253_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_HDPL_t), -1, 1, 1, 1, 1, 0, "u 'HDPL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncHEAD_t(void) {
   /* HEAD_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HEAD_t));
   // automatic default constructor
   G__memfunc_setup("HEAD_t", 485, G__bankvarsDict_254_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HEAD_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("HEAD_t", 485, G__bankvarsDict_254_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HEAD_t), -1, 0, 1, 1, 1, 0, "u 'HEAD_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~HEAD_t", 611, G__bankvarsDict_254_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_254_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_HEAD_t), -1, 1, 1, 1, 1, 0, "u 'HEAD_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncHEVT_t(void) {
   /* HEVT_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HEVT_t));
   // automatic default constructor
   G__memfunc_setup("HEVT_t", 522, G__bankvarsDict_255_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HEVT_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("HEVT_t", 522, G__bankvarsDict_255_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HEVT_t), -1, 0, 1, 1, 1, 0, "u 'HEVT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~HEVT_t", 648, G__bankvarsDict_255_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_255_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_HEVT_t), -1, 1, 1, 1, 1, 0, "u 'HEVT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncHLS_t(void) {
   /* HLS_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_HLS_t));
   // automatic default constructor
   G__memfunc_setup("HLS_t", 442, G__bankvarsDict_256_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HLS_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("HLS_t", 442, G__bankvarsDict_256_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_HLS_t), -1, 0, 1, 1, 1, 0, "u 'HLS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~HLS_t", 568, G__bankvarsDict_256_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_256_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_HLS_t), -1, 1, 1, 1, 1, 0, "u 'HLS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncIC_t(void) {
   /* IC_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_IC_t));
   // automatic default constructor
   G__memfunc_setup("IC_t", 351, G__bankvarsDict_257_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_IC_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("IC_t", 351, G__bankvarsDict_257_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_IC_t), -1, 0, 1, 1, 1, 0, "u 'IC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~IC_t", 477, G__bankvarsDict_257_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_257_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_IC_t), -1, 1, 1, 1, 1, 0, "u 'IC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncICHB_t(void) {
   /* ICHB_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ICHB_t));
   // automatic default constructor
   G__memfunc_setup("ICHB_t", 489, G__bankvarsDict_258_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ICHB_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ICHB_t", 489, G__bankvarsDict_258_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ICHB_t), -1, 0, 1, 1, 1, 0, "u 'ICHB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ICHB_t", 615, G__bankvarsDict_258_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_258_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ICHB_t), -1, 1, 1, 1, 1, 0, "u 'ICHB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncKFIT_t(void) {
   /* KFIT_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_KFIT_t));
   // automatic default constructor
   G__memfunc_setup("KFIT_t", 513, G__bankvarsDict_259_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_KFIT_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("KFIT_t", 513, G__bankvarsDict_259_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_KFIT_t), -1, 0, 1, 1, 1, 0, "u 'KFIT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~KFIT_t", 639, G__bankvarsDict_259_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_259_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_KFIT_t), -1, 1, 1, 1, 1, 0, "u 'KFIT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncL1PG_t(void) {
   /* L1PG_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_L1PG_t));
   // automatic default constructor
   G__memfunc_setup("L1PG_t", 487, G__bankvarsDict_260_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_L1PG_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("L1PG_t", 487, G__bankvarsDict_260_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_L1PG_t), -1, 0, 1, 1, 1, 0, "u 'L1PG_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~L1PG_t", 613, G__bankvarsDict_260_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_260_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_L1PG_t), -1, 1, 1, 1, 1, 0, "u 'L1PG_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncL2H_t(void) {
   /* L2H_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_L2H_t));
   // automatic default constructor
   G__memfunc_setup("L2H_t", 409, G__bankvarsDict_261_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_L2H_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("L2H_t", 409, G__bankvarsDict_261_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_L2H_t), -1, 0, 1, 1, 1, 0, "u 'L2H_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~L2H_t", 535, G__bankvarsDict_261_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_261_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_L2H_t), -1, 1, 1, 1, 1, 0, "u 'L2H_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncL2S_t(void) {
   /* L2S_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_L2S_t));
   // automatic default constructor
   G__memfunc_setup("L2S_t", 420, G__bankvarsDict_262_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_L2S_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("L2S_t", 420, G__bankvarsDict_262_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_L2S_t), -1, 0, 1, 1, 1, 0, "u 'L2S_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~L2S_t", 546, G__bankvarsDict_262_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_262_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_L2S_t), -1, 1, 1, 1, 1, 0, "u 'L2S_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncLASR_t(void) {
   /* LASR_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_LASR_t));
   // automatic default constructor
   G__memfunc_setup("LASR_t", 517, G__bankvarsDict_263_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_LASR_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("LASR_t", 517, G__bankvarsDict_263_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_LASR_t), -1, 0, 1, 1, 1, 0, "u 'LASR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~LASR_t", 643, G__bankvarsDict_263_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_263_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_LASR_t), -1, 1, 1, 1, 1, 0, "u 'LASR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncLCDI_t(void) {
   /* LCDI_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_LCDI_t));
   // automatic default constructor
   G__memfunc_setup("LCDI_t", 495, G__bankvarsDict_264_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_LCDI_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("LCDI_t", 495, G__bankvarsDict_264_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_LCDI_t), -1, 0, 1, 1, 1, 0, "u 'LCDI_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~LCDI_t", 621, G__bankvarsDict_264_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_264_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_LCDI_t), -1, 1, 1, 1, 1, 0, "u 'LCDI_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncLCPB_t(void) {
   /* LCPB_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_LCPB_t));
   // automatic default constructor
   G__memfunc_setup("LCPB_t", 500, G__bankvarsDict_265_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_LCPB_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("LCPB_t", 500, G__bankvarsDict_265_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_LCPB_t), -1, 0, 1, 1, 1, 0, "u 'LCPB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~LCPB_t", 626, G__bankvarsDict_265_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_265_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_LCPB_t), -1, 1, 1, 1, 1, 0, "u 'LCPB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncLOWQ_t(void) {
   /* LOWQ_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_LOWQ_t));
   // automatic default constructor
   G__memfunc_setup("LOWQ_t", 534, G__bankvarsDict_266_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_LOWQ_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("LOWQ_t", 534, G__bankvarsDict_266_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_LOWQ_t), -1, 0, 1, 1, 1, 0, "u 'LOWQ_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~LOWQ_t", 660, G__bankvarsDict_266_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_266_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_LOWQ_t), -1, 1, 1, 1, 1, 0, "u 'LOWQ_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncMCEV_t(void) {
   /* MCEV_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_MCEV_t));
   // automatic default constructor
   G__memfunc_setup("MCEV_t", 510, G__bankvarsDict_267_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_MCEV_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("MCEV_t", 510, G__bankvarsDict_267_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_MCEV_t), -1, 0, 1, 1, 1, 0, "u 'MCEV_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~MCEV_t", 636, G__bankvarsDict_267_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_267_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_MCEV_t), -1, 1, 1, 1, 1, 0, "u 'MCEV_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncMCHD_t(void) {
   /* MCHD_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_MCHD_t));
   // automatic default constructor
   G__memfunc_setup("MCHD_t", 495, G__bankvarsDict_268_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_MCHD_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("MCHD_t", 495, G__bankvarsDict_268_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_MCHD_t), -1, 0, 1, 1, 1, 0, "u 'MCHD_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~MCHD_t", 621, G__bankvarsDict_268_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_268_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_MCHD_t), -1, 1, 1, 1, 1, 0, "u 'MCHD_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncMCTK_t(void) {
   /* MCTK_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_MCTK_t));
   // automatic default constructor
   G__memfunc_setup("MCTK_t", 514, G__bankvarsDict_269_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_MCTK_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("MCTK_t", 514, G__bankvarsDict_269_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_MCTK_t), -1, 0, 1, 1, 1, 0, "u 'MCTK_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~MCTK_t", 640, G__bankvarsDict_269_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_269_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_MCTK_t), -1, 1, 1, 1, 1, 0, "u 'MCTK_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncMCVX_t(void) {
   /* MCVX_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_MCVX_t));
   // automatic default constructor
   G__memfunc_setup("MCVX_t", 529, G__bankvarsDict_270_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_MCVX_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("MCVX_t", 529, G__bankvarsDict_270_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_MCVX_t), -1, 0, 1, 1, 1, 0, "u 'MCVX_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~MCVX_t", 655, G__bankvarsDict_270_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_270_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_MCVX_t), -1, 1, 1, 1, 1, 0, "u 'MCVX_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncMS1_t(void) {
   /* MS1_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_MS1_t));
   // automatic default constructor
   G__memfunc_setup("MS1_t", 420, G__bankvarsDict_271_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_MS1_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("MS1_t", 420, G__bankvarsDict_271_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_MS1_t), -1, 0, 1, 1, 1, 0, "u 'MS1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~MS1_t", 546, G__bankvarsDict_271_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_271_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_MS1_t), -1, 1, 1, 1, 1, 0, "u 'MS1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncMTRK_t(void) {
   /* MTRK_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_MTRK_t));
   // automatic default constructor
   G__memfunc_setup("MTRK_t", 529, G__bankvarsDict_272_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_MTRK_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("MTRK_t", 529, G__bankvarsDict_272_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_MTRK_t), -1, 0, 1, 1, 1, 0, "u 'MTRK_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~MTRK_t", 655, G__bankvarsDict_272_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_272_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_MTRK_t), -1, 1, 1, 1, 1, 0, "u 'MTRK_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncMVRT_t(void) {
   /* MVRT_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_MVRT_t));
   // automatic default constructor
   G__memfunc_setup("MVRT_t", 540, G__bankvarsDict_273_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_MVRT_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("MVRT_t", 540, G__bankvarsDict_273_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_MVRT_t), -1, 0, 1, 1, 1, 0, "u 'MVRT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~MVRT_t", 666, G__bankvarsDict_273_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_273_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_MVRT_t), -1, 1, 1, 1, 1, 0, "u 'MVRT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPART_t(void) {
   /* PART_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PART_t));
   // automatic default constructor
   G__memfunc_setup("PART_t", 522, G__bankvarsDict_274_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PART_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PART_t", 522, G__bankvarsDict_274_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PART_t), -1, 0, 1, 1, 1, 0, "u 'PART_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PART_t", 648, G__bankvarsDict_274_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_274_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_PART_t), -1, 1, 1, 1, 1, 0, "u 'PART_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPCO_t(void) {
   /* PCO_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PCO_t));
   // automatic default constructor
   G__memfunc_setup("PCO_t", 437, G__bankvarsDict_275_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PCO_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PCO_t", 437, G__bankvarsDict_275_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PCO_t), -1, 0, 1, 1, 1, 0, "u 'PCO_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PCO_t", 563, G__bankvarsDict_275_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_275_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_PCO_t), -1, 1, 1, 1, 1, 0, "u 'PCO_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPHTM_t(void) {
   /* PHTM_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PHTM_t));
   // automatic default constructor
   G__memfunc_setup("PHTM_t", 524, G__bankvarsDict_276_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PHTM_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PHTM_t", 524, G__bankvarsDict_276_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PHTM_t), -1, 0, 1, 1, 1, 0, "u 'PHTM_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PHTM_t", 650, G__bankvarsDict_276_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_276_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_PHTM_t), -1, 1, 1, 1, 1, 0, "u 'PHTM_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPID1_t(void) {
   /* PID1_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PID1_t));
   // automatic default constructor
   G__memfunc_setup("PID1_t", 481, G__bankvarsDict_277_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PID1_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PID1_t", 481, G__bankvarsDict_277_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PID1_t), -1, 0, 1, 1, 1, 0, "u 'PID1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PID1_t", 607, G__bankvarsDict_277_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_277_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_PID1_t), -1, 1, 1, 1, 1, 0, "u 'PID1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPID2_t(void) {
   /* PID2_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PID2_t));
   // automatic default constructor
   G__memfunc_setup("PID2_t", 482, G__bankvarsDict_278_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PID2_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PID2_t", 482, G__bankvarsDict_278_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PID2_t), -1, 0, 1, 1, 1, 0, "u 'PID2_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PID2_t", 608, G__bankvarsDict_278_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_278_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_PID2_t), -1, 1, 1, 1, 1, 0, "u 'PID2_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPID3_t(void) {
   /* PID3_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PID3_t));
   // automatic default constructor
   G__memfunc_setup("PID3_t", 483, G__bankvarsDict_279_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PID3_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PID3_t", 483, G__bankvarsDict_279_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PID3_t), -1, 0, 1, 1, 1, 0, "u 'PID3_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PID3_t", 609, G__bankvarsDict_279_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_279_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_PID3_t), -1, 1, 1, 1, 1, 0, "u 'PID3_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPID4_t(void) {
   /* PID4_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PID4_t));
   // automatic default constructor
   G__memfunc_setup("PID4_t", 484, G__bankvarsDict_280_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PID4_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PID4_t", 484, G__bankvarsDict_280_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PID4_t), -1, 0, 1, 1, 1, 0, "u 'PID4_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PID4_t", 610, G__bankvarsDict_280_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_280_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_PID4_t), -1, 1, 1, 1, 1, 0, "u 'PID4_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPID5_t(void) {
   /* PID5_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PID5_t));
   // automatic default constructor
   G__memfunc_setup("PID5_t", 485, G__bankvarsDict_281_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PID5_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PID5_t", 485, G__bankvarsDict_281_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PID5_t), -1, 0, 1, 1, 1, 0, "u 'PID5_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PID5_t", 611, G__bankvarsDict_281_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_281_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_PID5_t), -1, 1, 1, 1, 1, 0, "u 'PID5_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPID6_t(void) {
   /* PID6_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PID6_t));
   // automatic default constructor
   G__memfunc_setup("PID6_t", 486, G__bankvarsDict_282_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PID6_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PID6_t", 486, G__bankvarsDict_282_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PID6_t), -1, 0, 1, 1, 1, 0, "u 'PID6_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PID6_t", 612, G__bankvarsDict_282_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_282_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_PID6_t), -1, 1, 1, 1, 1, 0, "u 'PID6_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPIDT_t(void) {
   /* PIDT_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PIDT_t));
   // automatic default constructor
   G__memfunc_setup("PIDT_t", 516, G__bankvarsDict_283_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PIDT_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PIDT_t", 516, G__bankvarsDict_283_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PIDT_t), -1, 0, 1, 1, 1, 0, "u 'PIDT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PIDT_t", 642, G__bankvarsDict_283_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_283_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_PIDT_t), -1, 1, 1, 1, 1, 0, "u 'PIDT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPRTM_t(void) {
   /* PRTM_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PRTM_t));
   // automatic default constructor
   G__memfunc_setup("PRTM_t", 534, G__bankvarsDict_284_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PRTM_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PRTM_t", 534, G__bankvarsDict_284_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PRTM_t), -1, 0, 1, 1, 1, 0, "u 'PRTM_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PRTM_t", 660, G__bankvarsDict_284_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_284_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_PRTM_t), -1, 1, 1, 1, 1, 0, "u 'PRTM_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPSO_t(void) {
   /* PSO_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PSO_t));
   // automatic default constructor
   G__memfunc_setup("PSO_t", 453, G__bankvarsDict_285_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PSO_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PSO_t", 453, G__bankvarsDict_285_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PSO_t), -1, 0, 1, 1, 1, 0, "u 'PSO_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PSO_t", 579, G__bankvarsDict_285_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_285_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_PSO_t), -1, 1, 1, 1, 1, 0, "u 'PSO_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPTDB_t(void) {
   /* PTDB_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_PTDB_t));
   // automatic default constructor
   G__memfunc_setup("PTDB_t", 509, G__bankvarsDict_286_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PTDB_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PTDB_t", 509, G__bankvarsDict_286_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_PTDB_t), -1, 0, 1, 1, 1, 0, "u 'PTDB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PTDB_t", 635, G__bankvarsDict_286_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_286_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_PTDB_t), -1, 1, 1, 1, 1, 0, "u 'PTDB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncRCST_t(void) {
   /* RCST_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RCST_t));
   // automatic default constructor
   G__memfunc_setup("RCST_t", 527, G__bankvarsDict_287_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RCST_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("RCST_t", 527, G__bankvarsDict_287_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RCST_t), -1, 0, 1, 1, 1, 0, "u 'RCST_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RCST_t", 653, G__bankvarsDict_287_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_287_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_RCST_t), -1, 1, 1, 1, 1, 0, "u 'RCST_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncREF_t(void) {
   /* REF_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_REF_t));
   // automatic default constructor
   G__memfunc_setup("REF_t", 432, G__bankvarsDict_288_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_REF_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("REF_t", 432, G__bankvarsDict_288_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_REF_t), -1, 0, 1, 1, 1, 0, "u 'REF_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~REF_t", 558, G__bankvarsDict_288_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_288_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_REF_t), -1, 1, 1, 1, 1, 0, "u 'REF_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncRF_t(void) {
   /* RF_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RF_t));
   // automatic default constructor
   G__memfunc_setup("RF_t", 363, G__bankvarsDict_289_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RF_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("RF_t", 363, G__bankvarsDict_289_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RF_t), -1, 0, 1, 1, 1, 0, "u 'RF_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RF_t", 489, G__bankvarsDict_289_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_289_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_RF_t), -1, 1, 1, 1, 1, 0, "u 'RF_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncRFT_t(void) {
   /* RFT_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RFT_t));
   // automatic default constructor
   G__memfunc_setup("RFT_t", 447, G__bankvarsDict_290_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RFT_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("RFT_t", 447, G__bankvarsDict_290_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RFT_t), -1, 0, 1, 1, 1, 0, "u 'RFT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RFT_t", 573, G__bankvarsDict_290_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_290_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_RFT_t), -1, 1, 1, 1, 1, 0, "u 'RFT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncRGLK_t(void) {
   /* RGLK_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RGLK_t));
   // automatic default constructor
   G__memfunc_setup("RGLK_t", 515, G__bankvarsDict_291_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RGLK_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("RGLK_t", 515, G__bankvarsDict_291_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RGLK_t), -1, 0, 1, 1, 1, 0, "u 'RGLK_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RGLK_t", 641, G__bankvarsDict_291_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_291_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_RGLK_t), -1, 1, 1, 1, 1, 0, "u 'RGLK_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncRNLG_t(void) {
   /* RNLG_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RNLG_t));
   // automatic default constructor
   G__memfunc_setup("RNLG_t", 518, G__bankvarsDict_292_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RNLG_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("RNLG_t", 518, G__bankvarsDict_292_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RNLG_t), -1, 0, 1, 1, 1, 0, "u 'RNLG_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RNLG_t", 644, G__bankvarsDict_292_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_292_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_RNLG_t), -1, 1, 1, 1, 1, 0, "u 'RNLG_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncRNPE_t(void) {
   /* RNPE_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RNPE_t));
   // automatic default constructor
   G__memfunc_setup("RNPE_t", 520, G__bankvarsDict_293_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RNPE_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("RNPE_t", 520, G__bankvarsDict_293_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RNPE_t), -1, 0, 1, 1, 1, 0, "u 'RNPE_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RNPE_t", 646, G__bankvarsDict_293_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_293_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_RNPE_t), -1, 1, 1, 1, 1, 0, "u 'RNPE_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncRTSL_t(void) {
   /* RTSL_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RTSL_t));
   // automatic default constructor
   G__memfunc_setup("RTSL_t", 536, G__bankvarsDict_294_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RTSL_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("RTSL_t", 536, G__bankvarsDict_294_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RTSL_t), -1, 0, 1, 1, 1, 0, "u 'RTSL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RTSL_t", 662, G__bankvarsDict_294_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_294_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_RTSL_t), -1, 1, 1, 1, 1, 0, "u 'RTSL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncRUNC_t(void) {
   /* RUNC_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RUNC_t));
   // automatic default constructor
   G__memfunc_setup("RUNC_t", 523, G__bankvarsDict_295_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RUNC_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("RUNC_t", 523, G__bankvarsDict_295_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RUNC_t), -1, 0, 1, 1, 1, 0, "u 'RUNC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RUNC_t", 649, G__bankvarsDict_295_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_295_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_RUNC_t), -1, 1, 1, 1, 1, 0, "u 'RUNC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncS1ST_t(void) {
   /* S1ST_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_S1ST_t));
   // automatic default constructor
   G__memfunc_setup("S1ST_t", 510, G__bankvarsDict_296_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_S1ST_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("S1ST_t", 510, G__bankvarsDict_296_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_S1ST_t), -1, 0, 1, 1, 1, 0, "u 'S1ST_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~S1ST_t", 636, G__bankvarsDict_296_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_296_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_S1ST_t), -1, 1, 1, 1, 1, 0, "u 'S1ST_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSC1_t(void) {
   /* SC1_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SC1_t));
   // automatic default constructor
   G__memfunc_setup("SC1_t", 410, G__bankvarsDict_297_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SC1_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SC1_t", 410, G__bankvarsDict_297_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SC1_t), -1, 0, 1, 1, 1, 0, "u 'SC1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SC1_t", 536, G__bankvarsDict_297_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_297_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SC1_t), -1, 1, 1, 1, 1, 0, "u 'SC1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSCC_t(void) {
   /* SCC_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCC_t));
   // automatic default constructor
   G__memfunc_setup("SCC_t", 428, G__bankvarsDict_298_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCC_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SCC_t", 428, G__bankvarsDict_298_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCC_t), -1, 0, 1, 1, 1, 0, "u 'SCC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SCC_t", 554, G__bankvarsDict_298_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_298_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SCC_t), -1, 1, 1, 1, 1, 0, "u 'SCC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSC_t(void) {
   /* SC_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SC_t));
   // automatic default constructor
   G__memfunc_setup("SC_t", 361, G__bankvarsDict_299_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SC_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SC_t", 361, G__bankvarsDict_299_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SC_t), -1, 0, 1, 1, 1, 0, "u 'SC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SC_t", 487, G__bankvarsDict_299_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_299_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SC_t), -1, 1, 1, 1, 1, 0, "u 'SC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSCDI_t(void) {
   /* SCDI_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCDI_t));
   // automatic default constructor
   G__memfunc_setup("SCDI_t", 502, G__bankvarsDict_300_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCDI_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SCDI_t", 502, G__bankvarsDict_300_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCDI_t), -1, 0, 1, 1, 1, 0, "u 'SCDI_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SCDI_t", 628, G__bankvarsDict_300_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_300_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SCDI_t), -1, 1, 1, 1, 1, 0, "u 'SCDI_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSCGD_t(void) {
   /* SCGD_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCGD_t));
   // automatic default constructor
   G__memfunc_setup("SCGD_t", 500, G__bankvarsDict_301_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCGD_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SCGD_t", 500, G__bankvarsDict_301_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCGD_t), -1, 0, 1, 1, 1, 0, "u 'SCGD_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SCGD_t", 626, G__bankvarsDict_301_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_301_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SCGD_t), -1, 1, 1, 1, 1, 0, "u 'SCGD_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSCG_t(void) {
   /* SCG_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCG_t));
   // automatic default constructor
   G__memfunc_setup("SCG_t", 432, G__bankvarsDict_302_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCG_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SCG_t", 432, G__bankvarsDict_302_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCG_t), -1, 0, 1, 1, 1, 0, "u 'SCG_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SCG_t", 558, G__bankvarsDict_302_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_302_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SCG_t), -1, 1, 1, 1, 1, 0, "u 'SCG_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSCH_t(void) {
   /* SCH_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCH_t));
   // automatic default constructor
   G__memfunc_setup("SCH_t", 433, G__bankvarsDict_303_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCH_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SCH_t", 433, G__bankvarsDict_303_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCH_t), -1, 0, 1, 1, 1, 0, "u 'SCH_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SCH_t", 559, G__bankvarsDict_303_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_303_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SCH_t), -1, 1, 1, 1, 1, 0, "u 'SCH_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSCMD_t(void) {
   /* SCMD_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCMD_t));
   // automatic default constructor
   G__memfunc_setup("SCMD_t", 506, G__bankvarsDict_304_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCMD_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SCMD_t", 506, G__bankvarsDict_304_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCMD_t), -1, 0, 1, 1, 1, 0, "u 'SCMD_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SCMD_t", 632, G__bankvarsDict_304_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_304_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SCMD_t), -1, 1, 1, 1, 1, 0, "u 'SCMD_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSCMT_t(void) {
   /* SCMT_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCMT_t));
   // automatic default constructor
   G__memfunc_setup("SCMT_t", 522, G__bankvarsDict_305_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCMT_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SCMT_t", 522, G__bankvarsDict_305_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCMT_t), -1, 0, 1, 1, 1, 0, "u 'SCMT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SCMT_t", 648, G__bankvarsDict_305_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_305_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SCMT_t), -1, 1, 1, 1, 1, 0, "u 'SCMT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSCMW_t(void) {
   /* SCMW_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCMW_t));
   // automatic default constructor
   G__memfunc_setup("SCMW_t", 525, G__bankvarsDict_306_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCMW_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SCMW_t", 525, G__bankvarsDict_306_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCMW_t), -1, 0, 1, 1, 1, 0, "u 'SCMW_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SCMW_t", 651, G__bankvarsDict_306_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_306_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SCMW_t), -1, 1, 1, 1, 1, 0, "u 'SCMW_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSCPB_t(void) {
   /* SCPB_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCPB_t));
   // automatic default constructor
   G__memfunc_setup("SCPB_t", 507, G__bankvarsDict_307_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCPB_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SCPB_t", 507, G__bankvarsDict_307_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCPB_t), -1, 0, 1, 1, 1, 0, "u 'SCPB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SCPB_t", 633, G__bankvarsDict_307_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_307_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SCPB_t), -1, 1, 1, 1, 1, 0, "u 'SCPB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSCP_t(void) {
   /* SCP_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCP_t));
   // automatic default constructor
   G__memfunc_setup("SCP_t", 441, G__bankvarsDict_308_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCP_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SCP_t", 441, G__bankvarsDict_308_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCP_t), -1, 0, 1, 1, 1, 0, "u 'SCP_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SCP_t", 567, G__bankvarsDict_308_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_308_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SCP_t), -1, 1, 1, 1, 1, 0, "u 'SCP_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSCPE_t(void) {
   /* SCPE_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCPE_t));
   // automatic default constructor
   G__memfunc_setup("SCPE_t", 510, G__bankvarsDict_309_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCPE_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SCPE_t", 510, G__bankvarsDict_309_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCPE_t), -1, 0, 1, 1, 1, 0, "u 'SCPE_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SCPE_t", 636, G__bankvarsDict_309_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_309_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SCPE_t), -1, 1, 1, 1, 1, 0, "u 'SCPE_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSCPS_t(void) {
   /* SCPS_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCPS_t));
   // automatic default constructor
   G__memfunc_setup("SCPS_t", 524, G__bankvarsDict_310_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCPS_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SCPS_t", 524, G__bankvarsDict_310_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCPS_t), -1, 0, 1, 1, 1, 0, "u 'SCPS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SCPS_t", 650, G__bankvarsDict_310_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_310_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SCPS_t), -1, 1, 1, 1, 1, 0, "u 'SCPS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSCRC_t(void) {
   /* SCRC_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCRC_t));
   // automatic default constructor
   G__memfunc_setup("SCRC_t", 510, G__bankvarsDict_311_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCRC_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SCRC_t", 510, G__bankvarsDict_311_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCRC_t), -1, 0, 1, 1, 1, 0, "u 'SCRC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SCRC_t", 636, G__bankvarsDict_311_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_311_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SCRC_t), -1, 1, 1, 1, 1, 0, "u 'SCRC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSCR_t(void) {
   /* SCR_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCR_t));
   // automatic default constructor
   G__memfunc_setup("SCR_t", 443, G__bankvarsDict_312_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCR_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SCR_t", 443, G__bankvarsDict_312_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCR_t), -1, 0, 1, 1, 1, 0, "u 'SCR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SCR_t", 569, G__bankvarsDict_312_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_312_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SCR_t), -1, 1, 1, 1, 1, 0, "u 'SCR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSCS_t(void) {
   /* SCS_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCS_t));
   // automatic default constructor
   G__memfunc_setup("SCS_t", 444, G__bankvarsDict_313_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCS_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SCS_t", 444, G__bankvarsDict_313_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCS_t), -1, 0, 1, 1, 1, 0, "u 'SCS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SCS_t", 570, G__bankvarsDict_313_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_313_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SCS_t), -1, 1, 1, 1, 1, 0, "u 'SCS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSCT_t(void) {
   /* SCT_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SCT_t));
   // automatic default constructor
   G__memfunc_setup("SCT_t", 445, G__bankvarsDict_314_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCT_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SCT_t", 445, G__bankvarsDict_314_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SCT_t), -1, 0, 1, 1, 1, 0, "u 'SCT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SCT_t", 571, G__bankvarsDict_314_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_314_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SCT_t), -1, 1, 1, 1, 1, 0, "u 'SCT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSGMP_t(void) {
   /* SGMP_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SGMP_t));
   // automatic default constructor
   G__memfunc_setup("SGMP_t", 522, G__bankvarsDict_315_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SGMP_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SGMP_t", 522, G__bankvarsDict_315_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SGMP_t), -1, 0, 1, 1, 1, 0, "u 'SGMP_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SGMP_t", 648, G__bankvarsDict_315_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_315_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SGMP_t), -1, 1, 1, 1, 1, 0, "u 'SGMP_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSPAR_t(void) {
   /* SPAR_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SPAR_t));
   // automatic default constructor
   G__memfunc_setup("SPAR_t", 521, G__bankvarsDict_316_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SPAR_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SPAR_t", 521, G__bankvarsDict_316_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SPAR_t), -1, 0, 1, 1, 1, 0, "u 'SPAR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SPAR_t", 647, G__bankvarsDict_316_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_316_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SPAR_t), -1, 1, 1, 1, 1, 0, "u 'SPAR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSPIN_t(void) {
   /* SPIN_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SPIN_t));
   // automatic default constructor
   G__memfunc_setup("SPIN_t", 525, G__bankvarsDict_317_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SPIN_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SPIN_t", 525, G__bankvarsDict_317_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SPIN_t), -1, 0, 1, 1, 1, 0, "u 'SPIN_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SPIN_t", 651, G__bankvarsDict_317_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_317_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SPIN_t), -1, 1, 1, 1, 1, 0, "u 'SPIN_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncST1_t(void) {
   /* ST1_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ST1_t));
   // automatic default constructor
   G__memfunc_setup("ST1_t", 427, G__bankvarsDict_318_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ST1_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ST1_t", 427, G__bankvarsDict_318_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ST1_t), -1, 0, 1, 1, 1, 0, "u 'ST1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ST1_t", 553, G__bankvarsDict_318_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_318_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ST1_t), -1, 1, 1, 1, 1, 0, "u 'ST1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncST_t(void) {
   /* ST_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_ST_t));
   // automatic default constructor
   G__memfunc_setup("ST_t", 378, G__bankvarsDict_319_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ST_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ST_t", 378, G__bankvarsDict_319_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_ST_t), -1, 0, 1, 1, 1, 0, "u 'ST_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ST_t", 504, G__bankvarsDict_319_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_319_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_ST_t), -1, 1, 1, 1, 1, 0, "u 'ST_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSTG_t(void) {
   /* STG_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STG_t));
   // automatic default constructor
   G__memfunc_setup("STG_t", 449, G__bankvarsDict_320_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STG_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("STG_t", 449, G__bankvarsDict_320_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STG_t), -1, 0, 1, 1, 1, 0, "u 'STG_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~STG_t", 575, G__bankvarsDict_320_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_320_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_STG_t), -1, 1, 1, 1, 1, 0, "u 'STG_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSTH_t(void) {
   /* STH_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STH_t));
   // automatic default constructor
   G__memfunc_setup("STH_t", 450, G__bankvarsDict_321_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STH_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("STH_t", 450, G__bankvarsDict_321_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STH_t), -1, 0, 1, 1, 1, 0, "u 'STH_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~STH_t", 576, G__bankvarsDict_321_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_321_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_STH_t), -1, 1, 1, 1, 1, 0, "u 'STH_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSTN0_t(void) {
   /* STN0_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STN0_t));
   // automatic default constructor
   G__memfunc_setup("STN0_t", 504, G__bankvarsDict_322_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STN0_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("STN0_t", 504, G__bankvarsDict_322_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STN0_t), -1, 0, 1, 1, 1, 0, "u 'STN0_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~STN0_t", 630, G__bankvarsDict_322_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_322_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_STN0_t), -1, 1, 1, 1, 1, 0, "u 'STN0_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSTN1_t(void) {
   /* STN1_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STN1_t));
   // automatic default constructor
   G__memfunc_setup("STN1_t", 505, G__bankvarsDict_323_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STN1_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("STN1_t", 505, G__bankvarsDict_323_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STN1_t), -1, 0, 1, 1, 1, 0, "u 'STN1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~STN1_t", 631, G__bankvarsDict_323_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_323_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_STN1_t), -1, 1, 1, 1, 1, 0, "u 'STN1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSTPB_t(void) {
   /* STPB_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STPB_t));
   // automatic default constructor
   G__memfunc_setup("STPB_t", 524, G__bankvarsDict_324_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STPB_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("STPB_t", 524, G__bankvarsDict_324_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STPB_t), -1, 0, 1, 1, 1, 0, "u 'STPB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~STPB_t", 650, G__bankvarsDict_324_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_324_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_STPB_t), -1, 1, 1, 1, 1, 0, "u 'STPB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSTPE_t(void) {
   /* STPE_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STPE_t));
   // automatic default constructor
   G__memfunc_setup("STPE_t", 527, G__bankvarsDict_325_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STPE_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("STPE_t", 527, G__bankvarsDict_325_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STPE_t), -1, 0, 1, 1, 1, 0, "u 'STPE_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~STPE_t", 653, G__bankvarsDict_325_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_325_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_STPE_t), -1, 1, 1, 1, 1, 0, "u 'STPE_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSTR_t(void) {
   /* STR_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STR_t));
   // automatic default constructor
   G__memfunc_setup("STR_t", 460, G__bankvarsDict_326_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STR_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("STR_t", 460, G__bankvarsDict_326_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STR_t), -1, 0, 1, 1, 1, 0, "u 'STR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~STR_t", 586, G__bankvarsDict_326_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_326_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_STR_t), -1, 1, 1, 1, 1, 0, "u 'STR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSTS_t(void) {
   /* STS_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STS_t));
   // automatic default constructor
   G__memfunc_setup("STS_t", 461, G__bankvarsDict_327_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STS_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("STS_t", 461, G__bankvarsDict_327_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STS_t), -1, 0, 1, 1, 1, 0, "u 'STS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~STS_t", 587, G__bankvarsDict_327_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_327_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_STS_t), -1, 1, 1, 1, 1, 0, "u 'STS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSTSN_t(void) {
   /* STSN_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STSN_t));
   // automatic default constructor
   G__memfunc_setup("STSN_t", 539, G__bankvarsDict_328_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STSN_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("STSN_t", 539, G__bankvarsDict_328_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STSN_t), -1, 0, 1, 1, 1, 0, "u 'STSN_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~STSN_t", 665, G__bankvarsDict_328_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_328_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_STSN_t), -1, 1, 1, 1, 1, 0, "u 'STSN_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSYNC_t(void) {
   /* SYNC_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_SYNC_t));
   // automatic default constructor
   G__memfunc_setup("SYNC_t", 528, G__bankvarsDict_329_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SYNC_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SYNC_t", 528, G__bankvarsDict_329_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_SYNC_t), -1, 0, 1, 1, 1, 0, "u 'SYNC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SYNC_t", 654, G__bankvarsDict_329_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_329_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_SYNC_t), -1, 1, 1, 1, 1, 0, "u 'SYNC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTACO_t(void) {
   /* TACO_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TACO_t));
   // automatic default constructor
   G__memfunc_setup("TACO_t", 506, G__bankvarsDict_330_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TACO_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TACO_t", 506, G__bankvarsDict_330_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TACO_t), -1, 0, 1, 1, 1, 0, "u 'TACO_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TACO_t", 632, G__bankvarsDict_330_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_330_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TACO_t), -1, 1, 1, 1, 1, 0, "u 'TACO_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTAGE_t(void) {
   /* TAGE_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TAGE_t));
   // automatic default constructor
   G__memfunc_setup("TAGE_t", 500, G__bankvarsDict_331_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TAGE_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TAGE_t", 500, G__bankvarsDict_331_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TAGE_t), -1, 0, 1, 1, 1, 0, "u 'TAGE_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TAGE_t", 626, G__bankvarsDict_331_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_331_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TAGE_t), -1, 1, 1, 1, 1, 0, "u 'TAGE_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTAGI_t(void) {
   /* TAGI_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TAGI_t));
   // automatic default constructor
   G__memfunc_setup("TAGI_t", 504, G__bankvarsDict_332_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TAGI_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TAGI_t", 504, G__bankvarsDict_332_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TAGI_t), -1, 0, 1, 1, 1, 0, "u 'TAGI_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TAGI_t", 630, G__bankvarsDict_332_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_332_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TAGI_t), -1, 1, 1, 1, 1, 0, "u 'TAGI_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTAGM_t(void) {
   /* TAGM_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TAGM_t));
   // automatic default constructor
   G__memfunc_setup("TAGM_t", 508, G__bankvarsDict_333_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TAGM_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TAGM_t", 508, G__bankvarsDict_333_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TAGM_t), -1, 0, 1, 1, 1, 0, "u 'TAGM_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TAGM_t", 634, G__bankvarsDict_333_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_333_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TAGM_t), -1, 1, 1, 1, 1, 0, "u 'TAGM_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTAGR_t(void) {
   /* TAGR_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TAGR_t));
   // automatic default constructor
   G__memfunc_setup("TAGR_t", 513, G__bankvarsDict_334_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TAGR_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TAGR_t", 513, G__bankvarsDict_334_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TAGR_t), -1, 0, 1, 1, 1, 0, "u 'TAGR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TAGR_t", 639, G__bankvarsDict_334_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_334_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TAGR_t), -1, 1, 1, 1, 1, 0, "u 'TAGR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTAGT_t(void) {
   /* TAGT_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TAGT_t));
   // automatic default constructor
   G__memfunc_setup("TAGT_t", 515, G__bankvarsDict_335_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TAGT_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TAGT_t", 515, G__bankvarsDict_335_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TAGT_t), -1, 0, 1, 1, 1, 0, "u 'TAGT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TAGT_t", 641, G__bankvarsDict_335_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_335_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TAGT_t), -1, 1, 1, 1, 1, 0, "u 'TAGT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTATL_t(void) {
   /* TATL_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TATL_t));
   // automatic default constructor
   G__memfunc_setup("TATL_t", 520, G__bankvarsDict_336_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TATL_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TATL_t", 520, G__bankvarsDict_336_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TATL_t), -1, 0, 1, 1, 1, 0, "u 'TATL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TATL_t", 646, G__bankvarsDict_336_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_336_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TATL_t), -1, 1, 1, 1, 1, 0, "u 'TATL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTATR_t(void) {
   /* TATR_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TATR_t));
   // automatic default constructor
   G__memfunc_setup("TATR_t", 526, G__bankvarsDict_337_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TATR_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TATR_t", 526, G__bankvarsDict_337_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TATR_t), -1, 0, 1, 1, 1, 0, "u 'TATR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TATR_t", 652, G__bankvarsDict_337_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_337_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TATR_t), -1, 1, 1, 1, 1, 0, "u 'TATR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTBER_t(void) {
   /* TBER_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TBER_t));
   // automatic default constructor
   G__memfunc_setup("TBER_t", 512, G__bankvarsDict_338_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TBER_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TBER_t", 512, G__bankvarsDict_338_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TBER_t), -1, 0, 1, 1, 1, 0, "u 'TBER_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TBER_t", 638, G__bankvarsDict_338_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_338_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TBER_t), -1, 1, 1, 1, 1, 0, "u 'TBER_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTBID_t(void) {
   /* TBID_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TBID_t));
   // automatic default constructor
   G__memfunc_setup("TBID_t", 502, G__bankvarsDict_339_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TBID_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TBID_t", 502, G__bankvarsDict_339_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TBID_t), -1, 0, 1, 1, 1, 0, "u 'TBID_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TBID_t", 628, G__bankvarsDict_339_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_339_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TBID_t), -1, 1, 1, 1, 1, 0, "u 'TBID_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTBLA_t(void) {
   /* TBLA_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TBLA_t));
   // automatic default constructor
   G__memfunc_setup("TBLA_t", 502, G__bankvarsDict_340_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TBLA_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TBLA_t", 502, G__bankvarsDict_340_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TBLA_t), -1, 0, 1, 1, 1, 0, "u 'TBLA_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TBLA_t", 628, G__bankvarsDict_340_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_340_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TBLA_t), -1, 1, 1, 1, 1, 0, "u 'TBLA_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTBTR_t(void) {
   /* TBTR_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TBTR_t));
   // automatic default constructor
   G__memfunc_setup("TBTR_t", 527, G__bankvarsDict_341_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TBTR_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TBTR_t", 527, G__bankvarsDict_341_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TBTR_t), -1, 0, 1, 1, 1, 0, "u 'TBTR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TBTR_t", 653, G__bankvarsDict_341_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_341_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TBTR_t), -1, 1, 1, 1, 1, 0, "u 'TBTR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTCSB_t(void) {
   /* TCSB_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TCSB_t));
   // automatic default constructor
   G__memfunc_setup("TCSB_t", 511, G__bankvarsDict_342_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TCSB_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TCSB_t", 511, G__bankvarsDict_342_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TCSB_t), -1, 0, 1, 1, 1, 0, "u 'TCSB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TCSB_t", 637, G__bankvarsDict_342_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_342_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TCSB_t), -1, 1, 1, 1, 1, 0, "u 'TCSB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTCT_t(void) {
   /* TCT_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TCT_t));
   // automatic default constructor
   G__memfunc_setup("TCT_t", 446, G__bankvarsDict_343_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TCT_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TCT_t", 446, G__bankvarsDict_343_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TCT_t), -1, 0, 1, 1, 1, 0, "u 'TCT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TCT_t", 572, G__bankvarsDict_343_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_343_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TCT_t), -1, 1, 1, 1, 1, 0, "u 'TCT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTDPL_t(void) {
   /* TDPL_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TDPL_t));
   // automatic default constructor
   G__memfunc_setup("TDPL_t", 519, G__bankvarsDict_344_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TDPL_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TDPL_t", 519, G__bankvarsDict_344_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TDPL_t), -1, 0, 1, 1, 1, 0, "u 'TDPL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TDPL_t", 645, G__bankvarsDict_344_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_344_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TDPL_t), -1, 1, 1, 1, 1, 0, "u 'TDPL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTESC_t(void) {
   /* TESC_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TESC_t));
   // automatic default constructor
   G__memfunc_setup("TESC_t", 514, G__bankvarsDict_345_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TESC_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TESC_t", 514, G__bankvarsDict_345_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TESC_t), -1, 0, 1, 1, 1, 0, "u 'TESC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TESC_t", 640, G__bankvarsDict_345_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_345_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TESC_t), -1, 1, 1, 1, 1, 0, "u 'TESC_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTGBI_t(void) {
   /* TGBI_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TGBI_t));
   // automatic default constructor
   G__memfunc_setup("TGBI_t", 505, G__bankvarsDict_346_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TGBI_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TGBI_t", 505, G__bankvarsDict_346_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TGBI_t), -1, 0, 1, 1, 1, 0, "u 'TGBI_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TGBI_t", 631, G__bankvarsDict_346_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_346_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TGBI_t), -1, 1, 1, 1, 1, 0, "u 'TGBI_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTGEO_t(void) {
   /* TGEO_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TGEO_t));
   // automatic default constructor
   G__memfunc_setup("TGEO_t", 514, G__bankvarsDict_347_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TGEO_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TGEO_t", 514, G__bankvarsDict_347_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TGEO_t), -1, 0, 1, 1, 1, 0, "u 'TGEO_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TGEO_t", 640, G__bankvarsDict_347_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_347_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TGEO_t), -1, 1, 1, 1, 1, 0, "u 'TGEO_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTGPB_t(void) {
   /* TGPB_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TGPB_t));
   // automatic default constructor
   G__memfunc_setup("TGPB_t", 512, G__bankvarsDict_348_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TGPB_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TGPB_t", 512, G__bankvarsDict_348_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TGPB_t), -1, 0, 1, 1, 1, 0, "u 'TGPB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TGPB_t", 638, G__bankvarsDict_348_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_348_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TGPB_t), -1, 1, 1, 1, 1, 0, "u 'TGPB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTGS_t(void) {
   /* TGS_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TGS_t));
   // automatic default constructor
   G__memfunc_setup("TGS_t", 449, G__bankvarsDict_349_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TGS_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TGS_t", 449, G__bankvarsDict_349_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TGS_t), -1, 0, 1, 1, 1, 0, "u 'TGS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TGS_t", 575, G__bankvarsDict_349_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_349_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TGS_t), -1, 1, 1, 1, 1, 0, "u 'TGS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTGTL_t(void) {
   /* TGTL_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TGTL_t));
   // automatic default constructor
   G__memfunc_setup("TGTL_t", 526, G__bankvarsDict_350_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TGTL_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TGTL_t", 526, G__bankvarsDict_350_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TGTL_t), -1, 0, 1, 1, 1, 0, "u 'TGTL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TGTL_t", 652, G__bankvarsDict_350_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_350_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TGTL_t), -1, 1, 1, 1, 1, 0, "u 'TGTL_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTGTR_t(void) {
   /* TGTR_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TGTR_t));
   // automatic default constructor
   G__memfunc_setup("TGTR_t", 532, G__bankvarsDict_351_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TGTR_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TGTR_t", 532, G__bankvarsDict_351_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TGTR_t), -1, 0, 1, 1, 1, 0, "u 'TGTR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TGTR_t", 658, G__bankvarsDict_351_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_351_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TGTR_t), -1, 1, 1, 1, 1, 0, "u 'TGTR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTLV1_t(void) {
   /* TLV1_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TLV1_t));
   // automatic default constructor
   G__memfunc_setup("TLV1_t", 506, G__bankvarsDict_352_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TLV1_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TLV1_t", 506, G__bankvarsDict_352_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TLV1_t), -1, 0, 1, 1, 1, 0, "u 'TLV1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TLV1_t", 632, G__bankvarsDict_352_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_352_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TLV1_t), -1, 1, 1, 1, 1, 0, "u 'TLV1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTRCF_t(void) {
   /* TRCF_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TRCF_t));
   // automatic default constructor
   G__memfunc_setup("TRCF_t", 514, G__bankvarsDict_353_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TRCF_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TRCF_t", 514, G__bankvarsDict_353_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TRCF_t), -1, 0, 1, 1, 1, 0, "u 'TRCF_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TRCF_t", 640, G__bankvarsDict_353_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_353_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TRCF_t), -1, 1, 1, 1, 1, 0, "u 'TRCF_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTRGS_t(void) {
   /* TRGS_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TRGS_t));
   // automatic default constructor
   G__memfunc_setup("TRGS_t", 531, G__bankvarsDict_354_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TRGS_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TRGS_t", 531, G__bankvarsDict_354_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TRGS_t), -1, 0, 1, 1, 1, 0, "u 'TRGS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TRGS_t", 657, G__bankvarsDict_354_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_354_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TRGS_t), -1, 1, 1, 1, 1, 0, "u 'TRGS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTRKS_t(void) {
   /* TRKS_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TRKS_t));
   // automatic default constructor
   G__memfunc_setup("TRKS_t", 535, G__bankvarsDict_355_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TRKS_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TRKS_t", 535, G__bankvarsDict_355_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TRKS_t), -1, 0, 1, 1, 1, 0, "u 'TRKS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TRKS_t", 661, G__bankvarsDict_355_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_355_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TRKS_t), -1, 1, 1, 1, 1, 0, "u 'TRKS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTRL1_t(void) {
   /* TRL1_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TRL1_t));
   // automatic default constructor
   G__memfunc_setup("TRL1_t", 502, G__bankvarsDict_356_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TRL1_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TRL1_t", 502, G__bankvarsDict_356_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TRL1_t), -1, 0, 1, 1, 1, 0, "u 'TRL1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TRL1_t", 628, G__bankvarsDict_356_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_356_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TRL1_t), -1, 1, 1, 1, 1, 0, "u 'TRL1_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTRPB_t(void) {
   /* TRPB_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TRPB_t));
   // automatic default constructor
   G__memfunc_setup("TRPB_t", 523, G__bankvarsDict_357_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TRPB_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TRPB_t", 523, G__bankvarsDict_357_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TRPB_t), -1, 0, 1, 1, 1, 0, "u 'TRPB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TRPB_t", 649, G__bankvarsDict_357_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_357_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TRPB_t), -1, 1, 1, 1, 1, 0, "u 'TRPB_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTSPR_t(void) {
   /* TSPR_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TSPR_t));
   // automatic default constructor
   G__memfunc_setup("TSPR_t", 540, G__bankvarsDict_358_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TSPR_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TSPR_t", 540, G__bankvarsDict_358_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TSPR_t), -1, 0, 1, 1, 1, 0, "u 'TSPR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TSPR_t", 666, G__bankvarsDict_358_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_358_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TSPR_t), -1, 1, 1, 1, 1, 0, "u 'TSPR_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTSRG_t(void) {
   /* TSRG_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_TSRG_t));
   // automatic default constructor
   G__memfunc_setup("TSRG_t", 531, G__bankvarsDict_359_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TSRG_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TSRG_t", 531, G__bankvarsDict_359_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_TSRG_t), -1, 0, 1, 1, 1, 0, "u 'TSRG_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TSRG_t", 657, G__bankvarsDict_359_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_359_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_TSRG_t), -1, 1, 1, 1, 1, 0, "u 'TSRG_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncUNUS_t(void) {
   /* UNUS_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_UNUS_t));
   // automatic default constructor
   G__memfunc_setup("UNUS_t", 542, G__bankvarsDict_360_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_UNUS_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("UNUS_t", 542, G__bankvarsDict_360_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_UNUS_t), -1, 0, 1, 1, 1, 0, "u 'UNUS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~UNUS_t", 668, G__bankvarsDict_360_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_360_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_UNUS_t), -1, 1, 1, 1, 1, 0, "u 'UNUS_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncVERT_t(void) {
   /* VERT_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_VERT_t));
   // automatic default constructor
   G__memfunc_setup("VERT_t", 532, G__bankvarsDict_361_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_VERT_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("VERT_t", 532, G__bankvarsDict_361_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_VERT_t), -1, 0, 1, 1, 1, 0, "u 'VERT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~VERT_t", 658, G__bankvarsDict_361_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_361_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_VERT_t), -1, 1, 1, 1, 1, 0, "u 'VERT_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncRC26_t(void) {
   /* RC26_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_RC26_t));
   // automatic default constructor
   G__memfunc_setup("RC26_t", 464, G__bankvarsDict_362_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RC26_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("RC26_t", 464, G__bankvarsDict_362_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_RC26_t), -1, 0, 1, 1, 1, 0, "u 'RC26_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RC26_t", 590, G__bankvarsDict_362_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_362_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_RC26_t), -1, 1, 1, 1, 1, 0, "u 'RC26_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSTRE_t(void) {
   /* STRE_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_STRE_t));
   // automatic default constructor
   G__memfunc_setup("STRE_t", 529, G__bankvarsDict_363_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STRE_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("STRE_t", 529, G__bankvarsDict_363_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_STRE_t), -1, 0, 1, 1, 1, 0, "u 'STRE_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~STRE_t", 655, G__bankvarsDict_363_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_363_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_STRE_t), -1, 1, 1, 1, 1, 0, "u 'STRE_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncaddressBanks_t(void) {
   /* addressBanks_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__bankvarsDictLN_addressBanks_t));
   // automatic default constructor
   G__memfunc_setup("addressBanks_t", 1448, G__bankvarsDict_368_0_1, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_addressBanks_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("addressBanks_t", 1448, G__bankvarsDict_368_0_2, (int) ('i'), G__get_linked_tagnum(&G__bankvarsDictLN_addressBanks_t), -1, 0, 1, 1, 1, 0, "u 'addressBanks_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~addressBanks_t", 1574, G__bankvarsDict_368_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__bankvarsDict_368_0_4, (int) ('u'), G__get_linked_tagnum(&G__bankvarsDictLN_addressBanks_t), -1, 1, 1, 1, 1, 0, "u 'addressBanks_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncbankvarsDict() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {
}

static void G__cpp_setup_global2() {
}

static void G__cpp_setup_global3() {
}

static void G__cpp_setup_global4() {
}

static void G__cpp_setup_global5() {
   G__memvar_setup((void*)(&BEAM),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_BEAM_t),-1,-1,1,"BEAM=",0,(char*)NULL);
   G__memvar_setup((void*)(&BEAM_NH),73,0,0,-1,-1,-1,1,"BEAM_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&BEAM_S),73,0,0,-1,-1,-1,1,"BEAM_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&BEAM_NS),105,0,0,-1,-1,-1,1,"BEAM_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&BMPR),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_BMPR_t),-1,-1,1,"BMPR=",0,(char*)NULL);
   G__memvar_setup((void*)(&BMPR_NH),105,0,0,-1,-1,-1,1,"BMPR_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&BMPR_S),105,0,0,-1,-1,-1,1,"BMPR_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&BREP),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_BREP_t),-1,-1,1,"BREP=",0,(char*)NULL);
   G__memvar_setup((void*)(&BREP_NH),105,0,0,-1,-1,-1,1,"BREP_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&BREP_S),105,0,0,-1,-1,-1,1,"BREP_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CALB),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_CALB_t),-1,-1,1,"CALB=",0,(char*)NULL);
   G__memvar_setup((void*)(&CALB_NH),73,0,0,-1,-1,-1,1,"CALB_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CALB_S),73,0,0,-1,-1,-1,1,"CALB_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CALB_NS),105,0,0,-1,-1,-1,1,"CALB_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&CALL),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_CALL_t),-1,-1,1,"CALL=",0,(char*)NULL);
   G__memvar_setup((void*)(&CALL_NH),105,0,0,-1,-1,-1,1,"CALL_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CALL_S),105,0,0,-1,-1,-1,1,"CALL_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CC01),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_CC01_t),-1,-1,1,"CC01=",0,(char*)NULL);
   G__memvar_setup((void*)(&CC01_NH),73,0,0,-1,-1,-1,1,"CC01_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CC01_S),73,0,0,-1,-1,-1,1,"CC01_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CC01_NS),105,0,0,-1,-1,-1,1,"CC01_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&CC1),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_CC1_t),-1,-1,1,"CC1=",0,(char*)NULL);
   G__memvar_setup((void*)(&CC1_NH),73,0,0,-1,-1,-1,1,"CC1_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CC1_S),73,0,0,-1,-1,-1,1,"CC1_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CC1_NS),105,0,0,-1,-1,-1,1,"CC1_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&CC),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_CC_t),-1,-1,1,"CC=",0,(char*)NULL);
   G__memvar_setup((void*)(&CC_NH),73,0,0,-1,-1,-1,1,"CC_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CC_S),73,0,0,-1,-1,-1,1,"CC_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CC_NS),105,0,0,-1,-1,-1,1,"CC_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCDI),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_CCDI_t),-1,-1,1,"CCDI=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCDI_NH),73,0,0,-1,-1,-1,1,"CCDI_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCDI_S),73,0,0,-1,-1,-1,1,"CCDI_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCDI_NS),105,0,0,-1,-1,-1,1,"CCDI_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCH),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_CCH_t),-1,-1,1,"CCH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCH_NH),73,0,0,-1,-1,-1,1,"CCH_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCH_S),73,0,0,-1,-1,-1,1,"CCH_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCH_NS),105,0,0,-1,-1,-1,1,"CCH_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCMT),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_CCMT_t),-1,-1,1,"CCMT=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCMT_NH),73,0,0,-1,-1,-1,1,"CCMT_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCMT_S),73,0,0,-1,-1,-1,1,"CCMT_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCMT_NS),105,0,0,-1,-1,-1,1,"CCMT_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCPB),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_CCPB_t),-1,-1,1,"CCPB=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCPB_NH),105,0,0,-1,-1,-1,1,"CCPB_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCPB_S),105,0,0,-1,-1,-1,1,"CCPB_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCPE),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_CCPE_t),-1,-1,1,"CCPE=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCPE_NH),73,0,0,-1,-1,-1,1,"CCPE_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCPE_S),73,0,0,-1,-1,-1,1,"CCPE_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCPE_NS),105,0,0,-1,-1,-1,1,"CCPE_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCRC),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_CCRC_t),-1,-1,1,"CCRC=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCRC_NH),105,0,0,-1,-1,-1,1,"CCRC_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCRC_S),105,0,0,-1,-1,-1,1,"CCRC_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCS),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_CCS_t),-1,-1,1,"CCS=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCS_NH),73,0,0,-1,-1,-1,1,"CCS_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCS_S),73,0,0,-1,-1,-1,1,"CCS_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCS_NS),105,0,0,-1,-1,-1,1,"CCS_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCT),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_CCT_t),-1,-1,1,"CCT=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCT_NH),73,0,0,-1,-1,-1,1,"CCT_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCT_S),73,0,0,-1,-1,-1,1,"CCT_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CCT_NS),105,0,0,-1,-1,-1,1,"CCT_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&CHI2),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_CHI2_t),-1,-1,1,"CHI2=",0,(char*)NULL);
   G__memvar_setup((void*)(&CHI2_NH),73,0,0,-1,-1,-1,1,"CHI2_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CHI2_S),73,0,0,-1,-1,-1,1,"CHI2_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CHI2_NS),105,0,0,-1,-1,-1,1,"CHI2_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&CL01),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_CL01_t),-1,-1,1,"CL01=",0,(char*)NULL);
   G__memvar_setup((void*)(&CL01_NH),105,0,0,-1,-1,-1,1,"CL01_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CL01_S),105,0,0,-1,-1,-1,1,"CL01_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CLST),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_CLST_t),-1,-1,1,"CLST=",0,(char*)NULL);
   G__memvar_setup((void*)(&CLST_NH),73,0,0,-1,-1,-1,1,"CLST_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CLST_S),73,0,0,-1,-1,-1,1,"CLST_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CLST_NS),105,0,0,-1,-1,-1,1,"CLST_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&CPED),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_CPED_t),-1,-1,1,"CPED=",0,(char*)NULL);
   G__memvar_setup((void*)(&CPED_NH),73,0,0,-1,-1,-1,1,"CPED_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CPED_S),73,0,0,-1,-1,-1,1,"CPED_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CPED_NS),105,0,0,-1,-1,-1,1,"CPED_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&CSQL),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_CSQL_t),-1,-1,1,"CSQL=",0,(char*)NULL);
   G__memvar_setup((void*)(&CSQL_NH),73,0,0,-1,-1,-1,1,"CSQL_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&CSQL_S),73,0,0,-1,-1,-1,1,"CSQL_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&CSQL_NS),105,0,0,-1,-1,-1,1,"CSQL_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DC0),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DC0_t),-1,-1,1,"DC0=",0,(char*)NULL);
   G__memvar_setup((void*)(&DC0_NH),73,0,0,-1,-1,-1,1,"DC0_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DC0_S),73,0,0,-1,-1,-1,1,"DC0_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DC0_NS),105,0,0,-1,-1,-1,1,"DC0_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DC1),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DC1_t),-1,-1,1,"DC1=",0,(char*)NULL);
   G__memvar_setup((void*)(&DC1_NH),73,0,0,-1,-1,-1,1,"DC1_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DC1_S),73,0,0,-1,-1,-1,1,"DC1_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DC1_NS),105,0,0,-1,-1,-1,1,"DC1_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCDW),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DCDW_t),-1,-1,1,"DCDW=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCDW_NH),73,0,0,-1,-1,-1,1,"DCDW_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCDW_S),73,0,0,-1,-1,-1,1,"DCDW_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCDW_NS),105,0,0,-1,-1,-1,1,"DCDW_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCGM),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DCGM_t),-1,-1,1,"DCGM=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCGM_NH),73,0,0,-1,-1,-1,1,"DCGM_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCGM_S),73,0,0,-1,-1,-1,1,"DCGM_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCGM_NS),105,0,0,-1,-1,-1,1,"DCGM_NS=",0,(char*)NULL);
}

static void G__cpp_setup_global6() {
   G__memvar_setup((void*)(&DCGW),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DCGW_t),-1,-1,1,"DCGW=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCGW_NH),73,0,0,-1,-1,-1,1,"DCGW_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCGW_S),73,0,0,-1,-1,-1,1,"DCGW_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCGW_NS),105,0,0,-1,-1,-1,1,"DCGW_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCH),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DCH_t),-1,-1,1,"DCH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCH_NH),73,0,0,-1,-1,-1,1,"DCH_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCH_S),73,0,0,-1,-1,-1,1,"DCH_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCH_NS),105,0,0,-1,-1,-1,1,"DCH_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCMN),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DCMN_t),-1,-1,1,"DCMN=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCMN_NH),73,0,0,-1,-1,-1,1,"DCMN_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCMN_S),73,0,0,-1,-1,-1,1,"DCMN_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCMN_NS),105,0,0,-1,-1,-1,1,"DCMN_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCPB),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_DCPB_t),-1,-1,1,"DCPB=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCPB_NH),105,0,0,-1,-1,-1,1,"DCPB_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCPB_S),105,0,0,-1,-1,-1,1,"DCPB_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCV1),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DCV1_t),-1,-1,1,"DCV1=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCV1_NH),73,0,0,-1,-1,-1,1,"DCV1_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCV1_S),73,0,0,-1,-1,-1,1,"DCV1_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCV1_NS),105,0,0,-1,-1,-1,1,"DCV1_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCV2),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DCV2_t),-1,-1,1,"DCV2=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCV2_NH),73,0,0,-1,-1,-1,1,"DCV2_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCV2_S),73,0,0,-1,-1,-1,1,"DCV2_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCV2_NS),105,0,0,-1,-1,-1,1,"DCV2_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCV3),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DCV3_t),-1,-1,1,"DCV3=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCV3_NH),73,0,0,-1,-1,-1,1,"DCV3_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCV3_S),73,0,0,-1,-1,-1,1,"DCV3_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DCV3_NS),105,0,0,-1,-1,-1,1,"DCV3_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DDLY),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DDLY_t),-1,-1,1,"DDLY=",0,(char*)NULL);
   G__memvar_setup((void*)(&DDLY_NH),73,0,0,-1,-1,-1,1,"DDLY_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DDLY_S),73,0,0,-1,-1,-1,1,"DDLY_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DDLY_NS),105,0,0,-1,-1,-1,1,"DDLY_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DGEO),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DGEO_t),-1,-1,1,"DGEO=",0,(char*)NULL);
   G__memvar_setup((void*)(&DGEO_NH),73,0,0,-1,-1,-1,1,"DGEO_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DGEO_S),73,0,0,-1,-1,-1,1,"DGEO_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DGEO_NS),105,0,0,-1,-1,-1,1,"DGEO_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DHCL),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DHCL_t),-1,-1,1,"DHCL=",0,(char*)NULL);
   G__memvar_setup((void*)(&DHCL_NH),73,0,0,-1,-1,-1,1,"DHCL_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DHCL_S),73,0,0,-1,-1,-1,1,"DHCL_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DHCL_NS),105,0,0,-1,-1,-1,1,"DHCL_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DITM),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DITM_t),-1,-1,1,"DITM=",0,(char*)NULL);
   G__memvar_setup((void*)(&DITM_NH),73,0,0,-1,-1,-1,1,"DITM_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DITM_S),73,0,0,-1,-1,-1,1,"DITM_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DITM_NS),105,0,0,-1,-1,-1,1,"DITM_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DOCA),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DOCA_t),-1,-1,1,"DOCA=",0,(char*)NULL);
   G__memvar_setup((void*)(&DOCA_NH),73,0,0,-1,-1,-1,1,"DOCA_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DOCA_S),73,0,0,-1,-1,-1,1,"DOCA_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DOCA_NS),105,0,0,-1,-1,-1,1,"DOCA_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DPCP),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DPCP_t),-1,-1,1,"DPCP=",0,(char*)NULL);
   G__memvar_setup((void*)(&DPCP_NH),73,0,0,-1,-1,-1,1,"DPCP_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DPCP_S),73,0,0,-1,-1,-1,1,"DPCP_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DPCP_NS),105,0,0,-1,-1,-1,1,"DPCP_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DPSP),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DPSP_t),-1,-1,1,"DPSP=",0,(char*)NULL);
   G__memvar_setup((void*)(&DPSP_NH),73,0,0,-1,-1,-1,1,"DPSP_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DPSP_S),73,0,0,-1,-1,-1,1,"DPSP_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DPSP_NS),105,0,0,-1,-1,-1,1,"DPSP_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DSPC),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DSPC_t),-1,-1,1,"DSPC=",0,(char*)NULL);
   G__memvar_setup((void*)(&DSPC_NH),73,0,0,-1,-1,-1,1,"DSPC_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DSPC_S),73,0,0,-1,-1,-1,1,"DSPC_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DSPC_NS),105,0,0,-1,-1,-1,1,"DSPC_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DSPS),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DSPS_t),-1,-1,1,"DSPS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DSPS_NH),73,0,0,-1,-1,-1,1,"DSPS_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DSPS_S),73,0,0,-1,-1,-1,1,"DSPS_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DSPS_NS),105,0,0,-1,-1,-1,1,"DSPS_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DSTC),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_DSTC_t),-1,-1,1,"DSTC=",0,(char*)NULL);
   G__memvar_setup((void*)(&DSTC_NH),105,0,0,-1,-1,-1,1,"DSTC_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DSTC_S),105,0,0,-1,-1,-1,1,"DSTC_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DTCP),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DTCP_t),-1,-1,1,"DTCP=",0,(char*)NULL);
   G__memvar_setup((void*)(&DTCP_NH),73,0,0,-1,-1,-1,1,"DTCP_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DTCP_S),73,0,0,-1,-1,-1,1,"DTCP_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DTCP_NS),105,0,0,-1,-1,-1,1,"DTCP_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&DTRK),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_DTRK_t),-1,-1,1,"DTRK=",0,(char*)NULL);
   G__memvar_setup((void*)(&DTRK_NH),73,0,0,-1,-1,-1,1,"DTRK_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&DTRK_S),73,0,0,-1,-1,-1,1,"DTRK_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&DTRK_NS),105,0,0,-1,-1,-1,1,"DTRK_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC01),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_EC01_t),-1,-1,1,"EC01=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC01_NH),73,0,0,-1,-1,-1,1,"EC01_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC01_S),73,0,0,-1,-1,-1,1,"EC01_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC01_NS),105,0,0,-1,-1,-1,1,"EC01_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC1),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_EC1_t),-1,-1,1,"EC1=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC1_NH),73,0,0,-1,-1,-1,1,"EC1_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC1_S),73,0,0,-1,-1,-1,1,"EC1_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC1_NS),105,0,0,-1,-1,-1,1,"EC1_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC1P),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_EC1P_t),-1,-1,1,"EC1P=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC1P_NH),73,0,0,-1,-1,-1,1,"EC1P_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC1P_S),73,0,0,-1,-1,-1,1,"EC1P_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC1P_NS),105,0,0,-1,-1,-1,1,"EC1P_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC1R),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_EC1R_t),-1,-1,1,"EC1R=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC1R_NH),73,0,0,-1,-1,-1,1,"EC1R_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC1R_S),73,0,0,-1,-1,-1,1,"EC1R_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC1R_NS),105,0,0,-1,-1,-1,1,"EC1R_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECCA),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECCA_t),-1,-1,1,"ECCA=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECCA_NH),73,0,0,-1,-1,-1,1,"ECCA_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECCA_S),73,0,0,-1,-1,-1,1,"ECCA_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECCA_NS),105,0,0,-1,-1,-1,1,"ECCA_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECCL),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECCL_t),-1,-1,1,"ECCL=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECCL_NH),73,0,0,-1,-1,-1,1,"ECCL_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECCL_S),73,0,0,-1,-1,-1,1,"ECCL_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECCL_NS),105,0,0,-1,-1,-1,1,"ECCL_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECCT),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECCT_t),-1,-1,1,"ECCT=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECCT_NH),73,0,0,-1,-1,-1,1,"ECCT_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECCT_S),73,0,0,-1,-1,-1,1,"ECCT_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECCT_NS),105,0,0,-1,-1,-1,1,"ECCT_NS=",0,(char*)NULL);
}

static void G__cpp_setup_global7() {
   G__memvar_setup((void*)(&EC),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_EC_t),-1,-1,1,"EC=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC_NH),73,0,0,-1,-1,-1,1,"EC_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC_S),73,0,0,-1,-1,-1,1,"EC_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&EC_NS),105,0,0,-1,-1,-1,1,"EC_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECDI),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECDI_t),-1,-1,1,"ECDI=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECDI_NH),73,0,0,-1,-1,-1,1,"ECDI_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECDI_S),73,0,0,-1,-1,-1,1,"ECDI_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECDI_NS),105,0,0,-1,-1,-1,1,"ECDI_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECG),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECG_t),-1,-1,1,"ECG=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECG_NH),73,0,0,-1,-1,-1,1,"ECG_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECG_S),73,0,0,-1,-1,-1,1,"ECG_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECG_NS),105,0,0,-1,-1,-1,1,"ECG_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECHB),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECHB_t),-1,-1,1,"ECHB=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECHB_NH),105,0,0,-1,-1,-1,1,"ECHB_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECHB_S),105,0,0,-1,-1,-1,1,"ECHB_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECH),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECH_t),-1,-1,1,"ECH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECH_NH),73,0,0,-1,-1,-1,1,"ECH_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECH_S),73,0,0,-1,-1,-1,1,"ECH_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECH_NS),105,0,0,-1,-1,-1,1,"ECH_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECMT),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECMT_t),-1,-1,1,"ECMT=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECMT_NH),73,0,0,-1,-1,-1,1,"ECMT_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECMT_S),73,0,0,-1,-1,-1,1,"ECMT_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECMT_NS),105,0,0,-1,-1,-1,1,"ECMT_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECP1),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECP1_t),-1,-1,1,"ECP1=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECP1_NH),73,0,0,-1,-1,-1,1,"ECP1_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECP1_S),73,0,0,-1,-1,-1,1,"ECP1_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECP1_NS),105,0,0,-1,-1,-1,1,"ECP1_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPB),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECPB_t),-1,-1,1,"ECPB=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPB_NH),105,0,0,-1,-1,-1,1,"ECPB_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPB_S),105,0,0,-1,-1,-1,1,"ECPB_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPC),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECPC_t),-1,-1,1,"ECPC=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPC_NH),73,0,0,-1,-1,-1,1,"ECPC_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPC_S),73,0,0,-1,-1,-1,1,"ECPC_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPC_NS),105,0,0,-1,-1,-1,1,"ECPC_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECP),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECP_t),-1,-1,1,"ECP=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECP_NH),73,0,0,-1,-1,-1,1,"ECP_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECP_S),73,0,0,-1,-1,-1,1,"ECP_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECP_NS),105,0,0,-1,-1,-1,1,"ECP_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPE),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECPE_t),-1,-1,1,"ECPE=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPE_NH),73,0,0,-1,-1,-1,1,"ECPE_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPE_S),73,0,0,-1,-1,-1,1,"ECPE_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPE_NS),105,0,0,-1,-1,-1,1,"ECPE_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPI),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECPI_t),-1,-1,1,"ECPI=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPI_NH),105,0,0,-1,-1,-1,1,"ECPI_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPI_S),105,0,0,-1,-1,-1,1,"ECPI_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPO),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECPO_t),-1,-1,1,"ECPO=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPO_NH),73,0,0,-1,-1,-1,1,"ECPO_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPO_S),73,0,0,-1,-1,-1,1,"ECPO_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECPO_NS),105,0,0,-1,-1,-1,1,"ECPO_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECRB),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECRB_t),-1,-1,1,"ECRB=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECRB_NH),73,0,0,-1,-1,-1,1,"ECRB_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECRB_S),73,0,0,-1,-1,-1,1,"ECRB_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECRB_NS),105,0,0,-1,-1,-1,1,"ECRB_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECS),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECS_t),-1,-1,1,"ECS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECS_NH),73,0,0,-1,-1,-1,1,"ECS_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECS_S),73,0,0,-1,-1,-1,1,"ECS_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECS_NS),105,0,0,-1,-1,-1,1,"ECS_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECT),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ECT_t),-1,-1,1,"ECT=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECT_NH),73,0,0,-1,-1,-1,1,"ECT_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECT_S),73,0,0,-1,-1,-1,1,"ECT_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ECT_NS),105,0,0,-1,-1,-1,1,"ECT_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&EID0),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_EID0_t),-1,-1,1,"EID0=",0,(char*)NULL);
   G__memvar_setup((void*)(&EID0_NH),73,0,0,-1,-1,-1,1,"EID0_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&EID0_S),73,0,0,-1,-1,-1,1,"EID0_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&EID0_NS),105,0,0,-1,-1,-1,1,"EID0_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&EPIC),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_EPIC_t),-1,-1,1,"EPIC=",0,(char*)NULL);
   G__memvar_setup((void*)(&EPIC_NH),73,0,0,-1,-1,-1,1,"EPIC_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&EPIC_S),73,0,0,-1,-1,-1,1,"EPIC_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&EPIC_NS),105,0,0,-1,-1,-1,1,"EPIC_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&EVNT),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_EVNT_t),-1,-1,1,"EVNT=",0,(char*)NULL);
   G__memvar_setup((void*)(&EVNT_NH),105,0,0,-1,-1,-1,1,"EVNT_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&EVNT_S),105,0,0,-1,-1,-1,1,"EVNT_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&FBPM),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_FBPM_t),-1,-1,1,"FBPM=",0,(char*)NULL);
   G__memvar_setup((void*)(&FBPM_NH),73,0,0,-1,-1,-1,1,"FBPM_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&FBPM_S),73,0,0,-1,-1,-1,1,"FBPM_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&FBPM_NS),105,0,0,-1,-1,-1,1,"FBPM_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&G1SL),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_G1SL_t),-1,-1,1,"G1SL=",0,(char*)NULL);
   G__memvar_setup((void*)(&G1SL_NH),73,0,0,-1,-1,-1,1,"G1SL_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&G1SL_S),73,0,0,-1,-1,-1,1,"G1SL_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&G1SL_NS),105,0,0,-1,-1,-1,1,"G1SL_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&G2SL),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_G2SL_t),-1,-1,1,"G2SL=",0,(char*)NULL);
   G__memvar_setup((void*)(&G2SL_NH),73,0,0,-1,-1,-1,1,"G2SL_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&G2SL_S),73,0,0,-1,-1,-1,1,"G2SL_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&G2SL_NS),105,0,0,-1,-1,-1,1,"G2SL_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&G3SL),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_G3SL_t),-1,-1,1,"G3SL=",0,(char*)NULL);
   G__memvar_setup((void*)(&G3SL_NH),73,0,0,-1,-1,-1,1,"G3SL_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&G3SL_S),73,0,0,-1,-1,-1,1,"G3SL_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&G3SL_NS),105,0,0,-1,-1,-1,1,"G3SL_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&G4SL),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_G4SL_t),-1,-1,1,"G4SL=",0,(char*)NULL);
   G__memvar_setup((void*)(&G4SL_NH),73,0,0,-1,-1,-1,1,"G4SL_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&G4SL_S),73,0,0,-1,-1,-1,1,"G4SL_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&G4SL_NS),105,0,0,-1,-1,-1,1,"G4SL_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&GPAR),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_GPAR_t),-1,-1,1,"GPAR=",0,(char*)NULL);
   G__memvar_setup((void*)(&GPAR_NH),73,0,0,-1,-1,-1,1,"GPAR_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&GPAR_S),73,0,0,-1,-1,-1,1,"GPAR_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&GPAR_NS),105,0,0,-1,-1,-1,1,"GPAR_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&GPID),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_GPID_t),-1,-1,1,"GPID=",0,(char*)NULL);
   G__memvar_setup((void*)(&GPID_NH),105,0,0,-1,-1,-1,1,"GPID_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&GPID_S),105,0,0,-1,-1,-1,1,"GPID_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&GP_X),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_GP_X_t),-1,-1,1,"GP_X=",0,(char*)NULL);
   G__memvar_setup((void*)(&GP_X_NH),105,0,0,-1,-1,-1,1,"GP_X_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&GP_X_S),105,0,0,-1,-1,-1,1,"GP_X_S=",0,(char*)NULL);
}

static void G__cpp_setup_global8() {
   G__memvar_setup((void*)(&GP_Y),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_GP_Y_t),-1,-1,1,"GP_Y=",0,(char*)NULL);
   G__memvar_setup((void*)(&GP_Y_NH),105,0,0,-1,-1,-1,1,"GP_Y_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&GP_Y_S),105,0,0,-1,-1,-1,1,"GP_Y_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBER),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_HBER_t),-1,-1,1,"HBER=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBER_NH),105,0,0,-1,-1,-1,1,"HBER_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBER_S),105,0,0,-1,-1,-1,1,"HBER_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBID),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_HBID_t),-1,-1,1,"HBID=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBID_NH),105,0,0,-1,-1,-1,1,"HBID_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBID_S),105,0,0,-1,-1,-1,1,"HBID_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBLA),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_HBLA_t),-1,-1,1,"HBLA=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBLA_NH),73,0,0,-1,-1,-1,1,"HBLA_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBLA_S),73,0,0,-1,-1,-1,1,"HBLA_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBLA_NS),105,0,0,-1,-1,-1,1,"HBLA_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBTB),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_HBTB_t),-1,-1,1,"HBTB=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBTB_NH),73,0,0,-1,-1,-1,1,"HBTB_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBTB_S),73,0,0,-1,-1,-1,1,"HBTB_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBTB_NS),105,0,0,-1,-1,-1,1,"HBTB_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBTR),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_HBTR_t),-1,-1,1,"HBTR=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBTR_NH),105,0,0,-1,-1,-1,1,"HBTR_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&HBTR_S),105,0,0,-1,-1,-1,1,"HBTR_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&HCAL),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_HCAL_t),-1,-1,1,"HCAL=",0,(char*)NULL);
   G__memvar_setup((void*)(&HCAL_NH),73,0,0,-1,-1,-1,1,"HCAL_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&HCAL_S),73,0,0,-1,-1,-1,1,"HCAL_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&HCAL_NS),105,0,0,-1,-1,-1,1,"HCAL_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&HDPL),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_HDPL_t),-1,-1,1,"HDPL=",0,(char*)NULL);
   G__memvar_setup((void*)(&HDPL_NH),73,0,0,-1,-1,-1,1,"HDPL_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&HDPL_S),73,0,0,-1,-1,-1,1,"HDPL_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&HDPL_NS),105,0,0,-1,-1,-1,1,"HDPL_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&HEAD),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_HEAD_t),-1,-1,1,"HEAD=",0,(char*)NULL);
   G__memvar_setup((void*)(&HEAD_NH),105,0,0,-1,-1,-1,1,"HEAD_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&HEAD_S),105,0,0,-1,-1,-1,1,"HEAD_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&HEVT),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_HEVT_t),-1,-1,1,"HEVT=",0,(char*)NULL);
   G__memvar_setup((void*)(&HEVT_NH),105,0,0,-1,-1,-1,1,"HEVT_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&HEVT_S),105,0,0,-1,-1,-1,1,"HEVT_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&HLS),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_HLS_t),-1,-1,1,"HLS=",0,(char*)NULL);
   G__memvar_setup((void*)(&HLS_NH),73,0,0,-1,-1,-1,1,"HLS_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&HLS_S),73,0,0,-1,-1,-1,1,"HLS_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&HLS_NS),105,0,0,-1,-1,-1,1,"HLS_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&IC),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_IC_t),-1,-1,1,"IC=",0,(char*)NULL);
   G__memvar_setup((void*)(&IC_NH),73,0,0,-1,-1,-1,1,"IC_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&IC_S),73,0,0,-1,-1,-1,1,"IC_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&IC_NS),105,0,0,-1,-1,-1,1,"IC_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ICHB),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ICHB_t),-1,-1,1,"ICHB=",0,(char*)NULL);
   G__memvar_setup((void*)(&ICHB_NH),73,0,0,-1,-1,-1,1,"ICHB_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ICHB_S),73,0,0,-1,-1,-1,1,"ICHB_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ICHB_NS),105,0,0,-1,-1,-1,1,"ICHB_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&KFIT),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_KFIT_t),-1,-1,1,"KFIT=",0,(char*)NULL);
   G__memvar_setup((void*)(&KFIT_NH),73,0,0,-1,-1,-1,1,"KFIT_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&KFIT_S),73,0,0,-1,-1,-1,1,"KFIT_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&KFIT_NS),105,0,0,-1,-1,-1,1,"KFIT_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&L1PG),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_L1PG_t),-1,-1,1,"L1PG=",0,(char*)NULL);
   G__memvar_setup((void*)(&L1PG_NH),73,0,0,-1,-1,-1,1,"L1PG_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&L1PG_S),73,0,0,-1,-1,-1,1,"L1PG_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&L1PG_NS),105,0,0,-1,-1,-1,1,"L1PG_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&L2H),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_L2H_t),-1,-1,1,"L2H=",0,(char*)NULL);
   G__memvar_setup((void*)(&L2H_NH),73,0,0,-1,-1,-1,1,"L2H_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&L2H_S),73,0,0,-1,-1,-1,1,"L2H_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&L2H_NS),105,0,0,-1,-1,-1,1,"L2H_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&L2S),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_L2S_t),-1,-1,1,"L2S=",0,(char*)NULL);
   G__memvar_setup((void*)(&L2S_NH),73,0,0,-1,-1,-1,1,"L2S_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&L2S_S),73,0,0,-1,-1,-1,1,"L2S_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&L2S_NS),105,0,0,-1,-1,-1,1,"L2S_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&LASR),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_LASR_t),-1,-1,1,"LASR=",0,(char*)NULL);
   G__memvar_setup((void*)(&LASR_NH),73,0,0,-1,-1,-1,1,"LASR_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&LASR_S),73,0,0,-1,-1,-1,1,"LASR_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&LASR_NS),105,0,0,-1,-1,-1,1,"LASR_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&LCDI),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_LCDI_t),-1,-1,1,"LCDI=",0,(char*)NULL);
   G__memvar_setup((void*)(&LCDI_NH),73,0,0,-1,-1,-1,1,"LCDI_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&LCDI_S),73,0,0,-1,-1,-1,1,"LCDI_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&LCDI_NS),105,0,0,-1,-1,-1,1,"LCDI_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&LCPB),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_LCPB_t),-1,-1,1,"LCPB=",0,(char*)NULL);
   G__memvar_setup((void*)(&LCPB_NH),105,0,0,-1,-1,-1,1,"LCPB_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&LCPB_S),105,0,0,-1,-1,-1,1,"LCPB_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&LOWQ),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_LOWQ_t),-1,-1,1,"LOWQ=",0,(char*)NULL);
   G__memvar_setup((void*)(&LOWQ_NH),73,0,0,-1,-1,-1,1,"LOWQ_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&LOWQ_S),73,0,0,-1,-1,-1,1,"LOWQ_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&LOWQ_NS),105,0,0,-1,-1,-1,1,"LOWQ_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&MCEV),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_MCEV_t),-1,-1,1,"MCEV=",0,(char*)NULL);
   G__memvar_setup((void*)(&MCEV_NH),73,0,0,-1,-1,-1,1,"MCEV_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&MCEV_S),73,0,0,-1,-1,-1,1,"MCEV_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&MCEV_NS),105,0,0,-1,-1,-1,1,"MCEV_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&MCHD),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_MCHD_t),-1,-1,1,"MCHD=",0,(char*)NULL);
   G__memvar_setup((void*)(&MCHD_NH),73,0,0,-1,-1,-1,1,"MCHD_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&MCHD_S),73,0,0,-1,-1,-1,1,"MCHD_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&MCHD_NS),105,0,0,-1,-1,-1,1,"MCHD_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&MCTK),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_MCTK_t),-1,-1,1,"MCTK=",0,(char*)NULL);
   G__memvar_setup((void*)(&MCTK_NH),73,0,0,-1,-1,-1,1,"MCTK_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&MCTK_S),73,0,0,-1,-1,-1,1,"MCTK_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&MCTK_NS),105,0,0,-1,-1,-1,1,"MCTK_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&MCVX),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_MCVX_t),-1,-1,1,"MCVX=",0,(char*)NULL);
   G__memvar_setup((void*)(&MCVX_NH),73,0,0,-1,-1,-1,1,"MCVX_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&MCVX_S),73,0,0,-1,-1,-1,1,"MCVX_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&MCVX_NS),105,0,0,-1,-1,-1,1,"MCVX_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&MS1),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_MS1_t),-1,-1,1,"MS1=",0,(char*)NULL);
   G__memvar_setup((void*)(&MS1_NH),73,0,0,-1,-1,-1,1,"MS1_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&MS1_S),73,0,0,-1,-1,-1,1,"MS1_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&MS1_NS),105,0,0,-1,-1,-1,1,"MS1_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&MTRK),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_MTRK_t),-1,-1,1,"MTRK=",0,(char*)NULL);
   G__memvar_setup((void*)(&MTRK_NH),73,0,0,-1,-1,-1,1,"MTRK_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&MTRK_S),73,0,0,-1,-1,-1,1,"MTRK_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&MTRK_NS),105,0,0,-1,-1,-1,1,"MTRK_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&MVRT),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_MVRT_t),-1,-1,1,"MVRT=",0,(char*)NULL);
}

static void G__cpp_setup_global9() {
   G__memvar_setup((void*)(&MVRT_NH),105,0,0,-1,-1,-1,1,"MVRT_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&MVRT_S),105,0,0,-1,-1,-1,1,"MVRT_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&PART),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_PART_t),-1,-1,1,"PART=",0,(char*)NULL);
   G__memvar_setup((void*)(&PART_NH),105,0,0,-1,-1,-1,1,"PART_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&PART_S),105,0,0,-1,-1,-1,1,"PART_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&PCO),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_PCO_t),-1,-1,1,"PCO=",0,(char*)NULL);
   G__memvar_setup((void*)(&PCO_NH),73,0,0,-1,-1,-1,1,"PCO_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&PCO_S),73,0,0,-1,-1,-1,1,"PCO_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&PCO_NS),105,0,0,-1,-1,-1,1,"PCO_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&PHTM),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_PHTM_t),-1,-1,1,"PHTM=",0,(char*)NULL);
   G__memvar_setup((void*)(&PHTM_NH),73,0,0,-1,-1,-1,1,"PHTM_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&PHTM_S),73,0,0,-1,-1,-1,1,"PHTM_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&PHTM_NS),105,0,0,-1,-1,-1,1,"PHTM_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID1),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_PID1_t),-1,-1,1,"PID1=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID1_NH),73,0,0,-1,-1,-1,1,"PID1_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID1_S),73,0,0,-1,-1,-1,1,"PID1_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID1_NS),105,0,0,-1,-1,-1,1,"PID1_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID2),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_PID2_t),-1,-1,1,"PID2=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID2_NH),73,0,0,-1,-1,-1,1,"PID2_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID2_S),73,0,0,-1,-1,-1,1,"PID2_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID2_NS),105,0,0,-1,-1,-1,1,"PID2_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID3),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_PID3_t),-1,-1,1,"PID3=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID3_NH),73,0,0,-1,-1,-1,1,"PID3_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID3_S),73,0,0,-1,-1,-1,1,"PID3_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID3_NS),105,0,0,-1,-1,-1,1,"PID3_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID4),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_PID4_t),-1,-1,1,"PID4=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID4_NH),73,0,0,-1,-1,-1,1,"PID4_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID4_S),73,0,0,-1,-1,-1,1,"PID4_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID4_NS),105,0,0,-1,-1,-1,1,"PID4_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID5),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_PID5_t),-1,-1,1,"PID5=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID5_NH),73,0,0,-1,-1,-1,1,"PID5_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID5_S),73,0,0,-1,-1,-1,1,"PID5_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID5_NS),105,0,0,-1,-1,-1,1,"PID5_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID6),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_PID6_t),-1,-1,1,"PID6=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID6_NH),73,0,0,-1,-1,-1,1,"PID6_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID6_S),73,0,0,-1,-1,-1,1,"PID6_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&PID6_NS),105,0,0,-1,-1,-1,1,"PID6_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&PIDT),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_PIDT_t),-1,-1,1,"PIDT=",0,(char*)NULL);
   G__memvar_setup((void*)(&PIDT_NH),73,0,0,-1,-1,-1,1,"PIDT_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&PIDT_S),73,0,0,-1,-1,-1,1,"PIDT_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&PIDT_NS),105,0,0,-1,-1,-1,1,"PIDT_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&PRTM),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_PRTM_t),-1,-1,1,"PRTM=",0,(char*)NULL);
   G__memvar_setup((void*)(&PRTM_NH),73,0,0,-1,-1,-1,1,"PRTM_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&PRTM_S),73,0,0,-1,-1,-1,1,"PRTM_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&PRTM_NS),105,0,0,-1,-1,-1,1,"PRTM_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&PSO),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_PSO_t),-1,-1,1,"PSO=",0,(char*)NULL);
   G__memvar_setup((void*)(&PSO_NH),73,0,0,-1,-1,-1,1,"PSO_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&PSO_S),73,0,0,-1,-1,-1,1,"PSO_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&PSO_NS),105,0,0,-1,-1,-1,1,"PSO_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&PTDB),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_PTDB_t),-1,-1,1,"PTDB=",0,(char*)NULL);
   G__memvar_setup((void*)(&PTDB_NH),73,0,0,-1,-1,-1,1,"PTDB_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&PTDB_S),73,0,0,-1,-1,-1,1,"PTDB_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&PTDB_NS),105,0,0,-1,-1,-1,1,"PTDB_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&RCST),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_RCST_t),-1,-1,1,"RCST=",0,(char*)NULL);
   G__memvar_setup((void*)(&RCST_NH),73,0,0,-1,-1,-1,1,"RCST_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&RCST_S),73,0,0,-1,-1,-1,1,"RCST_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&RCST_NS),105,0,0,-1,-1,-1,1,"RCST_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&REF),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_REF_t),-1,-1,1,"REF=",0,(char*)NULL);
   G__memvar_setup((void*)(&REF_NH),105,0,0,-1,-1,-1,1,"REF_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&REF_S),105,0,0,-1,-1,-1,1,"REF_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&RF),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_RF_t),-1,-1,1,"RF=",0,(char*)NULL);
   G__memvar_setup((void*)(&RF_NH),73,0,0,-1,-1,-1,1,"RF_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&RF_S),73,0,0,-1,-1,-1,1,"RF_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&RF_NS),105,0,0,-1,-1,-1,1,"RF_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&RFT),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_RFT_t),-1,-1,1,"RFT=",0,(char*)NULL);
   G__memvar_setup((void*)(&RFT_NH),105,0,0,-1,-1,-1,1,"RFT_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&RFT_S),105,0,0,-1,-1,-1,1,"RFT_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&RGLK),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_RGLK_t),-1,-1,1,"RGLK=",0,(char*)NULL);
   G__memvar_setup((void*)(&RGLK_NH),73,0,0,-1,-1,-1,1,"RGLK_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&RGLK_S),73,0,0,-1,-1,-1,1,"RGLK_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&RGLK_NS),105,0,0,-1,-1,-1,1,"RGLK_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&RNLG),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_RNLG_t),-1,-1,1,"RNLG=",0,(char*)NULL);
   G__memvar_setup((void*)(&RNLG_NH),73,0,0,-1,-1,-1,1,"RNLG_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&RNLG_S),73,0,0,-1,-1,-1,1,"RNLG_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&RNLG_NS),105,0,0,-1,-1,-1,1,"RNLG_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&RNPE),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_RNPE_t),-1,-1,1,"RNPE=",0,(char*)NULL);
   G__memvar_setup((void*)(&RNPE_NH),73,0,0,-1,-1,-1,1,"RNPE_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&RNPE_S),73,0,0,-1,-1,-1,1,"RNPE_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&RNPE_NS),105,0,0,-1,-1,-1,1,"RNPE_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&RTSL),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_RTSL_t),-1,-1,1,"RTSL=",0,(char*)NULL);
   G__memvar_setup((void*)(&RTSL_NH),73,0,0,-1,-1,-1,1,"RTSL_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&RTSL_S),73,0,0,-1,-1,-1,1,"RTSL_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&RTSL_NS),105,0,0,-1,-1,-1,1,"RTSL_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&RUNC),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_RUNC_t),-1,-1,1,"RUNC=",0,(char*)NULL);
   G__memvar_setup((void*)(&RUNC_NH),73,0,0,-1,-1,-1,1,"RUNC_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&RUNC_S),73,0,0,-1,-1,-1,1,"RUNC_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&RUNC_NS),105,0,0,-1,-1,-1,1,"RUNC_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&S1ST),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_S1ST_t),-1,-1,1,"S1ST=",0,(char*)NULL);
   G__memvar_setup((void*)(&S1ST_NH),73,0,0,-1,-1,-1,1,"S1ST_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&S1ST_S),73,0,0,-1,-1,-1,1,"S1ST_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&S1ST_NS),105,0,0,-1,-1,-1,1,"S1ST_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SC1),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SC1_t),-1,-1,1,"SC1=",0,(char*)NULL);
   G__memvar_setup((void*)(&SC1_NH),73,0,0,-1,-1,-1,1,"SC1_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SC1_S),73,0,0,-1,-1,-1,1,"SC1_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SC1_NS),105,0,0,-1,-1,-1,1,"SC1_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCC),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SCC_t),-1,-1,1,"SCC=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCC_NH),73,0,0,-1,-1,-1,1,"SCC_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCC_S),73,0,0,-1,-1,-1,1,"SCC_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCC_NS),105,0,0,-1,-1,-1,1,"SCC_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SC),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SC_t),-1,-1,1,"SC=",0,(char*)NULL);
   G__memvar_setup((void*)(&SC_NH),73,0,0,-1,-1,-1,1,"SC_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SC_S),73,0,0,-1,-1,-1,1,"SC_S=",0,(char*)NULL);
}

static void G__cpp_setup_global10() {
   G__memvar_setup((void*)(&SC_NS),105,0,0,-1,-1,-1,1,"SC_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCDI),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SCDI_t),-1,-1,1,"SCDI=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCDI_NH),73,0,0,-1,-1,-1,1,"SCDI_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCDI_S),73,0,0,-1,-1,-1,1,"SCDI_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCDI_NS),105,0,0,-1,-1,-1,1,"SCDI_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCGD),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SCGD_t),-1,-1,1,"SCGD=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCGD_NH),73,0,0,-1,-1,-1,1,"SCGD_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCGD_S),73,0,0,-1,-1,-1,1,"SCGD_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCGD_NS),105,0,0,-1,-1,-1,1,"SCGD_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCG),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SCG_t),-1,-1,1,"SCG=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCG_NH),73,0,0,-1,-1,-1,1,"SCG_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCG_S),73,0,0,-1,-1,-1,1,"SCG_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCG_NS),105,0,0,-1,-1,-1,1,"SCG_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCH),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SCH_t),-1,-1,1,"SCH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCH_NH),73,0,0,-1,-1,-1,1,"SCH_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCH_S),73,0,0,-1,-1,-1,1,"SCH_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCH_NS),105,0,0,-1,-1,-1,1,"SCH_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCMD),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SCMD_t),-1,-1,1,"SCMD=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCMD_NH),73,0,0,-1,-1,-1,1,"SCMD_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCMD_S),73,0,0,-1,-1,-1,1,"SCMD_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCMD_NS),105,0,0,-1,-1,-1,1,"SCMD_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCMT),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SCMT_t),-1,-1,1,"SCMT=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCMT_NH),73,0,0,-1,-1,-1,1,"SCMT_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCMT_S),73,0,0,-1,-1,-1,1,"SCMT_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCMT_NS),105,0,0,-1,-1,-1,1,"SCMT_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCMW),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SCMW_t),-1,-1,1,"SCMW=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCMW_NH),73,0,0,-1,-1,-1,1,"SCMW_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCMW_S),73,0,0,-1,-1,-1,1,"SCMW_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCMW_NS),105,0,0,-1,-1,-1,1,"SCMW_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCPB),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_SCPB_t),-1,-1,1,"SCPB=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCPB_NH),105,0,0,-1,-1,-1,1,"SCPB_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCPB_S),105,0,0,-1,-1,-1,1,"SCPB_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCP),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SCP_t),-1,-1,1,"SCP=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCP_NH),73,0,0,-1,-1,-1,1,"SCP_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCP_S),73,0,0,-1,-1,-1,1,"SCP_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCP_NS),105,0,0,-1,-1,-1,1,"SCP_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCPE),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SCPE_t),-1,-1,1,"SCPE=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCPE_NH),73,0,0,-1,-1,-1,1,"SCPE_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCPE_S),73,0,0,-1,-1,-1,1,"SCPE_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCPE_NS),105,0,0,-1,-1,-1,1,"SCPE_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCPS),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SCPS_t),-1,-1,1,"SCPS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCPS_NH),73,0,0,-1,-1,-1,1,"SCPS_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCPS_S),73,0,0,-1,-1,-1,1,"SCPS_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCPS_NS),105,0,0,-1,-1,-1,1,"SCPS_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCRC),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SCRC_t),-1,-1,1,"SCRC=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCRC_NH),73,0,0,-1,-1,-1,1,"SCRC_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCRC_S),73,0,0,-1,-1,-1,1,"SCRC_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCRC_NS),105,0,0,-1,-1,-1,1,"SCRC_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCR),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SCR_t),-1,-1,1,"SCR=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCR_NH),73,0,0,-1,-1,-1,1,"SCR_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCR_S),73,0,0,-1,-1,-1,1,"SCR_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCR_NS),105,0,0,-1,-1,-1,1,"SCR_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCS),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SCS_t),-1,-1,1,"SCS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCS_NH),73,0,0,-1,-1,-1,1,"SCS_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCS_S),73,0,0,-1,-1,-1,1,"SCS_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCS_NS),105,0,0,-1,-1,-1,1,"SCS_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCT),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SCT_t),-1,-1,1,"SCT=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCT_NH),73,0,0,-1,-1,-1,1,"SCT_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCT_S),73,0,0,-1,-1,-1,1,"SCT_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SCT_NS),105,0,0,-1,-1,-1,1,"SCT_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SGMP),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SGMP_t),-1,-1,1,"SGMP=",0,(char*)NULL);
   G__memvar_setup((void*)(&SGMP_NH),73,0,0,-1,-1,-1,1,"SGMP_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SGMP_S),73,0,0,-1,-1,-1,1,"SGMP_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SGMP_NS),105,0,0,-1,-1,-1,1,"SGMP_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SPAR),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SPAR_t),-1,-1,1,"SPAR=",0,(char*)NULL);
   G__memvar_setup((void*)(&SPAR_NH),73,0,0,-1,-1,-1,1,"SPAR_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SPAR_S),73,0,0,-1,-1,-1,1,"SPAR_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SPAR_NS),105,0,0,-1,-1,-1,1,"SPAR_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SPIN),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SPIN_t),-1,-1,1,"SPIN=",0,(char*)NULL);
   G__memvar_setup((void*)(&SPIN_NH),73,0,0,-1,-1,-1,1,"SPIN_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SPIN_S),73,0,0,-1,-1,-1,1,"SPIN_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SPIN_NS),105,0,0,-1,-1,-1,1,"SPIN_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ST1),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_ST1_t),-1,-1,1,"ST1=",0,(char*)NULL);
   G__memvar_setup((void*)(&ST1_NH),73,0,0,-1,-1,-1,1,"ST1_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ST1_S),73,0,0,-1,-1,-1,1,"ST1_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&ST1_NS),105,0,0,-1,-1,-1,1,"ST1_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&ST),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_ST_t),-1,-1,1,"ST=",0,(char*)NULL);
   G__memvar_setup((void*)(&ST_NH),105,0,0,-1,-1,-1,1,"ST_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&ST_S),105,0,0,-1,-1,-1,1,"ST_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&STG),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_STG_t),-1,-1,1,"STG=",0,(char*)NULL);
   G__memvar_setup((void*)(&STG_NH),73,0,0,-1,-1,-1,1,"STG_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&STG_S),73,0,0,-1,-1,-1,1,"STG_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&STG_NS),105,0,0,-1,-1,-1,1,"STG_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&STH),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_STH_t),-1,-1,1,"STH=",0,(char*)NULL);
   G__memvar_setup((void*)(&STH_NH),73,0,0,-1,-1,-1,1,"STH_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&STH_S),73,0,0,-1,-1,-1,1,"STH_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&STH_NS),105,0,0,-1,-1,-1,1,"STH_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&STN0),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_STN0_t),-1,-1,1,"STN0=",0,(char*)NULL);
   G__memvar_setup((void*)(&STN0_NH),105,0,0,-1,-1,-1,1,"STN0_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&STN0_S),105,0,0,-1,-1,-1,1,"STN0_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&STN1),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_STN1_t),-1,-1,1,"STN1=",0,(char*)NULL);
   G__memvar_setup((void*)(&STN1_NH),105,0,0,-1,-1,-1,1,"STN1_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&STN1_S),105,0,0,-1,-1,-1,1,"STN1_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&STPB),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_STPB_t),-1,-1,1,"STPB=",0,(char*)NULL);
   G__memvar_setup((void*)(&STPB_NH),105,0,0,-1,-1,-1,1,"STPB_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&STPB_S),105,0,0,-1,-1,-1,1,"STPB_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&STPE),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_STPE_t),-1,-1,1,"STPE=",0,(char*)NULL);
   G__memvar_setup((void*)(&STPE_NH),73,0,0,-1,-1,-1,1,"STPE_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&STPE_S),73,0,0,-1,-1,-1,1,"STPE_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&STPE_NS),105,0,0,-1,-1,-1,1,"STPE_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&STR),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_STR_t),-1,-1,1,"STR=",0,(char*)NULL);
   G__memvar_setup((void*)(&STR_NH),105,0,0,-1,-1,-1,1,"STR_NH=",0,(char*)NULL);
}

static void G__cpp_setup_global11() {
   G__memvar_setup((void*)(&STR_S),105,0,0,-1,-1,-1,1,"STR_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&STS),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_STS_t),-1,-1,1,"STS=",0,(char*)NULL);
   G__memvar_setup((void*)(&STS_NH),73,0,0,-1,-1,-1,1,"STS_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&STS_S),73,0,0,-1,-1,-1,1,"STS_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&STS_NS),105,0,0,-1,-1,-1,1,"STS_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&STSN),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_STSN_t),-1,-1,1,"STSN=",0,(char*)NULL);
   G__memvar_setup((void*)(&STSN_NH),73,0,0,-1,-1,-1,1,"STSN_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&STSN_S),73,0,0,-1,-1,-1,1,"STSN_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&STSN_NS),105,0,0,-1,-1,-1,1,"STSN_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&SYNC),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_SYNC_t),-1,-1,1,"SYNC=",0,(char*)NULL);
   G__memvar_setup((void*)(&SYNC_NH),73,0,0,-1,-1,-1,1,"SYNC_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&SYNC_S),73,0,0,-1,-1,-1,1,"SYNC_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&SYNC_NS),105,0,0,-1,-1,-1,1,"SYNC_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TACO),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TACO_t),-1,-1,1,"TACO=",0,(char*)NULL);
   G__memvar_setup((void*)(&TACO_NH),73,0,0,-1,-1,-1,1,"TACO_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TACO_S),73,0,0,-1,-1,-1,1,"TACO_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TACO_NS),105,0,0,-1,-1,-1,1,"TACO_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TAGE),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_TAGE_t),-1,-1,1,"TAGE=",0,(char*)NULL);
   G__memvar_setup((void*)(&TAGE_NH),105,0,0,-1,-1,-1,1,"TAGE_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TAGE_S),105,0,0,-1,-1,-1,1,"TAGE_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TAGI),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TAGI_t),-1,-1,1,"TAGI=",0,(char*)NULL);
   G__memvar_setup((void*)(&TAGI_NH),73,0,0,-1,-1,-1,1,"TAGI_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TAGI_S),73,0,0,-1,-1,-1,1,"TAGI_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TAGI_NS),105,0,0,-1,-1,-1,1,"TAGI_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TAGM),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_TAGM_t),-1,-1,1,"TAGM=",0,(char*)NULL);
   G__memvar_setup((void*)(&TAGM_NH),105,0,0,-1,-1,-1,1,"TAGM_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TAGM_S),105,0,0,-1,-1,-1,1,"TAGM_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TAGR),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_TAGR_t),-1,-1,1,"TAGR=",0,(char*)NULL);
   G__memvar_setup((void*)(&TAGR_NH),105,0,0,-1,-1,-1,1,"TAGR_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TAGR_S),105,0,0,-1,-1,-1,1,"TAGR_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TAGT),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_TAGT_t),-1,-1,1,"TAGT=",0,(char*)NULL);
   G__memvar_setup((void*)(&TAGT_NH),105,0,0,-1,-1,-1,1,"TAGT_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TAGT_S),105,0,0,-1,-1,-1,1,"TAGT_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TATL),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TATL_t),-1,-1,1,"TATL=",0,(char*)NULL);
   G__memvar_setup((void*)(&TATL_NH),73,0,0,-1,-1,-1,1,"TATL_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TATL_S),73,0,0,-1,-1,-1,1,"TATL_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TATL_NS),105,0,0,-1,-1,-1,1,"TATL_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TATR),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TATR_t),-1,-1,1,"TATR=",0,(char*)NULL);
   G__memvar_setup((void*)(&TATR_NH),73,0,0,-1,-1,-1,1,"TATR_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TATR_S),73,0,0,-1,-1,-1,1,"TATR_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TATR_NS),105,0,0,-1,-1,-1,1,"TATR_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TBER),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_TBER_t),-1,-1,1,"TBER=",0,(char*)NULL);
   G__memvar_setup((void*)(&TBER_NH),105,0,0,-1,-1,-1,1,"TBER_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TBER_S),105,0,0,-1,-1,-1,1,"TBER_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TBID),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_TBID_t),-1,-1,1,"TBID=",0,(char*)NULL);
   G__memvar_setup((void*)(&TBID_NH),105,0,0,-1,-1,-1,1,"TBID_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TBID_S),105,0,0,-1,-1,-1,1,"TBID_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TBLA),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TBLA_t),-1,-1,1,"TBLA=",0,(char*)NULL);
   G__memvar_setup((void*)(&TBLA_NH),73,0,0,-1,-1,-1,1,"TBLA_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TBLA_S),73,0,0,-1,-1,-1,1,"TBLA_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TBLA_NS),105,0,0,-1,-1,-1,1,"TBLA_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TBTR),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_TBTR_t),-1,-1,1,"TBTR=",0,(char*)NULL);
   G__memvar_setup((void*)(&TBTR_NH),105,0,0,-1,-1,-1,1,"TBTR_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TBTR_S),105,0,0,-1,-1,-1,1,"TBTR_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TCSB),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TCSB_t),-1,-1,1,"TCSB=",0,(char*)NULL);
   G__memvar_setup((void*)(&TCSB_NH),73,0,0,-1,-1,-1,1,"TCSB_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TCSB_S),73,0,0,-1,-1,-1,1,"TCSB_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TCSB_NS),105,0,0,-1,-1,-1,1,"TCSB_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TCT),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TCT_t),-1,-1,1,"TCT=",0,(char*)NULL);
   G__memvar_setup((void*)(&TCT_NH),73,0,0,-1,-1,-1,1,"TCT_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TCT_S),73,0,0,-1,-1,-1,1,"TCT_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TCT_NS),105,0,0,-1,-1,-1,1,"TCT_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TDPL),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TDPL_t),-1,-1,1,"TDPL=",0,(char*)NULL);
   G__memvar_setup((void*)(&TDPL_NH),73,0,0,-1,-1,-1,1,"TDPL_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TDPL_S),73,0,0,-1,-1,-1,1,"TDPL_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TDPL_NS),105,0,0,-1,-1,-1,1,"TDPL_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TESC),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_TESC_t),-1,-1,1,"TESC=",0,(char*)NULL);
   G__memvar_setup((void*)(&TESC_NH),105,0,0,-1,-1,-1,1,"TESC_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TESC_S),105,0,0,-1,-1,-1,1,"TESC_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGBI),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_TGBI_t),-1,-1,1,"TGBI=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGBI_NH),105,0,0,-1,-1,-1,1,"TGBI_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGBI_S),105,0,0,-1,-1,-1,1,"TGBI_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGEO),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TGEO_t),-1,-1,1,"TGEO=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGEO_NH),73,0,0,-1,-1,-1,1,"TGEO_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGEO_S),73,0,0,-1,-1,-1,1,"TGEO_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGEO_NS),105,0,0,-1,-1,-1,1,"TGEO_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGPB),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_TGPB_t),-1,-1,1,"TGPB=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGPB_NH),105,0,0,-1,-1,-1,1,"TGPB_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGPB_S),105,0,0,-1,-1,-1,1,"TGPB_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGS),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TGS_t),-1,-1,1,"TGS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGS_NH),73,0,0,-1,-1,-1,1,"TGS_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGS_S),73,0,0,-1,-1,-1,1,"TGS_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGS_NS),105,0,0,-1,-1,-1,1,"TGS_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGTL),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_TGTL_t),-1,-1,1,"TGTL=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGTL_NH),105,0,0,-1,-1,-1,1,"TGTL_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGTL_S),105,0,0,-1,-1,-1,1,"TGTL_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGTR),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_TGTR_t),-1,-1,1,"TGTR=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGTR_NH),105,0,0,-1,-1,-1,1,"TGTR_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TGTR_S),105,0,0,-1,-1,-1,1,"TGTR_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TLV1),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TLV1_t),-1,-1,1,"TLV1=",0,(char*)NULL);
   G__memvar_setup((void*)(&TLV1_NH),73,0,0,-1,-1,-1,1,"TLV1_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TLV1_S),73,0,0,-1,-1,-1,1,"TLV1_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TLV1_NS),105,0,0,-1,-1,-1,1,"TLV1_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRCF),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TRCF_t),-1,-1,1,"TRCF=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRCF_NH),73,0,0,-1,-1,-1,1,"TRCF_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRCF_S),73,0,0,-1,-1,-1,1,"TRCF_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRCF_NS),105,0,0,-1,-1,-1,1,"TRCF_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRGS),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TRGS_t),-1,-1,1,"TRGS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRGS_NH),73,0,0,-1,-1,-1,1,"TRGS_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRGS_S),73,0,0,-1,-1,-1,1,"TRGS_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRGS_NS),105,0,0,-1,-1,-1,1,"TRGS_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRKS),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TRKS_t),-1,-1,1,"TRKS=",0,(char*)NULL);
}

static void G__cpp_setup_global12() {
   G__memvar_setup((void*)(&TRKS_NH),73,0,0,-1,-1,-1,1,"TRKS_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRKS_S),73,0,0,-1,-1,-1,1,"TRKS_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRKS_NS),105,0,0,-1,-1,-1,1,"TRKS_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRL1),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TRL1_t),-1,-1,1,"TRL1=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRL1_NH),73,0,0,-1,-1,-1,1,"TRL1_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRL1_S),73,0,0,-1,-1,-1,1,"TRL1_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRL1_NS),105,0,0,-1,-1,-1,1,"TRL1_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRPB),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TRPB_t),-1,-1,1,"TRPB=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRPB_NH),73,0,0,-1,-1,-1,1,"TRPB_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRPB_S),73,0,0,-1,-1,-1,1,"TRPB_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TRPB_NS),105,0,0,-1,-1,-1,1,"TRPB_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TSPR),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TSPR_t),-1,-1,1,"TSPR=",0,(char*)NULL);
   G__memvar_setup((void*)(&TSPR_NH),73,0,0,-1,-1,-1,1,"TSPR_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TSPR_S),73,0,0,-1,-1,-1,1,"TSPR_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TSPR_NS),105,0,0,-1,-1,-1,1,"TSPR_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&TSRG),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_TSRG_t),-1,-1,1,"TSRG=",0,(char*)NULL);
   G__memvar_setup((void*)(&TSRG_NH),73,0,0,-1,-1,-1,1,"TSRG_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&TSRG_S),73,0,0,-1,-1,-1,1,"TSRG_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&TSRG_NS),105,0,0,-1,-1,-1,1,"TSRG_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&UNUS),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_UNUS_t),-1,-1,1,"UNUS=",0,(char*)NULL);
   G__memvar_setup((void*)(&UNUS_NH),73,0,0,-1,-1,-1,1,"UNUS_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&UNUS_S),73,0,0,-1,-1,-1,1,"UNUS_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&UNUS_NS),105,0,0,-1,-1,-1,1,"UNUS_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&VERT),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_VERT_t),-1,-1,1,"VERT=",0,(char*)NULL);
   G__memvar_setup((void*)(&VERT_NH),73,0,0,-1,-1,-1,1,"VERT_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&VERT_S),73,0,0,-1,-1,-1,1,"VERT_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&VERT_NS),105,0,0,-1,-1,-1,1,"VERT_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&RC26),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_RC26_t),-1,-1,1,"RC26=",0,(char*)NULL);
   G__memvar_setup((void*)(&RC26_NH),105,0,0,-1,-1,-1,1,"RC26_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&RC26_S),105,0,0,-1,-1,-1,1,"RC26_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&STRE),85,2,0,G__get_linked_tagnum(&G__bankvarsDictLN_STRE_t),-1,-1,1,"STRE=",0,(char*)NULL);
   G__memvar_setup((void*)(&STRE_NH),73,0,0,-1,-1,-1,1,"STRE_NH=",0,(char*)NULL);
   G__memvar_setup((void*)(&STRE_S),73,0,0,-1,-1,-1,1,"STRE_S=",0,(char*)NULL);
   G__memvar_setup((void*)(&STRE_NS),105,0,0,-1,-1,-1,1,"STRE_NS=",0,(char*)NULL);
   G__memvar_setup((void*)(&nBankTypes),105,0,0,-1,-1,-1,1,"nBankTypes=",0,(char*)NULL);
   G__memvar_setup((void*)(&bankAddress),85,0,0,G__get_linked_tagnum(&G__bankvarsDictLN_addressBanks_t),-1,-1,1,"bankAddress=",0,(char*)NULL);

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalbankvarsDict() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
  G__cpp_setup_global2();
  G__cpp_setup_global3();
  G__cpp_setup_global4();
  G__cpp_setup_global5();
  G__cpp_setup_global6();
  G__cpp_setup_global7();
  G__cpp_setup_global8();
  G__cpp_setup_global9();
  G__cpp_setup_global10();
  G__cpp_setup_global11();
  G__cpp_setup_global12();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {
}

static void G__cpp_setup_func11() {
}

static void G__cpp_setup_func12() {
}

static void G__cpp_setup_func13() {
}

static void G__cpp_setup_func14() {
}

static void G__cpp_setup_func15() {
}

static void G__cpp_setup_func16() {
}

static void G__cpp_setup_func17() {
}

static void G__cpp_setup_func18() {
}

static void G__cpp_setup_func19() {
}

static void G__cpp_setup_func20() {
}

static void G__cpp_setup_func21() {
}

static void G__cpp_setup_func22() {
}

static void G__cpp_setup_func23() {
}

static void G__cpp_setup_func24() {
}

static void G__cpp_setup_func25() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcbankvarsDict() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
  G__cpp_setup_func11();
  G__cpp_setup_func12();
  G__cpp_setup_func13();
  G__cpp_setup_func14();
  G__cpp_setup_func15();
  G__cpp_setup_func16();
  G__cpp_setup_func17();
  G__cpp_setup_func18();
  G__cpp_setup_func19();
  G__cpp_setup_func20();
  G__cpp_setup_func21();
  G__cpp_setup_func22();
  G__cpp_setup_func23();
  G__cpp_setup_func24();
  G__cpp_setup_func25();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__bankvarsDictLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR = { "vector<unsigned int,allocator<unsigned int> >" , 99 , -1 };
G__linked_taginfo G__bankvarsDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__bankvarsDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__bankvarsDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__bankvarsDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__bankvarsDictLN_BEAM_t = { "BEAM_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_BMPR_t = { "BMPR_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_BREP_t = { "BREP_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CALB_t = { "CALB_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CALL_t = { "CALL_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CC01_t = { "CC01_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CC1_t = { "CC1_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CC_t = { "CC_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CCDI_t = { "CCDI_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CCH_t = { "CCH_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CCMT_t = { "CCMT_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CCPB_t = { "CCPB_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CCPE_t = { "CCPE_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CCRC_t = { "CCRC_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CCS_t = { "CCS_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CCT_t = { "CCT_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CHI2_t = { "CHI2_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CL01_t = { "CL01_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CLST_t = { "CLST_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CPED_t = { "CPED_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_CSQL_t = { "CSQL_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DC0_t = { "DC0_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DC1_t = { "DC1_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DCDW_t = { "DCDW_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DCGM_t = { "DCGM_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DCGW_t = { "DCGW_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DCH_t = { "DCH_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DCMN_t = { "DCMN_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DCPB_t = { "DCPB_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DCV1_t = { "DCV1_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DCV2_t = { "DCV2_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DCV3_t = { "DCV3_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DDLY_t = { "DDLY_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DGEO_t = { "DGEO_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DHCL_t = { "DHCL_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DITM_t = { "DITM_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DOCA_t = { "DOCA_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DPCP_t = { "DPCP_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DPSP_t = { "DPSP_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DSPC_t = { "DSPC_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DSPS_t = { "DSPS_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DSTC_t = { "DSTC_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DTCP_t = { "DTCP_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_DTRK_t = { "DTRK_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_EC01_t = { "EC01_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_EC1_t = { "EC1_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_EC1P_t = { "EC1P_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_EC1R_t = { "EC1R_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECCA_t = { "ECCA_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECCL_t = { "ECCL_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECCT_t = { "ECCT_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_EC_t = { "EC_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECDI_t = { "ECDI_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECG_t = { "ECG_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECHB_t = { "ECHB_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECH_t = { "ECH_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECMT_t = { "ECMT_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECP1_t = { "ECP1_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECPB_t = { "ECPB_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECPC_t = { "ECPC_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECP_t = { "ECP_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECPE_t = { "ECPE_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECPI_t = { "ECPI_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECPO_t = { "ECPO_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECRB_t = { "ECRB_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECS_t = { "ECS_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ECT_t = { "ECT_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_EID0_t = { "EID0_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_EPIC_t = { "EPIC_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_EVNT_t = { "EVNT_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_FBPM_t = { "FBPM_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_G1SL_t = { "G1SL_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_G2SL_t = { "G2SL_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_G3SL_t = { "G3SL_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_G4SL_t = { "G4SL_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_GPAR_t = { "GPAR_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_GPID_t = { "GPID_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_GP_X_t = { "GP_X_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_GP_Y_t = { "GP_Y_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_HBER_t = { "HBER_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_HBID_t = { "HBID_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_HBLA_t = { "HBLA_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_HBTB_t = { "HBTB_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_HBTR_t = { "HBTR_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_HCAL_t = { "HCAL_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_HDPL_t = { "HDPL_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_HEAD_t = { "HEAD_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_HEVT_t = { "HEVT_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_HLS_t = { "HLS_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_IC_t = { "IC_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ICHB_t = { "ICHB_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_KFIT_t = { "KFIT_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_L1PG_t = { "L1PG_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_L2H_t = { "L2H_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_L2S_t = { "L2S_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_LASR_t = { "LASR_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_LCDI_t = { "LCDI_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_LCPB_t = { "LCPB_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_LOWQ_t = { "LOWQ_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_MCEV_t = { "MCEV_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_MCHD_t = { "MCHD_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_MCTK_t = { "MCTK_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_MCVX_t = { "MCVX_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_MS1_t = { "MS1_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_MTRK_t = { "MTRK_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_MVRT_t = { "MVRT_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_PART_t = { "PART_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_PCO_t = { "PCO_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_PHTM_t = { "PHTM_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_PID1_t = { "PID1_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_PID2_t = { "PID2_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_PID3_t = { "PID3_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_PID4_t = { "PID4_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_PID5_t = { "PID5_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_PID6_t = { "PID6_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_PIDT_t = { "PIDT_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_PRTM_t = { "PRTM_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_PSO_t = { "PSO_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_PTDB_t = { "PTDB_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_RCST_t = { "RCST_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_REF_t = { "REF_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_RF_t = { "RF_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_RFT_t = { "RFT_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_RGLK_t = { "RGLK_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_RNLG_t = { "RNLG_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_RNPE_t = { "RNPE_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_RTSL_t = { "RTSL_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_RUNC_t = { "RUNC_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_S1ST_t = { "S1ST_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SC1_t = { "SC1_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SCC_t = { "SCC_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SC_t = { "SC_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SCDI_t = { "SCDI_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SCGD_t = { "SCGD_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SCG_t = { "SCG_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SCH_t = { "SCH_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SCMD_t = { "SCMD_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SCMT_t = { "SCMT_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SCMW_t = { "SCMW_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SCPB_t = { "SCPB_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SCP_t = { "SCP_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SCPE_t = { "SCPE_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SCPS_t = { "SCPS_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SCRC_t = { "SCRC_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SCR_t = { "SCR_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SCS_t = { "SCS_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SCT_t = { "SCT_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SGMP_t = { "SGMP_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SPAR_t = { "SPAR_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SPIN_t = { "SPIN_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ST1_t = { "ST1_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_ST_t = { "ST_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_STG_t = { "STG_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_STH_t = { "STH_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_STN0_t = { "STN0_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_STN1_t = { "STN1_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_STPB_t = { "STPB_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_STPE_t = { "STPE_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_STR_t = { "STR_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_STS_t = { "STS_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_STSN_t = { "STSN_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_SYNC_t = { "SYNC_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TACO_t = { "TACO_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TAGE_t = { "TAGE_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TAGI_t = { "TAGI_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TAGM_t = { "TAGM_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TAGR_t = { "TAGR_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TAGT_t = { "TAGT_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TATL_t = { "TATL_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TATR_t = { "TATR_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TBER_t = { "TBER_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TBID_t = { "TBID_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TBLA_t = { "TBLA_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TBTR_t = { "TBTR_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TCSB_t = { "TCSB_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TCT_t = { "TCT_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TDPL_t = { "TDPL_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TESC_t = { "TESC_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TGBI_t = { "TGBI_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TGEO_t = { "TGEO_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TGPB_t = { "TGPB_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TGS_t = { "TGS_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TGTL_t = { "TGTL_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TGTR_t = { "TGTR_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TLV1_t = { "TLV1_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TRCF_t = { "TRCF_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TRGS_t = { "TRGS_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TRKS_t = { "TRKS_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TRL1_t = { "TRL1_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TRPB_t = { "TRPB_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TSPR_t = { "TSPR_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_TSRG_t = { "TSRG_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_UNUS_t = { "UNUS_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_VERT_t = { "VERT_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_RC26_t = { "RC26_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_STRE_t = { "STRE_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_addressBanks_t = { "addressBanks_t" , 115 , -1 };
G__linked_taginfo G__bankvarsDictLN_vectorlETStringcOallocatorlETStringgRsPgR = { "vector<TString,allocator<TString> >" , 99 , -1 };
G__linked_taginfo G__bankvarsDictLN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TString,allocator<TString> >::iterator>" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtablebankvarsDict() {
  G__bankvarsDictLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR.tagnum = -1 ;
  G__bankvarsDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__bankvarsDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__bankvarsDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__bankvarsDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__bankvarsDictLN_BEAM_t.tagnum = -1 ;
  G__bankvarsDictLN_BMPR_t.tagnum = -1 ;
  G__bankvarsDictLN_BREP_t.tagnum = -1 ;
  G__bankvarsDictLN_CALB_t.tagnum = -1 ;
  G__bankvarsDictLN_CALL_t.tagnum = -1 ;
  G__bankvarsDictLN_CC01_t.tagnum = -1 ;
  G__bankvarsDictLN_CC1_t.tagnum = -1 ;
  G__bankvarsDictLN_CC_t.tagnum = -1 ;
  G__bankvarsDictLN_CCDI_t.tagnum = -1 ;
  G__bankvarsDictLN_CCH_t.tagnum = -1 ;
  G__bankvarsDictLN_CCMT_t.tagnum = -1 ;
  G__bankvarsDictLN_CCPB_t.tagnum = -1 ;
  G__bankvarsDictLN_CCPE_t.tagnum = -1 ;
  G__bankvarsDictLN_CCRC_t.tagnum = -1 ;
  G__bankvarsDictLN_CCS_t.tagnum = -1 ;
  G__bankvarsDictLN_CCT_t.tagnum = -1 ;
  G__bankvarsDictLN_CHI2_t.tagnum = -1 ;
  G__bankvarsDictLN_CL01_t.tagnum = -1 ;
  G__bankvarsDictLN_CLST_t.tagnum = -1 ;
  G__bankvarsDictLN_CPED_t.tagnum = -1 ;
  G__bankvarsDictLN_CSQL_t.tagnum = -1 ;
  G__bankvarsDictLN_DC0_t.tagnum = -1 ;
  G__bankvarsDictLN_DC1_t.tagnum = -1 ;
  G__bankvarsDictLN_DCDW_t.tagnum = -1 ;
  G__bankvarsDictLN_DCGM_t.tagnum = -1 ;
  G__bankvarsDictLN_DCGW_t.tagnum = -1 ;
  G__bankvarsDictLN_DCH_t.tagnum = -1 ;
  G__bankvarsDictLN_DCMN_t.tagnum = -1 ;
  G__bankvarsDictLN_DCPB_t.tagnum = -1 ;
  G__bankvarsDictLN_DCV1_t.tagnum = -1 ;
  G__bankvarsDictLN_DCV2_t.tagnum = -1 ;
  G__bankvarsDictLN_DCV3_t.tagnum = -1 ;
  G__bankvarsDictLN_DDLY_t.tagnum = -1 ;
  G__bankvarsDictLN_DGEO_t.tagnum = -1 ;
  G__bankvarsDictLN_DHCL_t.tagnum = -1 ;
  G__bankvarsDictLN_DITM_t.tagnum = -1 ;
  G__bankvarsDictLN_DOCA_t.tagnum = -1 ;
  G__bankvarsDictLN_DPCP_t.tagnum = -1 ;
  G__bankvarsDictLN_DPSP_t.tagnum = -1 ;
  G__bankvarsDictLN_DSPC_t.tagnum = -1 ;
  G__bankvarsDictLN_DSPS_t.tagnum = -1 ;
  G__bankvarsDictLN_DSTC_t.tagnum = -1 ;
  G__bankvarsDictLN_DTCP_t.tagnum = -1 ;
  G__bankvarsDictLN_DTRK_t.tagnum = -1 ;
  G__bankvarsDictLN_EC01_t.tagnum = -1 ;
  G__bankvarsDictLN_EC1_t.tagnum = -1 ;
  G__bankvarsDictLN_EC1P_t.tagnum = -1 ;
  G__bankvarsDictLN_EC1R_t.tagnum = -1 ;
  G__bankvarsDictLN_ECCA_t.tagnum = -1 ;
  G__bankvarsDictLN_ECCL_t.tagnum = -1 ;
  G__bankvarsDictLN_ECCT_t.tagnum = -1 ;
  G__bankvarsDictLN_EC_t.tagnum = -1 ;
  G__bankvarsDictLN_ECDI_t.tagnum = -1 ;
  G__bankvarsDictLN_ECG_t.tagnum = -1 ;
  G__bankvarsDictLN_ECHB_t.tagnum = -1 ;
  G__bankvarsDictLN_ECH_t.tagnum = -1 ;
  G__bankvarsDictLN_ECMT_t.tagnum = -1 ;
  G__bankvarsDictLN_ECP1_t.tagnum = -1 ;
  G__bankvarsDictLN_ECPB_t.tagnum = -1 ;
  G__bankvarsDictLN_ECPC_t.tagnum = -1 ;
  G__bankvarsDictLN_ECP_t.tagnum = -1 ;
  G__bankvarsDictLN_ECPE_t.tagnum = -1 ;
  G__bankvarsDictLN_ECPI_t.tagnum = -1 ;
  G__bankvarsDictLN_ECPO_t.tagnum = -1 ;
  G__bankvarsDictLN_ECRB_t.tagnum = -1 ;
  G__bankvarsDictLN_ECS_t.tagnum = -1 ;
  G__bankvarsDictLN_ECT_t.tagnum = -1 ;
  G__bankvarsDictLN_EID0_t.tagnum = -1 ;
  G__bankvarsDictLN_EPIC_t.tagnum = -1 ;
  G__bankvarsDictLN_EVNT_t.tagnum = -1 ;
  G__bankvarsDictLN_FBPM_t.tagnum = -1 ;
  G__bankvarsDictLN_G1SL_t.tagnum = -1 ;
  G__bankvarsDictLN_G2SL_t.tagnum = -1 ;
  G__bankvarsDictLN_G3SL_t.tagnum = -1 ;
  G__bankvarsDictLN_G4SL_t.tagnum = -1 ;
  G__bankvarsDictLN_GPAR_t.tagnum = -1 ;
  G__bankvarsDictLN_GPID_t.tagnum = -1 ;
  G__bankvarsDictLN_GP_X_t.tagnum = -1 ;
  G__bankvarsDictLN_GP_Y_t.tagnum = -1 ;
  G__bankvarsDictLN_HBER_t.tagnum = -1 ;
  G__bankvarsDictLN_HBID_t.tagnum = -1 ;
  G__bankvarsDictLN_HBLA_t.tagnum = -1 ;
  G__bankvarsDictLN_HBTB_t.tagnum = -1 ;
  G__bankvarsDictLN_HBTR_t.tagnum = -1 ;
  G__bankvarsDictLN_HCAL_t.tagnum = -1 ;
  G__bankvarsDictLN_HDPL_t.tagnum = -1 ;
  G__bankvarsDictLN_HEAD_t.tagnum = -1 ;
  G__bankvarsDictLN_HEVT_t.tagnum = -1 ;
  G__bankvarsDictLN_HLS_t.tagnum = -1 ;
  G__bankvarsDictLN_IC_t.tagnum = -1 ;
  G__bankvarsDictLN_ICHB_t.tagnum = -1 ;
  G__bankvarsDictLN_KFIT_t.tagnum = -1 ;
  G__bankvarsDictLN_L1PG_t.tagnum = -1 ;
  G__bankvarsDictLN_L2H_t.tagnum = -1 ;
  G__bankvarsDictLN_L2S_t.tagnum = -1 ;
  G__bankvarsDictLN_LASR_t.tagnum = -1 ;
  G__bankvarsDictLN_LCDI_t.tagnum = -1 ;
  G__bankvarsDictLN_LCPB_t.tagnum = -1 ;
  G__bankvarsDictLN_LOWQ_t.tagnum = -1 ;
  G__bankvarsDictLN_MCEV_t.tagnum = -1 ;
  G__bankvarsDictLN_MCHD_t.tagnum = -1 ;
  G__bankvarsDictLN_MCTK_t.tagnum = -1 ;
  G__bankvarsDictLN_MCVX_t.tagnum = -1 ;
  G__bankvarsDictLN_MS1_t.tagnum = -1 ;
  G__bankvarsDictLN_MTRK_t.tagnum = -1 ;
  G__bankvarsDictLN_MVRT_t.tagnum = -1 ;
  G__bankvarsDictLN_PART_t.tagnum = -1 ;
  G__bankvarsDictLN_PCO_t.tagnum = -1 ;
  G__bankvarsDictLN_PHTM_t.tagnum = -1 ;
  G__bankvarsDictLN_PID1_t.tagnum = -1 ;
  G__bankvarsDictLN_PID2_t.tagnum = -1 ;
  G__bankvarsDictLN_PID3_t.tagnum = -1 ;
  G__bankvarsDictLN_PID4_t.tagnum = -1 ;
  G__bankvarsDictLN_PID5_t.tagnum = -1 ;
  G__bankvarsDictLN_PID6_t.tagnum = -1 ;
  G__bankvarsDictLN_PIDT_t.tagnum = -1 ;
  G__bankvarsDictLN_PRTM_t.tagnum = -1 ;
  G__bankvarsDictLN_PSO_t.tagnum = -1 ;
  G__bankvarsDictLN_PTDB_t.tagnum = -1 ;
  G__bankvarsDictLN_RCST_t.tagnum = -1 ;
  G__bankvarsDictLN_REF_t.tagnum = -1 ;
  G__bankvarsDictLN_RF_t.tagnum = -1 ;
  G__bankvarsDictLN_RFT_t.tagnum = -1 ;
  G__bankvarsDictLN_RGLK_t.tagnum = -1 ;
  G__bankvarsDictLN_RNLG_t.tagnum = -1 ;
  G__bankvarsDictLN_RNPE_t.tagnum = -1 ;
  G__bankvarsDictLN_RTSL_t.tagnum = -1 ;
  G__bankvarsDictLN_RUNC_t.tagnum = -1 ;
  G__bankvarsDictLN_S1ST_t.tagnum = -1 ;
  G__bankvarsDictLN_SC1_t.tagnum = -1 ;
  G__bankvarsDictLN_SCC_t.tagnum = -1 ;
  G__bankvarsDictLN_SC_t.tagnum = -1 ;
  G__bankvarsDictLN_SCDI_t.tagnum = -1 ;
  G__bankvarsDictLN_SCGD_t.tagnum = -1 ;
  G__bankvarsDictLN_SCG_t.tagnum = -1 ;
  G__bankvarsDictLN_SCH_t.tagnum = -1 ;
  G__bankvarsDictLN_SCMD_t.tagnum = -1 ;
  G__bankvarsDictLN_SCMT_t.tagnum = -1 ;
  G__bankvarsDictLN_SCMW_t.tagnum = -1 ;
  G__bankvarsDictLN_SCPB_t.tagnum = -1 ;
  G__bankvarsDictLN_SCP_t.tagnum = -1 ;
  G__bankvarsDictLN_SCPE_t.tagnum = -1 ;
  G__bankvarsDictLN_SCPS_t.tagnum = -1 ;
  G__bankvarsDictLN_SCRC_t.tagnum = -1 ;
  G__bankvarsDictLN_SCR_t.tagnum = -1 ;
  G__bankvarsDictLN_SCS_t.tagnum = -1 ;
  G__bankvarsDictLN_SCT_t.tagnum = -1 ;
  G__bankvarsDictLN_SGMP_t.tagnum = -1 ;
  G__bankvarsDictLN_SPAR_t.tagnum = -1 ;
  G__bankvarsDictLN_SPIN_t.tagnum = -1 ;
  G__bankvarsDictLN_ST1_t.tagnum = -1 ;
  G__bankvarsDictLN_ST_t.tagnum = -1 ;
  G__bankvarsDictLN_STG_t.tagnum = -1 ;
  G__bankvarsDictLN_STH_t.tagnum = -1 ;
  G__bankvarsDictLN_STN0_t.tagnum = -1 ;
  G__bankvarsDictLN_STN1_t.tagnum = -1 ;
  G__bankvarsDictLN_STPB_t.tagnum = -1 ;
  G__bankvarsDictLN_STPE_t.tagnum = -1 ;
  G__bankvarsDictLN_STR_t.tagnum = -1 ;
  G__bankvarsDictLN_STS_t.tagnum = -1 ;
  G__bankvarsDictLN_STSN_t.tagnum = -1 ;
  G__bankvarsDictLN_SYNC_t.tagnum = -1 ;
  G__bankvarsDictLN_TACO_t.tagnum = -1 ;
  G__bankvarsDictLN_TAGE_t.tagnum = -1 ;
  G__bankvarsDictLN_TAGI_t.tagnum = -1 ;
  G__bankvarsDictLN_TAGM_t.tagnum = -1 ;
  G__bankvarsDictLN_TAGR_t.tagnum = -1 ;
  G__bankvarsDictLN_TAGT_t.tagnum = -1 ;
  G__bankvarsDictLN_TATL_t.tagnum = -1 ;
  G__bankvarsDictLN_TATR_t.tagnum = -1 ;
  G__bankvarsDictLN_TBER_t.tagnum = -1 ;
  G__bankvarsDictLN_TBID_t.tagnum = -1 ;
  G__bankvarsDictLN_TBLA_t.tagnum = -1 ;
  G__bankvarsDictLN_TBTR_t.tagnum = -1 ;
  G__bankvarsDictLN_TCSB_t.tagnum = -1 ;
  G__bankvarsDictLN_TCT_t.tagnum = -1 ;
  G__bankvarsDictLN_TDPL_t.tagnum = -1 ;
  G__bankvarsDictLN_TESC_t.tagnum = -1 ;
  G__bankvarsDictLN_TGBI_t.tagnum = -1 ;
  G__bankvarsDictLN_TGEO_t.tagnum = -1 ;
  G__bankvarsDictLN_TGPB_t.tagnum = -1 ;
  G__bankvarsDictLN_TGS_t.tagnum = -1 ;
  G__bankvarsDictLN_TGTL_t.tagnum = -1 ;
  G__bankvarsDictLN_TGTR_t.tagnum = -1 ;
  G__bankvarsDictLN_TLV1_t.tagnum = -1 ;
  G__bankvarsDictLN_TRCF_t.tagnum = -1 ;
  G__bankvarsDictLN_TRGS_t.tagnum = -1 ;
  G__bankvarsDictLN_TRKS_t.tagnum = -1 ;
  G__bankvarsDictLN_TRL1_t.tagnum = -1 ;
  G__bankvarsDictLN_TRPB_t.tagnum = -1 ;
  G__bankvarsDictLN_TSPR_t.tagnum = -1 ;
  G__bankvarsDictLN_TSRG_t.tagnum = -1 ;
  G__bankvarsDictLN_UNUS_t.tagnum = -1 ;
  G__bankvarsDictLN_VERT_t.tagnum = -1 ;
  G__bankvarsDictLN_RC26_t.tagnum = -1 ;
  G__bankvarsDictLN_STRE_t.tagnum = -1 ;
  G__bankvarsDictLN_addressBanks_t.tagnum = -1 ;
  G__bankvarsDictLN_vectorlETStringcOallocatorlETStringgRsPgR.tagnum = -1 ;
  G__bankvarsDictLN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtablebankvarsDict() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__bankvarsDictLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR);
   G__get_linked_tagnum_fwd(&G__bankvarsDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__bankvarsDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__bankvarsDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__bankvarsDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_BEAM_t),sizeof(BEAM_t),-1,0,(char*)NULL,G__setup_memvarBEAM_t,G__setup_memfuncBEAM_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_BMPR_t),sizeof(BMPR_t),-1,0,(char*)NULL,G__setup_memvarBMPR_t,G__setup_memfuncBMPR_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_BREP_t),sizeof(BREP_t),-1,0,(char*)NULL,G__setup_memvarBREP_t,G__setup_memfuncBREP_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CALB_t),sizeof(CALB_t),-1,0,(char*)NULL,G__setup_memvarCALB_t,G__setup_memfuncCALB_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CALL_t),sizeof(CALL_t),-1,0,(char*)NULL,G__setup_memvarCALL_t,G__setup_memfuncCALL_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CC01_t),sizeof(CC01_t),-1,0,(char*)NULL,G__setup_memvarCC01_t,G__setup_memfuncCC01_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CC1_t),sizeof(CC1_t),-1,0,(char*)NULL,G__setup_memvarCC1_t,G__setup_memfuncCC1_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CC_t),sizeof(CC_t),-1,0,(char*)NULL,G__setup_memvarCC_t,G__setup_memfuncCC_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CCDI_t),sizeof(CCDI_t),-1,0,(char*)NULL,G__setup_memvarCCDI_t,G__setup_memfuncCCDI_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CCH_t),sizeof(CCH_t),-1,0,(char*)NULL,G__setup_memvarCCH_t,G__setup_memfuncCCH_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CCMT_t),sizeof(CCMT_t),-1,0,(char*)NULL,G__setup_memvarCCMT_t,G__setup_memfuncCCMT_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CCPB_t),sizeof(CCPB_t),-1,0,(char*)NULL,G__setup_memvarCCPB_t,G__setup_memfuncCCPB_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CCPE_t),sizeof(CCPE_t),-1,0,(char*)NULL,G__setup_memvarCCPE_t,G__setup_memfuncCCPE_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CCRC_t),sizeof(CCRC_t),-1,0,(char*)NULL,G__setup_memvarCCRC_t,G__setup_memfuncCCRC_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CCS_t),sizeof(CCS_t),-1,0,(char*)NULL,G__setup_memvarCCS_t,G__setup_memfuncCCS_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CCT_t),sizeof(CCT_t),-1,0,(char*)NULL,G__setup_memvarCCT_t,G__setup_memfuncCCT_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CHI2_t),sizeof(CHI2_t),-1,0,(char*)NULL,G__setup_memvarCHI2_t,G__setup_memfuncCHI2_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CL01_t),sizeof(CL01_t),-1,0,(char*)NULL,G__setup_memvarCL01_t,G__setup_memfuncCL01_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CLST_t),sizeof(CLST_t),-1,0,(char*)NULL,G__setup_memvarCLST_t,G__setup_memfuncCLST_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CPED_t),sizeof(CPED_t),-1,0,(char*)NULL,G__setup_memvarCPED_t,G__setup_memfuncCPED_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_CSQL_t),sizeof(CSQL_t),-1,0,(char*)NULL,G__setup_memvarCSQL_t,G__setup_memfuncCSQL_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DC0_t),sizeof(DC0_t),-1,0,(char*)NULL,G__setup_memvarDC0_t,G__setup_memfuncDC0_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DC1_t),sizeof(DC1_t),-1,0,(char*)NULL,G__setup_memvarDC1_t,G__setup_memfuncDC1_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DCDW_t),sizeof(DCDW_t),-1,0,(char*)NULL,G__setup_memvarDCDW_t,G__setup_memfuncDCDW_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DCGM_t),sizeof(DCGM_t),-1,0,(char*)NULL,G__setup_memvarDCGM_t,G__setup_memfuncDCGM_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DCGW_t),sizeof(DCGW_t),-1,0,(char*)NULL,G__setup_memvarDCGW_t,G__setup_memfuncDCGW_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DCH_t),sizeof(DCH_t),-1,0,(char*)NULL,G__setup_memvarDCH_t,G__setup_memfuncDCH_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DCMN_t),sizeof(DCMN_t),-1,0,(char*)NULL,G__setup_memvarDCMN_t,G__setup_memfuncDCMN_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DCPB_t),sizeof(DCPB_t),-1,0,(char*)NULL,G__setup_memvarDCPB_t,G__setup_memfuncDCPB_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DCV1_t),sizeof(DCV1_t),-1,0,(char*)NULL,G__setup_memvarDCV1_t,G__setup_memfuncDCV1_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DCV2_t),sizeof(DCV2_t),-1,0,(char*)NULL,G__setup_memvarDCV2_t,G__setup_memfuncDCV2_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DCV3_t),sizeof(DCV3_t),-1,0,(char*)NULL,G__setup_memvarDCV3_t,G__setup_memfuncDCV3_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DDLY_t),sizeof(DDLY_t),-1,0,(char*)NULL,G__setup_memvarDDLY_t,G__setup_memfuncDDLY_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DGEO_t),sizeof(DGEO_t),-1,0,(char*)NULL,G__setup_memvarDGEO_t,G__setup_memfuncDGEO_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DHCL_t),sizeof(DHCL_t),-1,0,(char*)NULL,G__setup_memvarDHCL_t,G__setup_memfuncDHCL_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DITM_t),sizeof(DITM_t),-1,0,(char*)NULL,G__setup_memvarDITM_t,G__setup_memfuncDITM_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DOCA_t),sizeof(DOCA_t),-1,0,(char*)NULL,G__setup_memvarDOCA_t,G__setup_memfuncDOCA_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DPCP_t),sizeof(DPCP_t),-1,0,(char*)NULL,G__setup_memvarDPCP_t,G__setup_memfuncDPCP_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DPSP_t),sizeof(DPSP_t),-1,0,(char*)NULL,G__setup_memvarDPSP_t,G__setup_memfuncDPSP_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DSPC_t),sizeof(DSPC_t),-1,0,(char*)NULL,G__setup_memvarDSPC_t,G__setup_memfuncDSPC_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DSPS_t),sizeof(DSPS_t),-1,0,(char*)NULL,G__setup_memvarDSPS_t,G__setup_memfuncDSPS_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DSTC_t),sizeof(DSTC_t),-1,0,(char*)NULL,G__setup_memvarDSTC_t,G__setup_memfuncDSTC_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DTCP_t),sizeof(DTCP_t),-1,0,(char*)NULL,G__setup_memvarDTCP_t,G__setup_memfuncDTCP_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_DTRK_t),sizeof(DTRK_t),-1,0,(char*)NULL,G__setup_memvarDTRK_t,G__setup_memfuncDTRK_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_EC01_t),sizeof(EC01_t),-1,0,(char*)NULL,G__setup_memvarEC01_t,G__setup_memfuncEC01_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_EC1_t),sizeof(EC1_t),-1,0,(char*)NULL,G__setup_memvarEC1_t,G__setup_memfuncEC1_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_EC1P_t),sizeof(EC1P_t),-1,0,(char*)NULL,G__setup_memvarEC1P_t,G__setup_memfuncEC1P_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_EC1R_t),sizeof(EC1R_t),-1,0,(char*)NULL,G__setup_memvarEC1R_t,G__setup_memfuncEC1R_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECCA_t),sizeof(ECCA_t),-1,0,(char*)NULL,G__setup_memvarECCA_t,G__setup_memfuncECCA_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECCL_t),sizeof(ECCL_t),-1,0,(char*)NULL,G__setup_memvarECCL_t,G__setup_memfuncECCL_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECCT_t),sizeof(ECCT_t),-1,0,(char*)NULL,G__setup_memvarECCT_t,G__setup_memfuncECCT_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_EC_t),sizeof(EC_t),-1,0,(char*)NULL,G__setup_memvarEC_t,G__setup_memfuncEC_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECDI_t),sizeof(ECDI_t),-1,0,(char*)NULL,G__setup_memvarECDI_t,G__setup_memfuncECDI_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECG_t),sizeof(ECG_t),-1,0,(char*)NULL,G__setup_memvarECG_t,G__setup_memfuncECG_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECHB_t),sizeof(ECHB_t),-1,0,(char*)NULL,G__setup_memvarECHB_t,G__setup_memfuncECHB_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECH_t),sizeof(ECH_t),-1,0,(char*)NULL,G__setup_memvarECH_t,G__setup_memfuncECH_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECMT_t),sizeof(ECMT_t),-1,0,(char*)NULL,G__setup_memvarECMT_t,G__setup_memfuncECMT_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECP1_t),sizeof(ECP1_t),-1,0,(char*)NULL,G__setup_memvarECP1_t,G__setup_memfuncECP1_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECPB_t),sizeof(ECPB_t),-1,0,(char*)NULL,G__setup_memvarECPB_t,G__setup_memfuncECPB_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECPC_t),sizeof(ECPC_t),-1,0,(char*)NULL,G__setup_memvarECPC_t,G__setup_memfuncECPC_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECP_t),sizeof(ECP_t),-1,0,(char*)NULL,G__setup_memvarECP_t,G__setup_memfuncECP_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECPE_t),sizeof(ECPE_t),-1,0,(char*)NULL,G__setup_memvarECPE_t,G__setup_memfuncECPE_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECPI_t),sizeof(ECPI_t),-1,0,(char*)NULL,G__setup_memvarECPI_t,G__setup_memfuncECPI_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECPO_t),sizeof(ECPO_t),-1,0,(char*)NULL,G__setup_memvarECPO_t,G__setup_memfuncECPO_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECRB_t),sizeof(ECRB_t),-1,0,(char*)NULL,G__setup_memvarECRB_t,G__setup_memfuncECRB_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECS_t),sizeof(ECS_t),-1,0,(char*)NULL,G__setup_memvarECS_t,G__setup_memfuncECS_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ECT_t),sizeof(ECT_t),-1,0,(char*)NULL,G__setup_memvarECT_t,G__setup_memfuncECT_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_EID0_t),sizeof(EID0_t),-1,0,(char*)NULL,G__setup_memvarEID0_t,G__setup_memfuncEID0_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_EPIC_t),sizeof(EPIC_t),-1,0,(char*)NULL,G__setup_memvarEPIC_t,G__setup_memfuncEPIC_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_EVNT_t),sizeof(EVNT_t),-1,0,(char*)NULL,G__setup_memvarEVNT_t,G__setup_memfuncEVNT_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_FBPM_t),sizeof(FBPM_t),-1,0,(char*)NULL,G__setup_memvarFBPM_t,G__setup_memfuncFBPM_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_G1SL_t),sizeof(G1SL_t),-1,0,(char*)NULL,G__setup_memvarG1SL_t,G__setup_memfuncG1SL_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_G2SL_t),sizeof(G2SL_t),-1,0,(char*)NULL,G__setup_memvarG2SL_t,G__setup_memfuncG2SL_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_G3SL_t),sizeof(G3SL_t),-1,0,(char*)NULL,G__setup_memvarG3SL_t,G__setup_memfuncG3SL_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_G4SL_t),sizeof(G4SL_t),-1,0,(char*)NULL,G__setup_memvarG4SL_t,G__setup_memfuncG4SL_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_GPAR_t),sizeof(GPAR_t),-1,0,(char*)NULL,G__setup_memvarGPAR_t,G__setup_memfuncGPAR_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_GPID_t),sizeof(GPID_t),-1,0,(char*)NULL,G__setup_memvarGPID_t,G__setup_memfuncGPID_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_GP_X_t),sizeof(GP_X_t),-1,0,(char*)NULL,G__setup_memvarGP_X_t,G__setup_memfuncGP_X_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_GP_Y_t),sizeof(GP_Y_t),-1,0,(char*)NULL,G__setup_memvarGP_Y_t,G__setup_memfuncGP_Y_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_HBER_t),sizeof(HBER_t),-1,0,(char*)NULL,G__setup_memvarHBER_t,G__setup_memfuncHBER_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_HBID_t),sizeof(HBID_t),-1,0,(char*)NULL,G__setup_memvarHBID_t,G__setup_memfuncHBID_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_HBLA_t),sizeof(HBLA_t),-1,0,(char*)NULL,G__setup_memvarHBLA_t,G__setup_memfuncHBLA_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_HBTB_t),sizeof(HBTB_t),-1,0,(char*)NULL,G__setup_memvarHBTB_t,G__setup_memfuncHBTB_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_HBTR_t),sizeof(HBTR_t),-1,0,(char*)NULL,G__setup_memvarHBTR_t,G__setup_memfuncHBTR_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_HCAL_t),sizeof(HCAL_t),-1,0,(char*)NULL,G__setup_memvarHCAL_t,G__setup_memfuncHCAL_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_HDPL_t),sizeof(HDPL_t),-1,0,(char*)NULL,G__setup_memvarHDPL_t,G__setup_memfuncHDPL_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_HEAD_t),sizeof(HEAD_t),-1,0,(char*)NULL,G__setup_memvarHEAD_t,G__setup_memfuncHEAD_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_HEVT_t),sizeof(HEVT_t),-1,0,(char*)NULL,G__setup_memvarHEVT_t,G__setup_memfuncHEVT_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_HLS_t),sizeof(HLS_t),-1,0,(char*)NULL,G__setup_memvarHLS_t,G__setup_memfuncHLS_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_IC_t),sizeof(IC_t),-1,0,(char*)NULL,G__setup_memvarIC_t,G__setup_memfuncIC_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ICHB_t),sizeof(ICHB_t),-1,0,(char*)NULL,G__setup_memvarICHB_t,G__setup_memfuncICHB_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_KFIT_t),sizeof(KFIT_t),-1,0,(char*)NULL,G__setup_memvarKFIT_t,G__setup_memfuncKFIT_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_L1PG_t),sizeof(L1PG_t),-1,0,(char*)NULL,G__setup_memvarL1PG_t,G__setup_memfuncL1PG_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_L2H_t),sizeof(L2H_t),-1,0,(char*)NULL,G__setup_memvarL2H_t,G__setup_memfuncL2H_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_L2S_t),sizeof(L2S_t),-1,0,(char*)NULL,G__setup_memvarL2S_t,G__setup_memfuncL2S_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_LASR_t),sizeof(LASR_t),-1,0,(char*)NULL,G__setup_memvarLASR_t,G__setup_memfuncLASR_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_LCDI_t),sizeof(LCDI_t),-1,0,(char*)NULL,G__setup_memvarLCDI_t,G__setup_memfuncLCDI_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_LCPB_t),sizeof(LCPB_t),-1,0,(char*)NULL,G__setup_memvarLCPB_t,G__setup_memfuncLCPB_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_LOWQ_t),sizeof(LOWQ_t),-1,0,(char*)NULL,G__setup_memvarLOWQ_t,G__setup_memfuncLOWQ_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_MCEV_t),sizeof(MCEV_t),-1,0,(char*)NULL,G__setup_memvarMCEV_t,G__setup_memfuncMCEV_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_MCHD_t),sizeof(MCHD_t),-1,0,(char*)NULL,G__setup_memvarMCHD_t,G__setup_memfuncMCHD_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_MCTK_t),sizeof(MCTK_t),-1,0,(char*)NULL,G__setup_memvarMCTK_t,G__setup_memfuncMCTK_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_MCVX_t),sizeof(MCVX_t),-1,0,(char*)NULL,G__setup_memvarMCVX_t,G__setup_memfuncMCVX_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_MS1_t),sizeof(MS1_t),-1,0,(char*)NULL,G__setup_memvarMS1_t,G__setup_memfuncMS1_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_MTRK_t),sizeof(MTRK_t),-1,0,(char*)NULL,G__setup_memvarMTRK_t,G__setup_memfuncMTRK_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_MVRT_t),sizeof(MVRT_t),-1,0,(char*)NULL,G__setup_memvarMVRT_t,G__setup_memfuncMVRT_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_PART_t),sizeof(PART_t),-1,0,(char*)NULL,G__setup_memvarPART_t,G__setup_memfuncPART_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_PCO_t),sizeof(PCO_t),-1,0,(char*)NULL,G__setup_memvarPCO_t,G__setup_memfuncPCO_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_PHTM_t),sizeof(PHTM_t),-1,0,(char*)NULL,G__setup_memvarPHTM_t,G__setup_memfuncPHTM_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_PID1_t),sizeof(PID1_t),-1,0,(char*)NULL,G__setup_memvarPID1_t,G__setup_memfuncPID1_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_PID2_t),sizeof(PID2_t),-1,0,(char*)NULL,G__setup_memvarPID2_t,G__setup_memfuncPID2_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_PID3_t),sizeof(PID3_t),-1,0,(char*)NULL,G__setup_memvarPID3_t,G__setup_memfuncPID3_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_PID4_t),sizeof(PID4_t),-1,0,(char*)NULL,G__setup_memvarPID4_t,G__setup_memfuncPID4_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_PID5_t),sizeof(PID5_t),-1,0,(char*)NULL,G__setup_memvarPID5_t,G__setup_memfuncPID5_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_PID6_t),sizeof(PID6_t),-1,0,(char*)NULL,G__setup_memvarPID6_t,G__setup_memfuncPID6_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_PIDT_t),sizeof(PIDT_t),-1,0,(char*)NULL,G__setup_memvarPIDT_t,G__setup_memfuncPIDT_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_PRTM_t),sizeof(PRTM_t),-1,0,(char*)NULL,G__setup_memvarPRTM_t,G__setup_memfuncPRTM_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_PSO_t),sizeof(PSO_t),-1,0,(char*)NULL,G__setup_memvarPSO_t,G__setup_memfuncPSO_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_PTDB_t),sizeof(PTDB_t),-1,0,(char*)NULL,G__setup_memvarPTDB_t,G__setup_memfuncPTDB_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_RCST_t),sizeof(RCST_t),-1,0,(char*)NULL,G__setup_memvarRCST_t,G__setup_memfuncRCST_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_REF_t),sizeof(REF_t),-1,0,(char*)NULL,G__setup_memvarREF_t,G__setup_memfuncREF_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_RF_t),sizeof(RF_t),-1,0,(char*)NULL,G__setup_memvarRF_t,G__setup_memfuncRF_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_RFT_t),sizeof(RFT_t),-1,0,(char*)NULL,G__setup_memvarRFT_t,G__setup_memfuncRFT_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_RGLK_t),sizeof(RGLK_t),-1,0,(char*)NULL,G__setup_memvarRGLK_t,G__setup_memfuncRGLK_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_RNLG_t),sizeof(RNLG_t),-1,0,(char*)NULL,G__setup_memvarRNLG_t,G__setup_memfuncRNLG_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_RNPE_t),sizeof(RNPE_t),-1,0,(char*)NULL,G__setup_memvarRNPE_t,G__setup_memfuncRNPE_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_RTSL_t),sizeof(RTSL_t),-1,0,(char*)NULL,G__setup_memvarRTSL_t,G__setup_memfuncRTSL_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_RUNC_t),sizeof(RUNC_t),-1,0,(char*)NULL,G__setup_memvarRUNC_t,G__setup_memfuncRUNC_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_S1ST_t),sizeof(S1ST_t),-1,0,(char*)NULL,G__setup_memvarS1ST_t,G__setup_memfuncS1ST_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SC1_t),sizeof(SC1_t),-1,0,(char*)NULL,G__setup_memvarSC1_t,G__setup_memfuncSC1_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SCC_t),sizeof(SCC_t),-1,0,(char*)NULL,G__setup_memvarSCC_t,G__setup_memfuncSCC_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SC_t),sizeof(SC_t),-1,0,(char*)NULL,G__setup_memvarSC_t,G__setup_memfuncSC_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SCDI_t),sizeof(SCDI_t),-1,0,(char*)NULL,G__setup_memvarSCDI_t,G__setup_memfuncSCDI_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SCGD_t),sizeof(SCGD_t),-1,0,(char*)NULL,G__setup_memvarSCGD_t,G__setup_memfuncSCGD_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SCG_t),sizeof(SCG_t),-1,0,(char*)NULL,G__setup_memvarSCG_t,G__setup_memfuncSCG_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SCH_t),sizeof(SCH_t),-1,0,(char*)NULL,G__setup_memvarSCH_t,G__setup_memfuncSCH_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SCMD_t),sizeof(SCMD_t),-1,0,(char*)NULL,G__setup_memvarSCMD_t,G__setup_memfuncSCMD_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SCMT_t),sizeof(SCMT_t),-1,0,(char*)NULL,G__setup_memvarSCMT_t,G__setup_memfuncSCMT_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SCMW_t),sizeof(SCMW_t),-1,0,(char*)NULL,G__setup_memvarSCMW_t,G__setup_memfuncSCMW_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SCPB_t),sizeof(SCPB_t),-1,0,(char*)NULL,G__setup_memvarSCPB_t,G__setup_memfuncSCPB_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SCP_t),sizeof(SCP_t),-1,0,(char*)NULL,G__setup_memvarSCP_t,G__setup_memfuncSCP_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SCPE_t),sizeof(SCPE_t),-1,0,(char*)NULL,G__setup_memvarSCPE_t,G__setup_memfuncSCPE_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SCPS_t),sizeof(SCPS_t),-1,0,(char*)NULL,G__setup_memvarSCPS_t,G__setup_memfuncSCPS_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SCRC_t),sizeof(SCRC_t),-1,0,(char*)NULL,G__setup_memvarSCRC_t,G__setup_memfuncSCRC_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SCR_t),sizeof(SCR_t),-1,0,(char*)NULL,G__setup_memvarSCR_t,G__setup_memfuncSCR_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SCS_t),sizeof(SCS_t),-1,0,(char*)NULL,G__setup_memvarSCS_t,G__setup_memfuncSCS_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SCT_t),sizeof(SCT_t),-1,0,(char*)NULL,G__setup_memvarSCT_t,G__setup_memfuncSCT_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SGMP_t),sizeof(SGMP_t),-1,0,(char*)NULL,G__setup_memvarSGMP_t,G__setup_memfuncSGMP_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SPAR_t),sizeof(SPAR_t),-1,0,(char*)NULL,G__setup_memvarSPAR_t,G__setup_memfuncSPAR_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SPIN_t),sizeof(SPIN_t),-1,0,(char*)NULL,G__setup_memvarSPIN_t,G__setup_memfuncSPIN_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ST1_t),sizeof(ST1_t),-1,0,(char*)NULL,G__setup_memvarST1_t,G__setup_memfuncST1_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_ST_t),sizeof(ST_t),-1,0,(char*)NULL,G__setup_memvarST_t,G__setup_memfuncST_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_STG_t),sizeof(STG_t),-1,0,(char*)NULL,G__setup_memvarSTG_t,G__setup_memfuncSTG_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_STH_t),sizeof(STH_t),-1,0,(char*)NULL,G__setup_memvarSTH_t,G__setup_memfuncSTH_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_STN0_t),sizeof(STN0_t),-1,0,(char*)NULL,G__setup_memvarSTN0_t,G__setup_memfuncSTN0_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_STN1_t),sizeof(STN1_t),-1,0,(char*)NULL,G__setup_memvarSTN1_t,G__setup_memfuncSTN1_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_STPB_t),sizeof(STPB_t),-1,0,(char*)NULL,G__setup_memvarSTPB_t,G__setup_memfuncSTPB_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_STPE_t),sizeof(STPE_t),-1,0,(char*)NULL,G__setup_memvarSTPE_t,G__setup_memfuncSTPE_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_STR_t),sizeof(STR_t),-1,0,(char*)NULL,G__setup_memvarSTR_t,G__setup_memfuncSTR_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_STS_t),sizeof(STS_t),-1,0,(char*)NULL,G__setup_memvarSTS_t,G__setup_memfuncSTS_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_STSN_t),sizeof(STSN_t),-1,0,(char*)NULL,G__setup_memvarSTSN_t,G__setup_memfuncSTSN_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_SYNC_t),sizeof(SYNC_t),-1,0,(char*)NULL,G__setup_memvarSYNC_t,G__setup_memfuncSYNC_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TACO_t),sizeof(TACO_t),-1,0,(char*)NULL,G__setup_memvarTACO_t,G__setup_memfuncTACO_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TAGE_t),sizeof(TAGE_t),-1,0,(char*)NULL,G__setup_memvarTAGE_t,G__setup_memfuncTAGE_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TAGI_t),sizeof(TAGI_t),-1,0,(char*)NULL,G__setup_memvarTAGI_t,G__setup_memfuncTAGI_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TAGM_t),sizeof(TAGM_t),-1,0,(char*)NULL,G__setup_memvarTAGM_t,G__setup_memfuncTAGM_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TAGR_t),sizeof(TAGR_t),-1,0,(char*)NULL,G__setup_memvarTAGR_t,G__setup_memfuncTAGR_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TAGT_t),sizeof(TAGT_t),-1,0,(char*)NULL,G__setup_memvarTAGT_t,G__setup_memfuncTAGT_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TATL_t),sizeof(TATL_t),-1,0,(char*)NULL,G__setup_memvarTATL_t,G__setup_memfuncTATL_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TATR_t),sizeof(TATR_t),-1,0,(char*)NULL,G__setup_memvarTATR_t,G__setup_memfuncTATR_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TBER_t),sizeof(TBER_t),-1,0,(char*)NULL,G__setup_memvarTBER_t,G__setup_memfuncTBER_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TBID_t),sizeof(TBID_t),-1,0,(char*)NULL,G__setup_memvarTBID_t,G__setup_memfuncTBID_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TBLA_t),sizeof(TBLA_t),-1,0,(char*)NULL,G__setup_memvarTBLA_t,G__setup_memfuncTBLA_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TBTR_t),sizeof(TBTR_t),-1,0,(char*)NULL,G__setup_memvarTBTR_t,G__setup_memfuncTBTR_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TCSB_t),sizeof(TCSB_t),-1,0,(char*)NULL,G__setup_memvarTCSB_t,G__setup_memfuncTCSB_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TCT_t),sizeof(TCT_t),-1,0,(char*)NULL,G__setup_memvarTCT_t,G__setup_memfuncTCT_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TDPL_t),sizeof(TDPL_t),-1,0,(char*)NULL,G__setup_memvarTDPL_t,G__setup_memfuncTDPL_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TESC_t),sizeof(TESC_t),-1,0,(char*)NULL,G__setup_memvarTESC_t,G__setup_memfuncTESC_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TGBI_t),sizeof(TGBI_t),-1,0,(char*)NULL,G__setup_memvarTGBI_t,G__setup_memfuncTGBI_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TGEO_t),sizeof(TGEO_t),-1,0,(char*)NULL,G__setup_memvarTGEO_t,G__setup_memfuncTGEO_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TGPB_t),sizeof(TGPB_t),-1,0,(char*)NULL,G__setup_memvarTGPB_t,G__setup_memfuncTGPB_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TGS_t),sizeof(TGS_t),-1,0,(char*)NULL,G__setup_memvarTGS_t,G__setup_memfuncTGS_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TGTL_t),sizeof(TGTL_t),-1,0,(char*)NULL,G__setup_memvarTGTL_t,G__setup_memfuncTGTL_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TGTR_t),sizeof(TGTR_t),-1,0,(char*)NULL,G__setup_memvarTGTR_t,G__setup_memfuncTGTR_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TLV1_t),sizeof(TLV1_t),-1,0,(char*)NULL,G__setup_memvarTLV1_t,G__setup_memfuncTLV1_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TRCF_t),sizeof(TRCF_t),-1,0,(char*)NULL,G__setup_memvarTRCF_t,G__setup_memfuncTRCF_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TRGS_t),sizeof(TRGS_t),-1,0,(char*)NULL,G__setup_memvarTRGS_t,G__setup_memfuncTRGS_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TRKS_t),sizeof(TRKS_t),-1,0,(char*)NULL,G__setup_memvarTRKS_t,G__setup_memfuncTRKS_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TRL1_t),sizeof(TRL1_t),-1,0,(char*)NULL,G__setup_memvarTRL1_t,G__setup_memfuncTRL1_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TRPB_t),sizeof(TRPB_t),-1,0,(char*)NULL,G__setup_memvarTRPB_t,G__setup_memfuncTRPB_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TSPR_t),sizeof(TSPR_t),-1,0,(char*)NULL,G__setup_memvarTSPR_t,G__setup_memfuncTSPR_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_TSRG_t),sizeof(TSRG_t),-1,0,(char*)NULL,G__setup_memvarTSRG_t,G__setup_memfuncTSRG_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_UNUS_t),sizeof(UNUS_t),-1,0,(char*)NULL,G__setup_memvarUNUS_t,G__setup_memfuncUNUS_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_VERT_t),sizeof(VERT_t),-1,0,(char*)NULL,G__setup_memvarVERT_t,G__setup_memfuncVERT_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_RC26_t),sizeof(RC26_t),-1,0,(char*)NULL,G__setup_memvarRC26_t,G__setup_memfuncRC26_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_STRE_t),sizeof(STRE_t),-1,0,(char*)NULL,G__setup_memvarSTRE_t,G__setup_memfuncSTRE_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__bankvarsDictLN_addressBanks_t),sizeof(addressBanks_t),-1,0,(char*)NULL,G__setup_memvaraddressBanks_t,G__setup_memfuncaddressBanks_t);
   G__get_linked_tagnum_fwd(&G__bankvarsDictLN_vectorlETStringcOallocatorlETStringgRsPgR);
   G__get_linked_tagnum_fwd(&G__bankvarsDictLN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR);
}
extern "C" void G__cpp_setupbankvarsDict(void) {
  G__check_setup_version(30051515,"G__cpp_setupbankvarsDict()");
  G__set_cpp_environmentbankvarsDict();
  G__cpp_setup_tagtablebankvarsDict();

  G__cpp_setup_inheritancebankvarsDict();

  G__cpp_setup_typetablebankvarsDict();

  G__cpp_setup_memvarbankvarsDict();

  G__cpp_setup_memfuncbankvarsDict();
  G__cpp_setup_globalbankvarsDict();
  G__cpp_setup_funcbankvarsDict();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncbankvarsDict();
  return;
}
class G__cpp_setup_initbankvarsDict {
  public:
    G__cpp_setup_initbankvarsDict() { G__add_setup_func("bankvarsDict",(G__incsetup)(&G__cpp_setupbankvarsDict)); G__call_setup_funcs(); }
   ~G__cpp_setup_initbankvarsDict() { G__remove_setup_func("bankvarsDict"); }
};
G__cpp_setup_initbankvarsDict G__cpp_setup_initializerbankvarsDict;

